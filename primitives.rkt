#lang racket/base
(require ; version-case
         racket/bool
         racket/bytes
         racket/control
         racket/fasl
         racket/fixnum
         racket/flonum
         racket/hash
         racket/include
         racket/keyword
         racket/linklet
         racket/list
         racket/math
         racket/mpair         
         racket/mutability
         racket/path
         racket/port
         racket/string
         racket/struct
         racket/symbol
         racket/syntax-srcloc
         racket/vector
         racket/unsafe/ops
         ; racket/namespace
         (prefix-in readerr: syntax/readerr)
         
         math/flonum
         (only-in math/base
                  asinh acosh atanh
                  float-complex?)
         
         
         (prefix-in imm: "immediates.rkt")

         (only-in '#%kernel
                  prop:method-arity-error
                  prop:incomplete-arity)
         
         racket/match
         ; Used by the runtime code generated by `match`:
         (only-in racket/match/runtime syntax-srclocs match:error)) 

(provide include
         include/reader
         struct-copy
         (for-syntax read-syntax/skip-first-line))

(provide define-syntax define-for-syntax begin-for-syntax define-syntaxes)
(provide (for-syntax define-syntax syntax-case ... #%app #%datum))

(require (for-syntax
          (only-in racket/base
                   define-syntax-rule
                   define-syntax
                   syntax-case                   
                   syntax/loc
                   with-syntax
                   generate-temporaries
                   syntax-property
                   datum->syntax
                   syntax-e
                   quote
                   void
                   define-syntaxes
                   )))
(provide (for-syntax define-syntax-rule
                     define-syntax
                     syntax-case
                     syntax
                     syntax/loc
                     with-syntax
                     generate-temporaries
                     syntax-property
                     datum->syntax
                     syntax-e
                     quote
                     void
                     define-syntaxes
                     ))


(require (prefix-in kernel: racket/kernel))

;; These functions are implemented in `stdlib` as webracket functions
(provide error ; [twice to force indentation]         
         ;; stdlib/exceptions.rkt
         error

         struct:exn
         struct:exn:fail
         struct:exn:fail:contract
         struct:exn:fail:contract:arity
         struct:exn:fail:contract:divide-by-zero
         struct:exn:fail:contract:variable
         struct:exn:fail:read
         struct:exn:fail:read:eof
         struct:exn:fail:read:non-char
         struct:exn:fail:syntax
         struct:exn:fail:syntax:missing-module
         struct:exn:fail:syntax:unbound
         
         exn
         exn?
         exn-message
         exn-continuation-marks
         
         exn:fail   
         exn:fail?
         
         exn:fail:contract
         exn:fail:contract?
         exn:fail:contract:arity
         exn:fail:contract:arity?
         exn:fail:contract:divide-by-zero
         exn:fail:contract:divide-by-zero?
         exn:fail:contract:variable
         exn:fail:contract:variable?
         exn:fail:contract:variable-id

         exn:fail:read
         exn:fail:read?
         exn:fail:read-srclocs
         exn:fail:read:eof
         exn:fail:read:eof?
         exn:fail:read:non-char
         exn:fail:read:non-char?

         exn:fail:syntax
         exn:fail:syntax?
         exn:fail:syntax-exprs
         exn:fail:syntax:missing-module
         exn:fail:syntax:missing-module?
         exn:fail:syntax:missing-module-path
         exn:fail:syntax:unbound
         exn:fail:syntax:unbound?
         
         make-exn
         make-exn:fail
         make-exn:fail:contract
         make-exn:fail:contract:arity
         make-exn:fail:contract:divide-by-zero
         make-exn:fail:contract:variable
         make-exn:fail:read
         make-exn:fail:read:eof
         make-exn:fail:read:non-char
         make-exn:fail:syntax
         make-exn:fail:syntax:missing-module
         make-exn:fail:syntax:unbound

          ;; syntax/readerr 
         raise-read-error
         raise-read-eof-error
         
         ;; stdlib/ports.rkt
         current-input-port
         current-output-port
         current-error-port
         reset-current-input-port!
         reset-current-output-port!
         reset-current-error-port!
         ;; stdlib/reading.rkt
         read
         read-syntax
         ;; stdlib/writing.rkt
         print-pair-curly-braces
         print-mpair-curly-braces
         print-unreadable
         print-graph
         print-struct
         print-box
         print-vector-length
         print-hash-table
         print-boolean-long-form
         print-reader-abbreviations
         print-as-expression
         print-syntax-width
         print-value-columns
         current-write-relative-directory         
         write
         display
         print
         writeln
         displayln
         println
         
         error-print-width
         ; default-error-value->string-handler
         error-value->string-handler
         
         ; format  ; define in stdlib - not a primitive
         fprintf
         ; fprintf*  ; todo: remove
         printf
         eprintf
         )


;; The primitives and constants are:

(provide
 match match:error
 match-define
 ; in-list   ; see "core.rkt"
 ; in-string ; see "core.rkt"
 
 ; exceptions
 catch
 catch*
 

 ;; checkers
 check-list
 check-mlist
 check-range
 check-range-generic
 check-naturals
 check-string

 ;; structure type properties
 ;; (these are used in kw.rkt)
 prop:checked-procedure  
 prop:impersonator-of
 prop:method-arity-error
 prop:arity-string
 prop:incomplete-arity
 
 ;; 4.1 Equality
 eq?
 eqv?
 equal?
 eq-hash-code
 eqv-hash-code
 equal-hash-code
 equal-always?
 ; equal?/recur
 ; equal-always?/recur
 ;; equal-hash-code/recur
 ;; equal-secondary-hash-code
 ;; equal-always-hash-code
 ;; equal-always-hash-code/recur
 ;; equal-always-secondary-hash-code


 ;; 4.2 Booleans
 not
 boolean?
 boolean=?
 false?
 xor
 immutable?
 mutable-string?
 immutable-string?
 mutable-bytes?
 immutable-bytes?
 mutable-vector?
 immutable-vector?
 mutable-box?
 immutable-box?
 mutable-hash?
 immutable-hash?

 ;; 4.3 Numbers

;; 4.3.1 Number Types
 number?
 real?
 integer?
 exact?
 exact-integer?
 exact-nonnegative-integer?
 exact-positive-integer?
 nan?
 infinite?
 positive-integer?
 negative-integer?
 nonpositive-integer?
 nonnegative-integer?
 natural?
 inexact-real?
 inexact?
 inexact->exact
 exact->inexact
 real->double-flonum
  fixnum?
 flonum?
 double-flonum?
 single-flonum?
 single-flonum-available?
 zero?
 positive?
 negative?
 even?
 odd?

 ;; 4.3.2 Generic Numerics
 ;; 4.3.2.1 Arithmetic
 +
 -
 *
 /
 quotient
 remainder
 modulo
 quotient/remainder
 add1
 sub1
 gcd
 lcm
 abs
 sgn
 max
 min
 exact-round exact-floor exact-ceiling exact-truncate
 round
 floor
 ceiling
 truncate
 ;; 4.3.2.2 Number Comparison
 =
 <
 >
 <=
 >=
 ;; 4.3.2.3 Powers and Roots
 sqr
 sqrt
 integer-sqrt
 integer-sqrt/remainder
 expt
 exp
 log
 ;; 4.3.2.4 Trigonometric Functions
 sin
 cos
 tan
 asin
 acos
 atan
 sinh
 cosh
 tanh
 asinh
 acosh
 atanh
 ;; 4.3.2.5 Complex Numbers
 ;; 4.3.2.6 Bitwise Operations
 bitwise-ior
  bitwise-and
  bitwise-xor
  bitwise-not
  bitwise-bit-set?
  bitwise-first-bit-set  ; added in version 8.16
  bitwise-bit-field
  arithmetic-shift
  integer-length
  random 
 ;; 4.3.2.7 Random Numbers
 ;; 4.3.2.8 Other Randomness Utilities (racket/random)
 ;; 4.3.2.9 Number–String Conversions
 number->string
 string->number
 floating-point-bytes->real
 real->floating-point-bytes
 ;; 4.3.2.10 Extra Constants and Functions (racket/math)

 degrees->radians
 radians->degrees
 order-of-magnitude
 system-big-endian?

 ;; 4.3.3 Flonums (racket/flonum)
 ;; 4.3.3.1 Flonum Arithmetic
 fl+
 fl-
 fl*
 fl/
 fl=
 fl<
 fl>
 fl<=
 fl>=
 flabs
 fllog
 flexp
 flsqrt
 flsin
 flcos
 fltan
 flasin
 flacos
 flatan
 flround
 flfloor
 flceiling
 fltruncate
 flsingle
 flexpt
 flmin
 flmax
 ->fl
 fl->exact-integer
 flrandom
 flbit-field
 
 ;; 4.3.3.2 Flonum Vectors

 ;; 4.3.4 Fixnums (racket/fixnum)
 ;; 4.3.4.1 Fixnum Arithmetic
 fxzero?
 fx+
 fx-
 fx*
 fxquotient
 unsafe-fxquotient
 fxremainder
 fxmodulo
 fxabs
 fxand
 fxior
 fxxor
 fxnot
 fxlshift
 fxrshift
 fxpopcount
 fxpopcount32
 fxpopcount16
 fx+/wraparound
 fx-/wraparound
 fx*/wraparound
 fxlshift/wraparound
 fxrshift/logical
 fx=
 fx<
 fx>
 fx<=
 fx>=
 fxmin
 fxmax
 fx->fl
 fl->fx
 fixnum-for-every-system?
 ;; 4.3.4.2 Fixnum Vectors
 ;; 4.3.4.3 Fixnum Range
 most-positive-fixnum
 most-negative-fixnum

 
 ;; 4.4 Strings
 build-string
 make-string
 list->string
 substring

 string
 string?
 string-ref
 string-set!
 string-length
 string-append
 string-append-immutable
 string-append*
 string-join
 string-copy
 string-copy!
 string-fill!
 string-upcase
 string-downcase
 string-titlecase
 string-foldcase
 string->immutable-string
 string=?    string<?    string<=?    string>?    string>=?
 string-ci=? string-ci<? string-ci<=? string-ci>? string-ci>=?
 string-prefix?
 string-suffix?
 string-contains?
 string-replace
 string-find
 string-take string-take-right
 string-drop string-drop-right
 string-trim string-trim-left string-trim-right
 string-split
 
 string->list
 string->bytes/utf-8
 string-utf-8-length
 string->immutable-string
 
 ;; 4.5 Byte Strings
 bytes?
 bytes
 make-bytes
 bytes-ref
 bytes-set!
 bytes-length
 subbytes
 bytes-copy!
 bytes-copy
 bytes-fill!
 bytes-append
 bytes-append*
 bytes-join
 bytes->immutable-bytes
 byte?
 bytes->list
 list->bytes
 bytes=?
 bytes<?
 bytes>?
 bytes->string/utf-8

 ;; 4.6 Characters
 char? char->integer integer->char char-utf-8-length
 char=? char<? char<=? char>? char>=?
 char-downcase char-foldcase char-titlecase char-upcase
 char-ci=? char-ci<? char-ci<=? char-ci>? char-ci>=?
 char-whitespace? char-general-category char-grapheme-break-property
 char-alphabetic? char-lower-case? char-upper-case? char-title-case?
 char-numeric? char-symbolic? char-punctuation? char-graphic?
 char-whitespace? char-blank? char-iso-control? char-extended-pictographic?

 ;; 4.7 Symbols
 symbol?
 symbol=?  ; from racket/bool
 symbol<?
 string->symbol
 symbol->string
 string->uninterned-symbol
 symbol-interned?
 ; symbol-unreadable?
 gensym

 ;; 4.7.1
 symbol->immutable-string
 

;; 4.9 Keywords

 keyword?
 keyword->string
 keyword<?
 string->keyword
 ; 4.9.1 Additional Keyword Functions
 keyword->immutable-string
 
 
  ;; 4.10 Pairs and Lists
 pair?
 cons?
 null?
 empty?
 cons
 car
 cdr
 list?
 list
 list*
 make-list     ; racket/list
 build-list
 range range-proc
 inclusive-range inclusive-range-proc

 length
 list-ref
 list-tail
 list-update
 list-set
 first
 rest
 second
  third
  fourth
  fifth
 sixth
 seventh
 eighth
 ninth
 tenth
 eleventh
 twelfth
 thirteenth
 fourteenth
 fifteenth
 last
 last-pair
 append
 append*
 flatten
 reverse

 map
 andmap
 ormap
 append-map
 foldl foldr
 for-each
 count
 add-between
 cartesian-product
 permutations
 ; foldl
 ; foldr

 filter
 filter-map
 filter-not
 shuffle
 partition
 index-of
 index-where
 indexes-of
 indexes-where
 list-prefix?
 take-common-prefix
 drop-common-prefix
 split-common-prefix

 take           take-right
 takef          takef-right
 drop           drop-right
 dropf          dropf-right
 split-at       splitf-at 
 split-at-right splitf-at-right
 
 member  memq  memv  memw  memf  findf
 remove  remq  remv  remw  remf  
 remove* remq* remv* remw* remf* 

 argmax argmin
 group-by
 sort 
 
 assoc assw assv assq assf

 caar  cadr  cdar  cddr
 caaar caadr cadar caddr
 cdaar cdadr cddar cdddr
 caaaar caaadr caadar caaddr
 cadaar cadadr caddar cadddr
 cdaaar cdaadr cdadar cdaddr
 cddaar cddadr cdddar cddddr

 ;; 4.11 Mutable Pairs and Lists

 mpair?
 mcons
 mcar
 mcdr
 set-mcar!
 set-mcdr!
 
 ;; 4.12 Vectors
 vector vector-immutable vector? make-vector vector-ref vector-set!
 vector-length vector-fill! vector-copy! vector-empty?
 vector-take vector-take-right
 vector-drop vector-drop-right
 vector-split-at vector-split-at-right 
 vector-copy
 vector->list vector->values vector->immutable-vector
 list->vector
 vector-map vector-map! vector-append
 vector-extend ; racket 8.12
 vector-count
 vector-argmax vector-argmin
 vector-filter vector-filter-not
 vector-member vector-memq vector-memv
 vector-sort! vector-sort
 build-vector
 vector-set/copy
 
 ;; 4.14 Boxes
 ; boxed unboxed set-boxed!  ; internal
 box? box box-immutable unbox set-box! 

 ;; 4.15 Hash Tables
 hash?
 hash-eq?
 hash-eqv?
 hash-equal?
 hash-equal-always?

 hash-ref hash-ref! hash-set! hash-remove! hash-clear!
 hash-update!
 hash-has-key?
 hash-empty?
 hash-count
 hash->list
 hash-for-each
 hash-map
 hash-map/copy
 hash-keys
 hash-values
 hash-filter
 hash-filter-keys
 hash-filter-values

 make-empty-hasheq
 make-empty-hasheqv
 make-empty-hash
 make-empty-hashalw
 
 make-hasheq
 make-hasheqv
 make-hash
 make-hashalw

 eq-hash-code
 eqv-hash-code
 equal-hash-code

 
 ;; 4.20 Procedures
 procedure? apply procedure-rename procedure->external
 procedure-arity procedure-arity-mask procedure-arity-includes?
 primitive? primitive-closure? primitive-result-arity
 prop:procedure
 
 ;; 4.21 Void
 void? make-void void

 ;; 5.1 Structures
 make-struct-type
 make-struct-field-accessor
 make-struct-field-mutator
 make-struct-type-property
 
 struct-constructor-procedure? struct-predicate-procedure?
 struct-accessor-procedure? struct-mutator-procedure?
 struct? struct-type? current-inspector
 struct-type-property?
 struct-type-property-accessor-procedure?
 struct-type-property-predicate-procedure?
 struct->list
 struct->vector
 
 ;; 10.1 Multiple Values
 values
 call-with-values

 ;; 10.2 Exceptions
 call-with-exception-handler
 raise
 raise-argument-error
 ; raise-unbound-variable-reference

 ;; 10.2.5 Source Locations
 srcloc make-srcloc
 srcloc? srcloc-source srcloc-line srcloc-column srcloc-position srcloc-span
 srcloc->string

 identifier?
 
 syntax-srcloc  ; in racket/syntax-srcloc
 syntax-srclocs ; in racket/match/runtime.rkt
 
 ;; 10.5 Continuation Marks
 current-continuation-marks  ; dummy, always returns #f
 
 ;; 12.2 Syntac Object Content
 syntax?
 syntax-e

 syntax-source
 syntax-line
 syntax-column
 syntax-position
 syntax-span

 datum->syntax
 syntax->datum
 syntax->list
  
 ;; 13   Input and Output
 ;; 13.1 Ports
 eof
 eof-object?

 port?
 input-port?
 output-port?

 call-with-output-string

 ;; 13.2 Byte and String Input
 read-byte
 read-char
 read-bytes!
 read-string!
 read-bytes
 read-string
 byte-ready?
 char-ready?
 read-line
 peek-bytes!
 peek-string!
 peek-bytes
 peek-string
 peek-byte
 peek-char
 
 ;; 13.3 Byte and String Output
 write-byte
 write-char
 newline
 write-bytes
 write-string

 ;; 13.4 Reading
 
 ;; 13.5 Writing
 display
 displayln

 ;; 13.7 String Ports
 string-port?
 open-input-string open-output-string get-output-string
 open-input-bytes  open-output-bytes  get-output-bytes
 port-next-location
 port-count-lines!
 port-counts-lines?
 
 ;; 14.1 Namespaces
 namespace?
 make-empty-namespace
 namespace-variable-value-simple
 namespace-set-variable-value!
 namespace-undefine-variable! 
 ; namespace-variable-value
 ; namespace-has-key?

 ;; 14.5 Impersonators and Chaperones
 prop:impersonator-of

 ;; 14.9 Structure Inspectors
 object-name
 prop:object-name

 ;; 14.14 Linklets and the Core Compiler
 correlated?
 correlated-source
 correlated-line
 correlated-column
 correlated-position
 correlated-span
 correlated-e
 correlated->datum
 datum->correlated
 correlated-property
 correlated-property-symbol-keys

 instance?
 make-instance
 instance-variable-names
 instance-set-variable-value!
 instance-unset-variable!
 instance-variable-value
 
 ;; 15.1 Paths
 path?
 path-for-some-system?
 path-string?
 path->bytes
 path->string
 bytes->path

 ;; 17. Unsafe Operations
 unsafe-fx+ unsafe-fl/
 unsafe-flabs unsafe-flround unsafe-flfloor unsafe-flceiling unsafe-fltruncate
 unsafe-flsingle unsafe-flsin unsafe-flcos unsafe-fltan unsafe-flasin
 unsafe-flacos unsafe-flatan unsafe-fllog unsafe-flexp unsafe-flsqrt
 unsafe-flmin unsafe-flmax unsafe-flexpt
 unsafe-flrandom 
 unsafe-fx= unsafe-fx< unsafe-car unsafe-cdr
 unsafe-struct-ref unsafe-vector-length unsafe-vector-ref unsafe-vector*-length unsafe-vector*-set! unsafe-struct-set!
 unsafe-string-length



 
 ;; FFI
 
 s-exp->fasl
 fasl->s-exp
 procedure->external
 external-number->flonum
 external-string->string
 js-log
 external?

)

(define (js_log v)
  (displayln v))

(define (procedure->external p)
  (unless (procedure? p)
    (raise-argument-error 'procedure->external "procedure?" p))
  p)

(define (external-number->flonum x)
  (cond [(number? x) (exact->inexact x)]
        [else (raise-argument-error 'external-number->flonum "number?" x)]))

(define (external-string->string x)
  (cond [(string? x) x]
        [else (raise-argument-error 'external-string->string "string?" x)]))


;; Changed in version 8.15.0.7: Added string-find.

(define (string-find s contained)
  (define m
    (regexp-match-positions (regexp (regexp-quote contained)) s))
  (and m (car (car m))))

(define (fxzero? x)
  (and (fixnum? x)
       (zero? x)))

(define (most-positive-fixnum)
  imm:most-positive-fixnum)

(define (most-negative-fixnum)
  imm:most-negative-fixnum)


(define (string-take s n)
  (define l (string-length s))
  (when (> n l)
    (error 'string-take "attempt to take substring longer than string"))
  (substring s 0 n))

(define (string-take-right s n)
  (define l (string-length s))
  (when (> n l)
    (error 'string-take-right
           "attempt to take substring longer than string"))
  (substring s (- l n) l))

(define (string-drop s n)
  (define l (string-length s))
  (when (> n l)
    (error 'string-drop "attempt to drop substring longer than string"))
  (substring s n l))

(define (string-drop-right s n)
  (define l (string-length s))
  (when (> n l)
    (error 'string-drop-right
           "attempt to drop substring longer than string"))
  (substring s 0 (- l n)))

(define (string-trim-left s sep)
  ; trims s to the left by removing sep
  (define l (string-length s))
  (define n (let loop ([i 0])
              (cond
                [(> i l)                     n]
                [(eqv? (string-ref s i) sep) (loop (+ i 1))]
                [else                        i])))  
  (substring s n l))

(define (string-trim-right s sep)
  ; trims s to the left by removing sep
  (define l (string-length s))
  (define n (let loop ([i 0])
              (cond
                [(> i l)                     n]
                [(eqv? (string-ref s i) sep) (loop (+ i 1))]
                [else                        i])))  
  (substring s (- l n) l))


(struct boxed (x) #:transparent #:mutable)
(define (unboxed b)      (boxed-x b))
(define (set-boxed! b x) (set-boxed-x! b x))

(define (make-empty-hash)    (make-hash))
(define (make-empty-hasheq)  (make-hasheq))
(define (make-empty-hasheqv) (make-hasheqv))
(define (make-empty-hashalw) (make-hashalw))

(define (make-void) (void))

(define (namespace-variable-value-simple ns sym)
  (namespace-variable-value sym #t #f ns))

;; The inverse hyperbolic functions are from
;;   math/private/base/base-functions.rkt

(define (asinh x)
  (cond [(flonum? x)  (flasinh x)]
        [(eqv? x 0)  0]
        [(real? x)  (flasinh (fl x))]
        [(float-complex? x)  (log (+ x (sqrt (+ (* x x) 1.0))))]
        [else  (log (+ x (sqrt (+ (* x x) 1))))]))

(define (acosh x)
  (cond [(flonum? x)  (flacosh x)]
        [(eqv? x 1)  0]
        [(and (real? x) (x . >= . 1))  (flacosh (fl x))]
        [(float-complex? x)  (log (+ x (* (sqrt (+ x 1.0)) (sqrt (- x 1.0)))))]
        [else  (log (+ x (* (sqrt (+ x 1)) (sqrt (- x 1)))))]))

(define (atanh x)
  (cond [(flonum? x)  (flatanh x)]
        [(eqv? x 0)  0]
        [(real? x)  (flatanh (fl x))]
        [(float-complex? x)  (* 0.5 (- (log (+ 1.0 x)) (log (- 1.0 x))))]
        [else  (* 1/2 (- (log (+ 1 x)) (log (- 1 x))))]))


;; (require (for-syntax racket/base))  ; for version-case
;; (version-case
;;  [(version< (version) "8.16")
;;   (define (bitwise-first-bit-set n)
;;     (unless (exact-integer? n)
;;       (raise-argument-error 'bitwise-first-bit-set
;;                             "exact-integer?" n))
;;     (if (zero? n)
;;         -1
;;         (sub1 (integer-length (bitwise-and n (- n))))))])

(define (bitwise-first-bit-set n)
  (unless (exact-integer? n)
    (raise-argument-error 'bitwise-first-bit-set
                          "exact-integer?" n))
  (if (zero? n)
      -1
      (sub1 (integer-length (bitwise-and n (- n))))))

; This simplified version of random doesn't allow passing
; a random number generator.
(define random
  ;; Simple wrapper around Racket's `random` that exposes the same
  ;; optional argument behaviour to the rest of the system.  The RNG
  ;; state itself lives in `runtime-wasm.rkt` and is shared across
  ;; invocations of the Wasm primitive.
  (case-lambda
    [()        (racket:random)]
    [(k)       (racket:random k)]
    [(min max) (racket:random min max)]))

; The "real" apply is a macro (due to keyword arguments)
; This defines a plain apply as a procedure.
; (the machinery in `priminfo.rkt` expects a procedure)
(require (prefix-in racket: racket/base))
(define (apply proc . xss)
  (racket:apply racket:apply proc xss))

; Added in Racket 8.15.
(define (eleventh    xs) (list-ref xs 11))
(define (twelfth     xs) (list-ref xs 12))
(define (thirteenth  xs) (list-ref xs 13))
(define (fourteenth  xs) (list-ref xs 14))
(define (fifteenth   xs) (list-ref xs 15))


; FFI
(define (external? x) #f)

(define (js-log x)
  (displayln x))




(define (inclusive-range-proc start end [step #f])
  ;; Step defaults to 1 or -1 depending on order of start and end.
  ;; Uses flonum defaults when either boundary is inexact.
  (define default-step
    (if (<= start end)
        (if (or (inexact? start) (inexact? end)) 1.0 1)
        (if (or (inexact? start) (inexact? end)) -1.0 -1)))
  (inclusive-range start end (if step step default-step)))

(define (range-proc start-or-end [end #f] [step #f])
  (cond [(eq? end #f) (range start-or-end)]
        [(eq? step #f) (range start-or-end end)]
        [else (range start-or-end end step)]))

(define (range start-or-end [end #f] [step #f]) 
  (cond [(eq? end #f) (range start-or-end)]
        [(eq? step #f) (range start-or-end end)]
        [else (range start-or-end end step)]))

;; Checkers

(define (check-list l)
  (unless (list? l)
    (raise-argument-error 'in-list "list?" l)))

(define (check-string l)
  (unless (string? l)
    (raise-argument-error 'in-string "string?" l)))

(define (check-mlist l)
  (unless (or (mpair? l) (null? l))
    (raise-argument-error 'in-mlist "(or/c mpair? null?)" l)))

(define (check-range a b step)
  (check-range-generic 'in-range a b step))

(define (check-range-generic who a b step)
  (unless (real? a) (raise-argument-error who "real?" a))
  (unless (real? b) (raise-argument-error who "real?" b))
  (unless (real? step) (raise-argument-error who "real?" step)))

(define (check-naturals n)
  (unless (and (integer? n)
               (exact? n)
               (n . >= . 0))
    (raise-argument-error 'in-naturals
                          "exact-nonnegative-integer?"
                          n)))

(require (prefix-in racket: racket/list))
(define (add-between xs v)   ; simplified version without keyword arguments.
  (racket:add-between xs v))


; A simplified no-keywords version of string-join.
(define (string-join strs [maybe-sep " "])
  (define xs (add-between strs maybe-sep))
  (string-append* xs))

(require (prefix-in racket: racket/string))

; A simplified no-keywords version 
(define (string-replace str from to [all? #t])
  (racket:string-replace str from to all?))

; A simplified no-keywords version 
(define (sort xs less-than?)
  (racket:sort xs less-than?))


; Added in version Racket 8.12.
(define (vector-extend vec new-size [val 0])
  (define old-size (vector-length vec))
  (unless (and (exact-nonnegative-integer? new-size)
               (>= new-size old-size))
    (raise-argument-error 'vector-extend
                          "(and/c exact-nonnegative-integer? (>=/c (vector-length vec)))"
                          new-size))
  (define new-vec (make-vector new-size val))
  (for ([i (in-range old-size)])
    (vector-set! new-vec i (vector-ref vec i)))
  new-vec)

(require (prefix-in racket: racket/vector))
         
; A simplified no-keywords version 
(define (vector-sort! vec less-than? [start 0] [end (vector-length #f)])
  (racket:vector-sort! vec less-than? start end))

; A simplified no-keywords version 
(define (vector-sort vec less-than? [start 0] [end (vector-length #f)])
  (racket:vector-sort vec less-than? start end))


(require (prefix-in racket: math/flonum))
; This simplified version of flrandom ignores the random generator argument.
(define flrandom
  ;; Mirrors the WebAssembly primitive's semantics by always using the
  ;; shared generator.
  (case-lambda
    [()  (racket:flrandom)]
    [(_) (racket:flrandom)]))

(define unsafe-flrandom flrandom)


; A simplified no-keywords version 
(define (hash-map/copy ht proc [kind #f])
  (racket:hash-map/copy ht proc kind))


; A simplified no-keywords version 
; A simplified positional version of string-split.
; Notes:
;   * Keyword arguments are not supported.
;   * Regular-expression separators are not supported; `sep` must be a string.
(define (string-split str [sep " "] [trim? #t] [repeat? #f])
  (unless (string? str) (raise-argument-error 'string-split "string?" str))
  (unless (string? sep) (raise-argument-error 'string-split "string?" sep))
  (define trim?-flag   (not (eq? trim? #f)))
  (define repeat?-flag (not (eq? repeat? #f)))
  (racket:string-split str sep #:trim? trim?-flag #:repeat? repeat?-flag))


; A simplified no-keywords version 
; A simplified positional version of string-trim.
; Notes:
;   * Keyword arguments are not supported.
;   * Regular-expression separators are not supported; `sep` must be a string.
(define (string-trim str [sep " "] [left? #t] [right? #t] [repeat? #f])
  (unless (string? str) (raise-argument-error 'string-trim "string?" str))
  (unless (string? sep) (raise-argument-error 'string-trim "string?" sep))
  (define left?-flag    (not (eq? left?   #f)))
  (define right?-flag   (not (eq? right?  #f)))
  (define repeat?-flag  (not (eq? repeat? #f)))
  (racket:string-trim str sep
                      #:left?   left?-flag
                      #:right?  right?-flag
                      #:repeat? repeat?-flag))


; Not added until Racket 8.13
(define (hash-filter ht pred)
  (define eq?  (hash-eq? ht))
  (define eqv? (hash-eqv? ht))
  (define imm? (immutable? ht))
  (if imm?
      (let ([pairs (for/list ([(k v) (in-hash ht)]
                              #:when (pred k v))
                     (cons k v))])
        (cond
          [eq?  (make-immutable-hasheq pairs)]
          [eqv? (make-immutable-hasheqv pairs)]
          [else (make-immutable-hash pairs)]))
      (let ([out (cond
                   [eq?  (make-hasheq)]
                   [eqv? (make-hasheqv)]
                   [else (make-hash)])])
        (for ([(k v) (in-hash ht)]
              #:when (pred k v))
          (hash-set! out k v))
        out)))

; Not added until Racket 8.12.0.9
(define (hash-filter-keys ht pred)
  (define eq?  (hash-eq? ht))
  (define eqv? (hash-eqv? ht))
  (define imm? (immutable? ht))
  (if imm?
      (let ([pairs (for/list ([(k v) (in-hash ht)]
                              #:when (pred k))
                     (cons k v))])
        (cond
          [eq?  (make-immutable-hasheq pairs)]
          [eqv? (make-immutable-hasheqv pairs)]
          [else (make-immutable-hash pairs)]))
      (let ([out (cond
                   [eq?  (make-hasheq)]
                   [eqv? (make-hasheqv)]
                   [else (make-hash)])])
        (for ([(k v) (in-hash ht)]
              #:when (pred k))
          (hash-set! out k v))
        out)))

; Not added until Racket 8.12.0.9
(define (hash-filter-values ht pred)
  (define eq?  (hash-eq? ht))
  (define eqv? (hash-eqv? ht))
  (define imm? (immutable? ht))
  (if imm?
      (let ([pairs (for/list ([(k v) (in-hash ht)]
                              #:when (pred v))
                     (cons k v))])
        (cond
          [eq?  (make-immutable-hasheq pairs)]
          [eqv? (make-immutable-hasheqv pairs)]
          [else (make-immutable-hash pairs)]))
      (let ([out (cond
                   [eq?  (make-hasheq)]
                   [eqv? (make-hasheqv)]
                   [else (make-hash)])])
        (for ([(k v) (in-hash ht)]
              #:when (pred v))
          (hash-set! out k v))
        out)))

; Added in version 8.15.0.3 of package base.
(define (flbit-field a start end)
  ;; Contracts / checks
  (unless (flonum? a)
    (raise-argument-error 'flbit-field "flonum?" a))
  (unless (and (exact-integer? start) (<= 0 start 64))
    (raise-argument-error 'flbit-field "(integer-in 0 64)" start))
  (unless (and (exact-integer? end) (<= 0 end 64))
    (raise-argument-error 'flbit-field "(integer-in 0 64)" end))
  (when (> start end)
    (raise-arguments-error 'flbit-field
      "start must be <= end" "start" start "end" end))

  ;; Get IEEE-754 bytes in a known order (little-endian).
  (define bs (real->floating-point-bytes a 8 'little-endian))

  ;; Pack bytes into an exact, nonnegative 64-bit integer.
  (define u64
    (let loop ([i 0] [acc 0])
      (if (= i 8)
          acc
          (loop (add1 i)
                (bitwise-ior acc
                  (arithmetic-shift (bytes-ref bs i) (* 8 i)))))))

  ;; Slice [start, end) from that bitstring.
  (define width (- end start))
  (cond
    [(zero? width) 0]
    [else
     (define shifted (arithmetic-shift u64 (- start))) ; right shift
     (define mask (sub1 (arithmetic-shift 1 width)))   ; (1<<width)-1
     (bitwise-and shifted mask)]))


(define (in-list xs)   'in-list)
(define (in-string xs) 'in-string)


; Redefine to avoid `srcloc` being bound as syntax
(define (srcloc source line column position span)
  (racket:srcloc source line column position span))

(define (syntax-source stx)
  (racket:syntax-source stx))

(define (syntax-line stx)
  (racket:syntax-line stx))

(define (syntax-column stx)
  (racket:syntax-column stx))

(define (syntax-position stx)
  (racket:syntax-position stx))

(define (syntax-span stx)
  (racket:syntax-span stx))


; Redefine to avoid `struct->list` being bound as syntax
; And to avoid keyword arguments.
(require (prefix-in racket: racket/struct))
(define (struct->list s [on-opaque 'error])
  (racket:struct->list s on-opaque))

(define (struct->vector s [opaque-v '...])
  (racket:struct->vector s opaque-v))


; To avoid keyword arguments
(define (raise-read-error message source line column position span [extra-srclocs '()])
  (readerr:raise-read-error message source line column position span
                            #:extra-srclocs extra-srclocs))

; To avoid keyword arguments
(define (raise-read-eof-error message source line column position span [extra-srclocs '()])
  (readerr:raise-read-eof-error message source line column position span
                                #:extra-srclocs extra-srclocs))

;;;
;;; STANDARD LIBRARY
;;;

;; The standard library contains implementations of many primitives.
;; For most we simply use the Racket counter parts.
;; A few non-Racket functions are needed across the stdlib-files,
;; so we need implementations to make `#lang webracket` work.

;;; ports.rkt

(define (reset-current-input-port!)
  (current-input-port (open-input-string "")))

(define (reset-current-output-port!)
  (current-output-port (open-output-string)))

(define (reset-current-error-port!)
  (current-error-port (open-output-string)))



;;;
;;; Inclusion
;;;

(require (for-syntax racket/base))

(begin-for-syntax
  (define (read-syntax/skip-first-line
           [source-name (object-name (current-input-port))]
           [in          (current-input-port)])
    (read-line in) ; skip first line
    (read-syntax source-name in)))


;;;
;;; Exceptions
;;;

(struct exn/tag (value) #:transparent)

(define (always-throw)
  (raise (exn/tag 42)))


(define (catch* preds handlers thunk)
  (unless (procedure? thunk)
    (raise-argument-error 'catch* "procedure?" thunk))
  (unless (list? preds)
    (raise-argument-error 'catch* "list?" preds))
  (unless (list? handlers)
    (raise-argument-error 'catch* "list?" handlers))
  (unless (= (length preds) (length handlers))
    (raise-argument-error 'catch* "same number of handlers as predicates" handlers))
  (for ([pred preds])
    (unless (procedure? pred)
      (raise-argument-error 'catch* "procedure?" pred)))
  (for ([handler handlers])
    (unless (procedure? handler)
      (raise-argument-error 'catch* "procedure?" handler)))
  (define clauses (map cons preds handlers))
  (let loop ([rest (reverse clauses)])
    (if (null? rest)
        (thunk)
        (let ([clause (car rest)])
          (with-handlers ([(car clause) (cdr clause)])
            (loop (cdr rest)))))))


(define (catch predicate handler thunk)
  (unless (procedure? predicate)
    (raise-argument-error 'catch "procedure?" predicate))
  (unless (procedure? handler)
    (raise-argument-error 'catch "procedure?" handler))
  (unless (procedure? thunk)
    (raise-argument-error 'catch "procedure?" thunk))
  (with-handlers ([(λ (value) (predicate value)) handler])
    (thunk)))
