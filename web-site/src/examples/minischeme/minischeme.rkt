;;;
;;; MiniScheme Interpreter (shared by minischeme-page)
;;;

;; Generated by build.sh for website builds; defaults to a static value in repo.
(include "build-id.rkt")

(define-values (minischeme-reset-state! minischeme-process-input)
  (let ()
    (struct env       (table parent))
    (struct closure   (params body env))
    (struct prim      (name proc))
    (struct mvals     (vals))
    (struct captured-kont (kont env winds))
    (struct wind      (before after))
    (struct k-apply   (args env))
    (struct k-args    (proc rest env values))
    (struct k-if      (then else env))
    (struct k-begin   (rest env))
    (struct k-set!    (cell name))
    (struct k-define  (cell name))
    (struct k-dw-enter (wf thunk env winds-before))
    (struct k-dw-exit (after env winds-before))
    (struct k-dw-return (produced env winds-before))

    (define uninitialized (gensym 'uninitialized))
    (define no-else       (gensym 'no-else))

    (define (make-env parent)
      (env (make-hasheq) parent))

    (define (env-bound-current? e name)
      (hash-has-key? (env-table e) name))

    (define (env-lookup-cell e name)
      (cond
        [(hash-has-key? (env-table e) name)
         (hash-ref (env-table e) name)]
        [(env-parent e)
         (env-lookup-cell (env-parent e) name)]
        [else
         (error 'minischeme "unbound identifier ~a" name)]))

    (define (cell-value cell)
      (define v (unbox cell))
      (if (eq? v uninitialized)
          (error 'minischeme "accessing uninitialized binding")
          v))

    (define (env-lookup e name)
      (cell-value (env-lookup-cell e name)))

    (define (env-define! e name value)
      (hash-set! (env-table e) name (box value)))

    (define (env-define-cell! e name cell)
      (hash-set! (env-table e) name cell))

    (define (literal? expr)
      (or (boolean? expr)
          (number? expr)
          (string? expr)
          (char? expr)
          (null? expr)))

    (define (ensure-identifier sym)
      (unless (symbol? sym)
        (error 'minischeme "expected identifier, got ~a" sym)))

    (define (ensure-parameters params)
      (define (bad)
        (error 'minischeme "invalid parameter list ~a" params))
      (cond
        [(symbol? params) params]
        [(null? params) params]
        [(pair? params)
         (let loop ([ps params])
           (cond
             [(null? ps) params]
             [(pair? ps)
              (unless (symbol? (car ps)) (bad))
              (loop (cdr ps))]
             [(symbol? ps) params]
             [else (bad)]))]
        [else (bad)]))

    (define (split-formals params)
      (cond
        [(symbol? params) (values '() params)]
        [(null? params) (values '() #f)]
        [else
         (let loop ([ps params] [required '()])
           (cond
             [(null? ps) (values (reverse required) #f)]
             [(pair? ps) (loop (cdr ps) (cons (car ps) required))]
             [else (values (reverse required) ps)]))]))

    (define (check-numbers name args)
      (for-each (λ (v)
                  (unless (number? v)
                    (error 'minischeme "~a expects numbers, got ~a" name v)))
                args))

    (define (check-integers name args)
      (for-each (λ (v)
                  (unless (integer? v)
                    (error 'minischeme "~a expects integers, got ~a" name v)))
                args))

    (define (check-reals name args)
      (for-each (λ (v)
                  (unless (real? v)
                    (error 'minischeme "~a expects real numbers, got ~a" name v)))
                args))

    (define (check-arg-count name args expected)
      (unless (= (length args) expected)
        (error 'minischeme "~a expects ~a argument~a"
               name expected (if (= expected 1) "" "s"))))

    (define (check-at-least name args expected)
      (unless (>= (length args) expected)
        (error 'minischeme "~a expects at least ~a argument~a"
               name expected (if (= expected 1) "" "s"))))

    (define (value->values-list v)
      (if (mvals? v) (mvals-vals v) (list v)))

    (define (single-value who v)
      (if (mvals? v)
          (let ([vs (mvals-vals v)])
            (if (= (length vs) 1)
                (car vs)
                (error 'minischeme "~a: expected 1 value, got ~a" who (length vs))))
          v))

    (define (ensure-list who v)
      (unless (list? v)
        (error 'minischeme "~a expects a list, got ~a" who v)))

    (define (procedure-value? v)
      (or (closure? v)
          (prim? v)
          (captured-kont? v)))

    (define (create-initial-state)
      (define base-env (make-env #f))

      (define all-primitives '())
      (define all-constants  '())
      (define all-keywords   '())

      (define (install name proc)
        (env-define! base-env name (prim name proc))
        (set! all-primitives (cons name all-primitives)))

      (define (numeric name f)
        (install name (λ (args)
                        (check-numbers name args)
                        (apply f args))))
      (define (constant name value)
        (env-define! base-env name value)
        (set! all-constants (cons name all-constants)))

      (define (list-tail* who lst idx)
        (unless (exact-nonnegative-integer? idx)
          (error 'minischeme "~a expects a nonnegative exact integer index, got ~a" who idx))
        (let loop ([xs lst] [n idx])
          (if (= n 0)
              xs
              (begin
                (unless (pair? xs)
                  (error 'minischeme "~a: index out of bounds for list-like value" who))
                (loop (cdr xs) (sub1 n))))))

      (define (mem* who cmp key lst)
        (let loop ([xs lst])
          (cond
            [(null? xs) #f]
            [(pair? xs)
             (if (cmp key (car xs))
                 xs
                 (loop (cdr xs)))]
            [else
             (error 'minischeme "~a expects a proper list, got ~a" who lst)])))

      (define (assoc* who cmp key alist)
        (let loop ([xs alist])
          (cond
            [(null? xs) #f]
            [(pair? xs)
             (define entry (car xs))
             (unless (pair? entry)
               (error 'minischeme "~a expects an association list of pairs, got entry ~a" who entry))
             (if (cmp key (car entry))
                 entry
                 (loop (cdr xs)))]
            [else
             (error 'minischeme "~a expects a proper association list, got ~a" who alist)])))

      (define (selector-apply who v middle)
        (let loop ([x v] [ops (reverse (string->list middle))])
          (if (null? ops)
              x
              (begin
                (unless (pair? x)
                  (error 'minischeme "~a expects a pair while traversing, got ~a" who x))
                (loop (if (char=? (car ops) #\a) (car x) (cdr x))
                      (cdr ops))))))

      (constant 'null  '())
      (constant 'empty '())
      (constant 'true  #t)
      (constant 'false #f)
      (constant 'build-id minischeme-build-id)

      (numeric '+ +)
      (numeric '* *)
      (install '- (λ (args)
                    (check-at-least '- args 1)
                    (check-numbers '- args)
                    (if (null? (cdr args))
                        (- (car args))
                        (apply - args))))
      (install '/ (λ (args)
                    (check-at-least '/ args 1)
                    (check-numbers '/ args)
                    (if (null? (cdr args))
                        (/ 1 (car args))
                        (apply / args))))
      (install '= (λ (args)
                    (check-numbers '= args)
                    (if (null? args) #t (apply = args))))
      (install '< (λ (args)
                    (check-at-least '< args 2)
                    (check-numbers '< args)
                    (apply < args)))
      (install '<= (λ (args)
                     (check-at-least '<= args 2)
                     (check-numbers '<= args)
                     (apply <= args)))
      (install '> (λ (args)
                    (check-at-least '> args 2)
                    (check-numbers '> args)
                    (apply > args)))
      (install '>= (λ (args)
                     (check-at-least '>= args 2)
                     (check-numbers '>= args)
                     (apply >= args)))
      (install 'cons (λ (args)
                       (check-arg-count 'cons args 2)
                       (cons (car args) (cadr args))))
      (install 'car (λ (args)
                      (check-arg-count 'car args 1)
                      (let ([v (car args)])
                        (unless (pair? v)
                          (error 'minischeme "car expects a non-empty pair"))
                        (car v))))
      (install 'cdr (λ (args)
                      (check-arg-count 'cdr args 1)
                      (let ([v (car args)])
                        (unless (pair? v)
                          (error 'minischeme "cdr expects a non-empty pair"))
                        (cdr v))))
      (install 'list (λ (args) args))
      (install 'list? (λ (args)
                        (check-arg-count 'list? args 1)
                        (list? (car args))))
      (install 'pair? (λ (args)
                        (check-arg-count 'pair? args 1)
                        (pair? (car args))))
      (install 'null? (λ (args)
                        (check-arg-count 'null? args 1)
                        (null? (car args))))
      (install 'symbol? (λ (args)
                          (check-arg-count 'symbol? args 1)
                          (symbol? (car args))))
      (install 'number? (λ (args)
                          (check-arg-count 'number? args 1)
                          (number? (car args))))
      (install 'real? (λ (args)
                        (check-arg-count 'real? args 1)
                        (real? (car args))))
      (install 'rational? (λ (args)
                            (check-arg-count 'rational? args 1)
                            (and (real? (car args))
                                 (not (nan? (car args)))
                                 (not (infinite? (car args))))))
      (install 'integer? (λ (args)
                           (check-arg-count 'integer? args 1)
                           (integer? (car args))))
      (install 'exact? (λ (args)
                         (check-arg-count 'exact? args 1)
                         (exact? (car args))))
      (install 'inexact? (λ (args)
                           (check-arg-count 'inexact? args 1)
                           (inexact? (car args))))
      (install 'boolean? (λ (args)
                           (check-arg-count 'boolean? args 1)
                           (boolean? (car args))))
      (install 'not (λ (args)
                      (check-arg-count 'not args 1)
                      (false? (car args))))
      (install 'equal? (λ (args)
                         (check-arg-count 'equal? args 2)
                         (equal? (car args) (cadr args))))
      (install 'append (λ (args)
                         (for-each (λ (v) (ensure-list 'append v)) args)
                         (apply append args)))
      (install 'reverse (λ (args)
                          (check-arg-count 'reverse args 1)
                          (ensure-list 'reverse (car args))
                          (reverse (car args))))
      (install 'length (λ (args)
                         (check-arg-count 'length args 1)
                         (ensure-list 'length (car args))
                         (length (car args))))
      (install 'list-ref (λ (args)
                           (check-arg-count 'list-ref args 2)
                           (define lst (car args))
                           (define idx (cadr args))
                           (ensure-list 'list-ref lst)
                           (unless (exact-nonnegative-integer? idx)
                             (error 'minischeme "list-ref expects a nonnegative exact integer index, got ~a" idx))
                           (list-ref lst idx)))
      (install 'list-tail (λ (args)
                            (check-arg-count 'list-tail args 2)
                            (list-tail* 'list-tail (car args) (cadr args))))
      (install 'memq (λ (args)
                       (check-arg-count 'memq args 2)
                       (mem* 'memq eq? (car args) (cadr args))))
      (install 'memv (λ (args)
                       (check-arg-count 'memv args 2)
                       (mem* 'memv eqv? (car args) (cadr args))))
      (install 'member (λ (args)
                         (check-arg-count 'member args 2)
                         (mem* 'member equal? (car args) (cadr args))))
      (install 'assq (λ (args)
                       (check-arg-count 'assq args 2)
                       (assoc* 'assq eq? (car args) (cadr args))))
      (install 'assv (λ (args)
                       (check-arg-count 'assv args 2)
                       (assoc* 'assv eqv? (car args) (cadr args))))
      (install 'assoc (λ (args)
                        (check-arg-count 'assoc args 2)
                        (assoc* 'assoc equal? (car args) (cadr args))))
      (for-each
       (λ (name)
         (define name-str (symbol->string name))
         (define middle (substring name-str 1 (sub1 (string-length name-str))))
         (install name (λ (args)
                         (check-arg-count name args 1)
                         (selector-apply name (car args) middle))))
       '(caar cadr cdar cddr
         caaar caadr cadar caddr cdaar cdadr cddar cdddr
         caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr
         cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr))
      (install 'zero? (λ (args)
                        (check-arg-count 'zero? args 1)
                        (unless (number? (car args))
                          (error 'minischeme "zero? expects a number, got ~a" (car args)))
                        (zero? (car args))))
      (install 'add1 (λ (args)
                       (check-arg-count 'add1 args 1)
                       (unless (number? (car args))
                         (error 'minischeme "add1 expects a number, got ~a" (car args)))
                       (add1 (car args))))
      (install 'sub1 (λ (args)
                       (check-arg-count 'sub1 args 1)
                       (unless (number? (car args))
                         (error 'minischeme "sub1 expects a number, got ~a" (car args)))
                       (sub1 (car args))))
      (install 'positive? (λ (args)
                            (check-arg-count 'positive? args 1)
                            (unless (number? (car args))
                              (error 'minischeme "positive? expects a number, got ~a" (car args)))
                            (positive? (car args))))
      (install 'negative? (λ (args)
                            (check-arg-count 'negative? args 1)
                            (unless (number? (car args))
                              (error 'minischeme "negative? expects a number, got ~a" (car args)))
                            (negative? (car args))))
      (install 'even? (λ (args)
                        (check-arg-count 'even? args 1)
                        (unless (integer? (car args))
                          (error 'minischeme "even? expects an integer, got ~a" (car args)))
                        (even? (car args))))
      (install 'odd? (λ (args)
                       (check-arg-count 'odd? args 1)
                       (unless (integer? (car args))
                         (error 'minischeme "odd? expects an integer, got ~a" (car args)))
                       (odd? (car args))))
      (install 'abs (λ (args)
                      (check-arg-count 'abs args 1)
                      (unless (number? (car args))
                        (error 'minischeme "abs expects a number, got ~a" (car args)))
                      (abs (car args))))
      (install 'quotient (λ (args)
                           (check-arg-count 'quotient args 2)
                           (check-integers 'quotient args)
                           (quotient (car args) (cadr args))))
      (install 'remainder (λ (args)
                            (check-arg-count 'remainder args 2)
                            (check-integers 'remainder args)
                            (remainder (car args) (cadr args))))
      (install 'modulo (λ (args)
                         (check-arg-count 'modulo args 2)
                         (check-integers 'modulo args)
                         (modulo (car args) (cadr args))))
      (install 'gcd (λ (args)
                      (check-integers 'gcd args)
                      (apply gcd args)))
      (install 'lcm (λ (args)
                      (check-integers 'lcm args)
                      (apply lcm args)))
      (install 'numerator (λ (args)
                            (check-arg-count 'numerator args 1)
                            (unless (integer? (car args))
                              (error 'minischeme "numerator currently supports integers only, got ~a" (car args)))
                            (car args)))
      (install 'denominator (λ (args)
                              (check-arg-count 'denominator args 1)
                              (unless (integer? (car args))
                                (error 'minischeme "denominator currently supports integers only, got ~a" (car args)))
                              1))
      (install 'floor (λ (args)
                        (check-arg-count 'floor args 1)
                        (check-reals 'floor args)
                        (floor (car args))))
      (install 'ceiling (λ (args)
                          (check-arg-count 'ceiling args 1)
                          (check-reals 'ceiling args)
                          (ceiling (car args))))
      (install 'truncate (λ (args)
                           (check-arg-count 'truncate args 1)
                           (check-reals 'truncate args)
                           (truncate (car args))))
      (install 'round (λ (args)
                        (check-arg-count 'round args 1)
                        (check-reals 'round args)
                        (round (car args))))
      (install 'rationalize (λ (args)
                              (check-arg-count 'rationalize args 2)
                              (check-reals 'rationalize args)
                              (car args)))
      (install 'max (λ (args)
                      (check-at-least 'max args 1)
                      (check-numbers 'max args)
                      (apply max args)))
      (install 'min (λ (args)
                      (check-at-least 'min args 1)
                      (check-numbers 'min args)
                      (apply min args)))
      (install 'exp (λ (args)
                      (check-arg-count 'exp args 1)
                      (check-numbers 'exp args)
                      (exp (car args))))
      (install 'log (λ (args)
                      (check-arg-count 'log args 1)
                      (check-numbers 'log args)
                      (log (car args))))
      (install 'sin (λ (args)
                      (check-arg-count 'sin args 1)
                      (check-numbers 'sin args)
                      (sin (car args))))
      (install 'cos (λ (args)
                      (check-arg-count 'cos args 1)
                      (check-numbers 'cos args)
                      (cos (car args))))
      (install 'tan (λ (args)
                      (check-arg-count 'tan args 1)
                      (check-numbers 'tan args)
                      (tan (car args))))
      (install 'asin (λ (args)
                       (check-arg-count 'asin args 1)
                       (check-numbers 'asin args)
                       (asin (car args))))
      (install 'acos (λ (args)
                       (check-arg-count 'acos args 1)
                       (check-numbers 'acos args)
                       (acos (car args))))
      (install 'atan (λ (args)
                       (unless (or (= (length args) 1) (= (length args) 2))
                         (error 'minischeme "atan expects 1 or 2 arguments"))
                       (check-numbers 'atan args)
                       (if (= (length args) 1)
                           (atan (car args))
                           (atan (car args) (cadr args)))))
      (install 'sqrt (λ (args)
                       (check-arg-count 'sqrt args 1)
                       (check-numbers 'sqrt args)
                       (sqrt (car args))))
      (install 'expt (λ (args)
                       (check-arg-count 'expt args 2)
                       (check-numbers 'expt args)
                       (expt (car args) (cadr args))))
      (install 'exact->inexact (λ (args)
                                 (check-arg-count 'exact->inexact args 1)
                                 (check-numbers 'exact->inexact args)
                                 (exact->inexact (car args))))
      (install 'inexact->exact (λ (args)
                                 (check-arg-count 'inexact->exact args 1)
                                 (check-numbers 'inexact->exact args)
                                 (inexact->exact (car args))))
      (install 'number->string (λ (args)
                                 (unless (or (= (length args) 1) (= (length args) 2))
                                   (error 'minischeme "number->string expects 1 or 2 arguments"))
                                 (unless (number? (car args))
                                   (error 'minischeme "number->string expects a number, got ~a" (car args)))
                                 (if (= (length args) 1)
                                     (number->string (car args))
                                     (number->string (car args) (cadr args)))))
      (install 'string->number (λ (args)
                                 (unless (or (= (length args) 1) (= (length args) 2))
                                   (error 'minischeme "string->number expects 1 or 2 arguments"))
                                 (unless (string? (car args))
                                   (error 'minischeme "string->number expects a string, got ~a" (car args)))
                                 (if (= (length args) 1)
                                     (string->number (car args))
                                     (string->number (car args) (cadr args)))))
      ;; Higher-order primitives are handled in `apply-now`.
      (install 'apply (λ (_args)
                        (error 'minischeme "internal error: apply should be handled by evaluator")))
      (install 'map (λ (_args)
                      (error 'minischeme "internal error: map should be handled by evaluator")))
      (install 'for-each (λ (_args)
                           (error 'minischeme "internal error: for-each should be handled by evaluator")))
      (install 'filter (λ (_args)
                         (error 'minischeme "internal error: filter should be handled by evaluator")))
      (install 'values (λ (_args)
                         (error 'minischeme "internal error: values should be handled by evaluator")))
      (install 'call-with-values (λ (_args)
                                   (error 'minischeme "internal error: call-with-values should be handled by evaluator")))
      (install 'call/cc (λ (_args)
                          (error 'minischeme "internal error: call/cc should be handled by evaluator")))
      (install 'call-with-current-continuation (λ (_args)
                                                 (error 'minischeme "internal error: call-with-current-continuation should be handled by evaluator")))
      (install 'dynamic-wind (λ (_args)
                               (error 'minischeme "internal error: dynamic-wind should be handled by evaluator")))
      (constant 'primitives (sort all-primitives (λ (x y) (symbol<? x y))))
      (constant 'constants  (sort all-constants  (λ (x y) (symbol<? x y))))
      (constant 'keywords   (sort all-keywords   (λ (x y) (symbol<? x y))))
      base-env)

    (define global-env #f)

    (define (reset-state!)
      (set! global-env (create-initial-state)))

    ;; Parse via WebRacket's `read`.
    (define (parse-program/read s)
      (define in (open-input-string s))
      (let loop ([exprs '()])
        (define datum (read in))
        (if (eof-object? datum)
            (reverse exprs)
            (loop (cons datum exprs)))))

    (define (value->string v)
      (cond
        [(closure? v) "#<closure>"]
        [(prim? v)    (format "#<primitive ~a>" (prim-name v))]
        [(captured-kont? v) "#<continuation>"]
        [(void? v)    "#<void>"]
        [else         (format "~s" v)]))

    (define (top-level-value->string v)
      (if (mvals? v)
          (let ([vs (mvals-vals v)])
            (cond
              [(null? vs) "=> ; no values"]
              [else
               (string-append
                "=> "
                (string-join (map value->string vs) "\n=> "))]))
          (string-append "=> " (value->string v))))

    (define (apply-procedure value args caller-env kont loop)
      (cond
        [(closure? value)
         (define params (closure-params value))
         (define-values (required rest-id) (split-formals params))
         (define req-count (length required))
         (define arg-count (length args))
         (if rest-id
             (when (< arg-count req-count)
               (error 'minischeme "arity mismatch: expected at least ~a arguments, got ~a"
                      req-count arg-count))
             (when (not (= req-count arg-count))
               (error 'minischeme "arity mismatch: expected ~a arguments, got ~a"
                      req-count arg-count)))
         (define new-env (make-env (closure-env value)))
         (let bind-loop ([ps required] [as args])
           (unless (null? ps)
             (ensure-identifier (car ps))
             (env-define! new-env (car ps) (car as))
             (bind-loop (cdr ps) (cdr as))))
         (when rest-id
           (ensure-identifier rest-id)
           (env-define! new-env rest-id (list-tail args req-count)))
         (define body (closure-body value))
         (if (null? body)
             (loop 'value (void) caller-env kont)
             (loop 'eval (car body) new-env
                   (cons (k-begin (cdr body) new-env) kont)))]
        [(prim? value)
         (define result ((prim-proc value) args))
         (loop 'value result caller-env kont)]
        [else
         (error 'minischeme "application of non-procedure: ~a" value)]))

    (define (validate-binding binding who)
      (unless (and (pair? binding)
                   (symbol? (car binding))
                   (pair? (cdr binding))
                   (null? (cddr binding)))
        (error 'minischeme "~a binding malformed: ~s" who binding)))

    (define (validate-bindings bindings who)
      (unless (list? bindings)
        (error 'minischeme "~a malformed: bindings must be a list: ~s" who bindings))
      (for-each (λ (b) (validate-binding b who)) bindings))

    (define (expand-body forms)
      (cond
        [(null? forms) '(begin)]
        [(null? (cdr forms)) (expand-expr (car forms))]
        [else (cons 'begin (map expand-expr forms))]))

    (define (expand-and forms)
      (cond
        [(null? forms) #t]
        [(null? (cdr forms)) (expand-expr (car forms))]
        [else
         (list 'if (expand-expr (car forms))
               (expand-and (cdr forms))
               #f)]))

    (define (expand-or forms)
      (cond
        [(null? forms) #f]
        [(null? (cdr forms)) (expand-expr (car forms))]
        [else
         (define tmp (gensym 'or-tmp))
         (list 'let (list (list tmp (expand-expr (car forms))))
               (list 'if tmp tmp (expand-or (cdr forms))))]))

    (define (desugar-cond clauses)
      (cond
        [(null? clauses) '(begin)]
        [else
         (define clause (car clauses))
         (unless (pair? clause)
           (error 'minischeme "malformed cond clause: ~s" clause))
         (define test (car clause))
         (define body (cdr clause))
         (cond
           [(eq? test 'else)
            (unless (null? (cdr clauses))
              (error 'minischeme "cond: else clause must be last: ~s" clauses))
            (expand-body body)]
           [(and (pair? body) (eq? (car body) '=>))
            (error 'minischeme "cond => clauses not supported: ~s" clause)]
           [(null? body)
            (define tmp (gensym 'cond-tmp))
            (list 'let (list (list tmp (expand-expr test)))
                  (list 'if tmp tmp (desugar-cond (cdr clauses))))]
           [else
            (list 'if (expand-expr test)
                  (expand-body body)
                  (desugar-cond (cdr clauses)))])]))

    (define (case-clause-test key clauses)
      (expand-or
       (map (λ (datum) (list 'equal? key (list 'quote datum))) clauses)))

    (define (desugar-case key clauses)
      (define tmp (gensym 'case-key))
      (define (loop cls)
        (cond
          [(null? cls) '(begin)]
          [else
           (define clause (car cls))
           (unless (pair? clause)
             (error 'minischeme "malformed case clause: ~s" clause))
           (define head (car clause))
           (define body (cdr clause))
           (cond
             [(eq? head 'else)
              (unless (null? (cdr cls))
                (error 'minischeme "case: else clause must be last: ~s" clauses))
              (expand-body body)]
             [(list? head)
              (list 'if (case-clause-test tmp head)
                    (expand-body body)
                    (loop (cdr cls)))]
             [else
              (error 'minischeme "malformed case clause: ~s" clause)])]))
      (list 'let (list (list tmp (expand-expr key)))
            (loop clauses)))

    (define (expand-binding b)
      (unless (and (pair? b)
                   (symbol? (car b))
                   (pair? (cdr b))
                   (null? (cddr b)))
        (error 'minischeme "malformed binding: ~s" b))
      (list (car b) (expand-expr (cadr b))))

    (define (expand-expr expr)
      (cond
        [(or (symbol? expr)
             (number? expr)
             (boolean? expr)
             (string? expr)
             (char? expr)
             (null? expr)
             (vector? expr))
         expr]
        [(pair? expr)
         (define head (car expr))
         (define tail (cdr expr))
         (cond
           [(eq? head 'quote) expr]
           [(eq? head 'quasiquote) expr]
           [(eq? head 'unquote) expr]
           [(eq? head 'unquote-splicing) expr]
           [(eq? head 'and) (expand-and tail)]
           [(eq? head 'or) (expand-or tail)]
           [(eq? head 'when)
            (unless (pair? tail)
              (error 'minischeme "malformed when: ~s" expr))
            (list 'if (expand-expr (car tail))
                  (expand-body (cdr tail))
                  '(begin))]
           [(eq? head 'unless)
            (unless (pair? tail)
              (error 'minischeme "malformed unless: ~s" expr))
            (list 'if (expand-expr (car tail))
                  '(begin)
                  (expand-body (cdr tail)))]
           [(eq? head 'cond) (desugar-cond tail)]
           [(eq? head 'case)
            (unless (pair? tail)
              (error 'minischeme "malformed case: ~s" expr))
            (desugar-case (car tail) (cdr tail))]
           [(eq? head 'let*)
            (unless (pair? tail)
              (error 'minischeme "malformed let*: ~s" expr))
            (cons 'let* (cons (map expand-binding (car tail))
                              (map expand-expr (cdr tail))))]
           [(eq? head 'letrec)
            (unless (pair? tail)
              (error 'minischeme "malformed letrec: ~s" expr))
            (cons 'letrec (cons (map expand-binding (car tail))
                                (map expand-expr (cdr tail))))]
           [(eq? head 'let)
            (unless (pair? tail)
              (error 'minischeme "malformed let: ~s" expr))
            (if (symbol? (car tail))
                (let* ([name (car tail)]
                       [named-tail (cdr tail)])
                  (unless (pair? named-tail)
                    (error 'minischeme "malformed named let: ~s" expr))
                  (define bindings (car named-tail))
                  (define body (cdr named-tail))
                  (validate-bindings bindings 'let)
                  (define params (map car bindings))
                  (define args (map cadr bindings))
                  (expand-expr
                   (list 'letrec
                         (list (list name (cons 'lambda (cons params body))))
                         (cons name args))))
                (cons 'let (cons (map expand-binding (car tail))
                                 (map expand-expr (cdr tail)))))]
           [(eq? head 'lambda)
            (if (and (pair? tail) (pair? (cdr tail)))
                (cons 'lambda (cons (car tail) (map expand-expr (cdr tail))))
                expr)]
           [(eq? head 'if)
            (if (and (pair? tail) (pair? (cdr tail)))
                (let ([test (car tail)]
                      [then (cadr tail)]
                      [else-tail (cddr tail)])
                  (if (null? else-tail)
                      (list 'if (expand-expr test) (expand-expr then))
                      (list 'if (expand-expr test)
                            (expand-expr then)
                            (expand-expr (car else-tail)))))
                expr)]
           [(eq? head 'begin) (cons 'begin (map expand-expr tail))]
           [(eq? head 'unwind-protect)
            (if (and (pair? tail) (pair? (cdr tail)) (null? (cddr tail)))
                (let ([body (car tail)]
                      [cleanup (cadr tail)])
                  (list 'dynamic-wind
                        (list 'lambda '() #f)
                        (list 'lambda '() (expand-expr body))
                        (list 'lambda '() (expand-expr cleanup))))
                (error 'minischeme "unwind-protect: malformed form: ~s" expr))]
           [(eq? head 'set!)
            (if (and (pair? tail) (pair? (cdr tail)) (null? (cddr tail)))
                (list 'set! (car tail) (expand-expr (cadr tail)))
                expr)]
           [(eq? head 'define)
            (cond
              [(and (pair? tail) (symbol? (car tail))
                    (pair? (cdr tail)) (null? (cddr tail)))
               (list 'define (car tail) (expand-expr (cadr tail)))]
              [(and (pair? tail) (pair? (car tail)) (symbol? (caar tail)))
               (cons 'define
                     (cons (car tail) (map expand-expr (cdr tail))))]
              [else expr])]
           [else (map expand-expr expr)])]
        [else expr]))

    (define (expand-program exprs)
      (map expand-expr exprs))

    (define (single-arg who form)
      (define rest (cdr form))
      (unless (and (pair? rest) (null? (cdr rest)))
        (error 'minischeme "~a: malformed form: ~s" who form))
      (car rest))

    (define (cek-evaluate expr env [initial-kont '()] [initial-winds '()])
      (let loop ([mode         'eval]
                 [control      expr]
                 [current-env  env]
                 [kont         initial-kont]
                 [current-winds initial-winds])
        (define (continue mode control env kont [winds current-winds])
          (loop mode control env kont winds))
        (define (eval-now e env [winds current-winds])
          (call-with-values
           (λ () (cek-evaluate e env '() winds))
           (λ (v _env _winds) v)))
        (define (apply-now proc args env kont [winds current-winds])
          (define (apply-result proc args [winds* winds])
            (define tmp-env (make-env env))
            (define f-id (gensym 'apply-f))
            (env-define! tmp-env f-id proc)
            (define arg-ids
              (let loop-args ([xs args] [acc '()])
                (if (null? xs)
                    (reverse acc)
                    (let ([id (gensym 'apply-a)])
                      (env-define! tmp-env id (car xs))
                      (loop-args (cdr xs) (cons id acc))))))
            (eval-now (cons f-id arg-ids) tmp-env winds*))
          (define (apply-single proc args who)
            (single-value who (apply-result proc args)))
          (define (continue* mode control env kont [w winds])
            (continue mode control env kont w))
          (define (common-prefix-length xs ys)
            (let loop-prefix ([xs xs] [ys ys] [n 0])
              (if (or (null? xs) (null? ys) (not (eq? (car xs) (car ys))))
                  n
                  (loop-prefix (cdr xs) (cdr ys) (add1 n)))))
          (define (invoke-captured-cont k arg)
            (define target-kont (captured-kont-kont k))
            (define target-env (captured-kont-env k))
            (define target-winds (captured-kont-winds k))
            (define current-out (reverse winds))
            (define target-out (reverse target-winds))
            (define common (common-prefix-length current-out target-out))
            (define after-count (- (length winds) common))
            (define before-out (drop target-out common))
            (define run-winds winds)
            (for-each
             (λ (wf)
               (void (apply-result (wind-after wf) '() run-winds))
               (set! run-winds (cdr run-winds)))
             (take current-winds after-count))
            (for-each
             (λ (wf)
               (void (apply-result (wind-before wf) '() run-winds))
               (set! run-winds (cons wf run-winds)))
             before-out)
            (continue 'value arg target-env target-kont run-winds))
          (cond
            [(captured-kont? proc)
             (check-arg-count 'continuation args 1)
             (invoke-captured-cont proc (car args))]
            [(prim? proc)
             (let ([pname (prim-name proc)])
               (cond
                 [(eq? pname 'apply)
                  (check-at-least 'apply args 2)
                  (define proc-arg (car args))
                  (define initial (cdr (drop-right args 1)))
                  (define final-list (last args))
                  (ensure-list 'apply final-list)
                  (apply-now proc-arg (append initial final-list) env kont)]
                 [(eq? pname 'values)
                  (continue 'value (mvals args) env kont winds)]
                 [(eq? pname 'call-with-values)
                  (check-arg-count 'call-with-values args 2)
                  (define producer (car args))
                  (define consumer (cadr args))
                   (define produced (apply-result producer '()))
                  (apply-now consumer (value->values-list produced) env kont winds)]
                 [(or (eq? pname 'call/cc)
                      (eq? pname 'call-with-current-continuation))
                  (check-arg-count pname args 1)
                  (define proc-arg (car args))
                  (define k-proc (captured-kont kont env winds))
                  (apply-now proc-arg (list k-proc) env kont winds)]
                 [(eq? pname 'dynamic-wind)
                  (check-arg-count 'dynamic-wind args 3)
                  (define before (car args))
                  (define thunk (cadr args))
                  (define after (caddr args))
                  (unless (procedure-value? before)
                    (error 'minischeme "dynamic-wind: before must be a procedure, got ~a" before))
                  (unless (procedure-value? thunk)
                    (error 'minischeme "dynamic-wind: thunk must be a procedure, got ~a" thunk))
                  (unless (procedure-value? after)
                    (error 'minischeme "dynamic-wind: after must be a procedure, got ~a" after))
                  (define wf (wind before after))
                  (apply-now before '() env
                            (cons (k-dw-enter wf thunk env winds) kont)
                            winds)]
                 [(eq? pname 'map)
                  (check-arg-count 'map args 2)
                  (define f (car args))
                  (define lst (cadr args))
                  (ensure-list 'map lst)
                  (continue 'value
                            (map (λ (x) (apply-single f (list x) 'map)) lst)
                            env
                            kont
                            winds)]
                 [(eq? pname 'for-each)
                  (check-arg-count 'for-each args 2)
                  (define f (car args))
                  (define lst (cadr args))
                  (ensure-list 'for-each lst)
                  (for-each (λ (x) (apply-single f (list x) 'for-each)) lst)
                  (continue 'value (void) env kont winds)]
                 [(eq? pname 'filter)
                  (check-arg-count 'filter args 2)
                  (define pred (car args))
                  (define lst (cadr args))
                  (ensure-list 'filter lst)
                  (let loop-filter ([xs lst] [acc '()])
                    (if (null? xs)
                        (continue 'value (reverse acc) env kont winds)
                        (let ([ok (apply-single pred (list (car xs)) 'filter)])
                          (loop-filter (cdr xs)
                                       (if (false? ok)
                                           acc
                                           (cons (car xs) acc))))))]
                 [else
                  (apply-procedure proc args env kont continue*)]))]
            [else
             (apply-procedure proc args env kont continue*)]))
        (define (eval-sequence forms env kont)
          (if (null? forms)
              (continue 'value (void) env kont)
              (continue 'eval (car forms) env
                        (cons (k-begin (cdr forms) env) kont))))

        (define (qq-general datum depth)
          (cond
            [(pair? datum)
             (define head (car datum))
             (cond
               [(and (symbol? head) (eq? head 'quasiquote))
                (define arg (single-arg 'quasiquote datum))
                (list 'quasiquote (qq-general arg (add1 depth)))]
               [(and (symbol? head) (eq? head 'unquote))
                (define arg (single-arg 'unquote datum))
                (if (= depth 1)
                    (eval-now arg current-env)
                    (list 'unquote (qq-general arg (sub1 depth))))]
               [(and (symbol? head) (eq? head 'unquote-splicing))
                (define arg (single-arg 'unquote-splicing datum))
                (if (= depth 1)
                    (error 'minischeme "unquote-splicing outside list/vector context: ~s" datum)
                    (list 'unquote-splicing (qq-general arg (sub1 depth))))]
               [else
                (qq-list datum depth)])]
            [(vector? datum)
             (qq-vector datum depth)]
            [else
             datum]))

        (define (qq-item datum depth)
          (if (and (pair? datum)
                   (symbol? (car datum))
                   (eq? (car datum) 'unquote-splicing))
              (let ([arg (single-arg 'unquote-splicing datum)])
                (if (= depth 1)
                    (values #t (eval-now arg current-env))
                    (values #f (list 'unquote-splicing
                                     (qq-general arg (sub1 depth))))))
              (values #f (qq-general datum depth))))

        (define (qq-list datum depth)
          (cond
            [(null? datum) '()]
            [(pair? datum)
             (define-values (splice? v) (qq-item (car datum) depth))
             (define rest (qq-list (cdr datum) depth))
             (if splice?
                 (begin
                   (unless (list? v)
                     (error 'minischeme "unquote-splicing expects a list in list context: ~s" v))
                   (append v rest))
                 (cons v rest))]
            [else
             (qq-general datum depth)]))

        (define (qq-vector vec depth)
          (let loopv ([xs (vector->list vec)] [acc '()])
            (if (null? xs)
                (list->vector (reverse acc))
                (let-values ([(splice? v) (qq-item (car xs) depth)])
                  (if splice?
                      (begin
                        (unless (list? v)
                          (error 'minischeme "unquote-splicing expects a list in vector context: ~s" v))
                        (loopv (cdr xs) (append (reverse v) acc)))
                      (loopv (cdr xs) (cons v acc)))))))

        (cond
          [(eq? mode 'eval)
           (cond
             [(literal? control)
              (continue 'value control current-env kont)]
             [(symbol? control)
              (continue 'value (env-lookup current-env control) current-env kont)]
             [(and (pair? control) (eq? (car control) 'quote))
             (let ([rest (cdr control)])
                (if (and (pair? rest) (null? (cdr rest)))
                    (continue 'value (car rest) current-env kont)
                    (error 'minischeme "malformed quote: ~s" control)))]
             [(and (pair? control) (eq? (car control) 'quasiquote))
              (continue 'value (qq-general (single-arg 'quasiquote control) 1)
                        current-env kont)]
             [(and (pair? control) (eq? (car control) 'unquote))
              (error 'minischeme "unquote outside quasiquote: ~s" control)]
             [(and (pair? control) (eq? (car control) 'unquote-splicing))
              (error 'minischeme "unquote-splicing outside quasiquote: ~s" control)]
             [(and (pair? control) (eq? (car control) 'lambda))
              (let ([rest (cdr control)])
                (if (and (pair? rest))
                    (let ([params (car rest)]
                          [body (cdr rest)])
                      (continue 'value (closure (ensure-parameters params)
                                                body current-env)
                                current-env kont))
                    (error 'minischeme "malformed lambda: ~s" control)))]
             [(and (pair? control) (eq? (car control) 'if))
              (let* ([rest (cdr control)]
                     [len (length rest)])
                (cond
                  [(or (< len 2) (> len 3))
                   (error 'minischeme "malformed if: ~s" control)]
                  [else
                   (define test (car rest))
                   (define then (cadr rest))
                   (define else-expr (if (= len 3) (caddr rest) no-else))
                   (continue 'eval test current-env
                             (cons (k-if then else-expr current-env) kont))]))]
             [(and (pair? control) (eq? (car control) 'begin))
              (eval-sequence (cdr control) current-env kont)]
             [(and (pair? control) (eq? (car control) 'set!))
              (let ([rest (cdr control)])
                (if (and (pair? rest)
                         (symbol? (car rest))
                         (pair? (cdr rest))
                         (null? (cddr rest)))
                    (let ([name (car rest)]
                          [rhs (cadr rest)])
                      (define cell (env-lookup-cell current-env name))
                      (continue 'eval rhs current-env
                                (cons (k-set! cell name) kont)))
                    (error 'minischeme "malformed set!: ~s" control)))]
             [(and (pair? control) (eq? (car control) 'define))
              (let ([rest (cdr control)])
                (cond
                  [(and (pair? rest) (symbol? (car rest)))
                   (let ([name (car rest)]
                         [tail (cdr rest)])
                     (unless (and (pair? tail) (null? (cdr tail)))
                       (error 'minischeme "malformed define: ~s" control))
                     (define cell
                       (if (env-bound-current? current-env name)
                           (hash-ref (env-table current-env) name)
                           (let ([c (box uninitialized)])
                             (env-define-cell! current-env name c)
                             c)))
                     (set-box! cell uninitialized)
                     (continue 'eval (car tail) current-env
                               (cons (k-define cell name) kont)))]
                  [(and (pair? rest)
                        (pair? (car rest))
                        (symbol? (caar rest)))
                   (let* ([head (car rest)]
                          [name (car head)]
                          [params (cdr head)]
                          [body (cdr rest)])
                     (define cell
                       (if (env-bound-current? current-env name)
                           (hash-ref (env-table current-env) name)
                           (let ([c (box uninitialized)])
                             (env-define-cell! current-env name c)
                             c)))
                     (set-box! cell uninitialized)
                     (define lambda-expr (cons 'lambda (cons params body)))
                     (continue 'eval lambda-expr current-env
                               (cons (k-define cell name) kont)))]
                  [else (error 'minischeme "malformed define: ~s" control)]))]
             [(and (pair? control) (eq? (car control) 'let))
              (let ([rest (cdr control)])
                (if (and (pair? rest))
                    (let ([bindings (car rest)]
                          [body (cdr rest)])
                      (validate-bindings bindings 'let)
                      (define new-env (make-env current-env))
                      (for-each
                       (λ (binding)
                         (env-define! new-env (car binding)
                                      (single-value 'let-binding
                                                    (eval-now (cadr binding) current-env))))
                       bindings)
                      (eval-sequence body new-env kont))
                    (error 'minischeme "malformed let: ~s" control)))]
             [(and (pair? control) (eq? (car control) 'let*))
              (let ([rest (cdr control)])
                (if (and (pair? rest))
                    (let ([bindings (car rest)]
                          [body (cdr rest)])
                      (validate-bindings bindings 'let*)
                      (define new-env (make-env current-env))
                      (for-each
                       (λ (binding)
                         (env-define! new-env (car binding)
                                      (single-value 'let*-binding
                                                    (eval-now (cadr binding) new-env))))
                       bindings)
                      (eval-sequence body new-env kont))
                    (error 'minischeme "malformed let*: ~s" control)))]
             [(and (pair? control) (eq? (car control) 'letrec))
              (let ([rest (cdr control)])
                (if (and (pair? rest))
                    (let ([bindings (car rest)]
                          [body (cdr rest)])
                      (validate-bindings bindings 'letrec)
                      (define new-env (make-env current-env))
                      (define cells '())
                      (define rhss '())
                      (for-each
                       (λ (binding)
                         (unless (and (pair? binding)
                                      (symbol? (car binding))
                                      (pair? (cdr binding))
                                      (null? (cddr binding)))
                           (error 'minischeme "malformed letrec binding: ~s" binding))
                         (define cell (box uninitialized))
                         (env-define-cell! new-env (car binding) cell)
                         (set! cells (cons cell cells))
                         (set! rhss (cons (cadr binding) rhss)))
                       bindings)
                      (let loopr ([cs (reverse cells)] [es (reverse rhss)])
                        (unless (null? cs)
                          (set-box! (car cs) (single-value 'letrec-binding
                                                           (eval-now (car es) new-env)))
                          (loopr (cdr cs) (cdr es))))
                      (eval-sequence body new-env kont))
                    (error 'minischeme "malformed letrec: ~s" control)))]
             [(pair? control)
              (define op (car control))
              (define args (cdr control))
              (continue 'eval op current-env
                        (cons (k-apply args current-env) kont))]
             [else
              (error 'minischeme "cannot evaluate expression ~a" control)])]
          [(eq? mode 'value)
           (if (null? kont)
               (values control current-env current-winds)
               (let* ([frame (car kont)]
                      [rest (cdr kont)])
                 (cond
                   [(k-apply? frame)
                    (define args (k-apply-args frame))
                    (define call-env (k-apply-env frame))
                    (define op (single-value 'application control))
                    (if (null? args)
                        (apply-now op '() call-env rest)
                        (continue 'eval (car args) call-env
                                  (cons (k-args op (cdr args) call-env '())
                                        rest)))]
                   [(k-args? frame)
                    (define proc (k-args-proc frame))
                    (define rest-args (k-args-rest frame))
                    (define call-env (k-args-env frame))
                    (define arg (single-value 'application-argument control))
                    (define collected (cons arg (k-args-values frame)))
                    (if (null? rest-args)
                        (apply-now proc (reverse collected) call-env rest)
                        (continue 'eval (car rest-args) call-env
                                  (cons (k-args proc (cdr rest-args)
                                                call-env collected) rest)))]
                   [(k-if? frame)
                   (define branch-env (k-if-env frame))
                   (define then (k-if-then frame))
                   (define else-expr (k-if-else frame))
                    (define test-v (single-value 'if-test control))
                    (if (false? test-v)
                        (if (eq? else-expr no-else)
                            (continue 'value (void) branch-env rest)
                            (continue 'eval else-expr branch-env rest))
                        (continue 'eval then branch-env rest))]
                   [(k-begin? frame)
                    (define begin-env (k-begin-env frame))
                    (define rest-forms (k-begin-rest frame))
                    (if (null? rest-forms)
                        (continue 'value control begin-env rest)
                        (continue 'eval (car rest-forms) begin-env
                                  (cons (k-begin (cdr rest-forms) begin-env) rest)))]
                   [(k-set!? frame)
                    (set-box! (k-set!-cell frame) (single-value (k-set!-name frame) control))
                    (continue 'value control current-env rest)]
                   [(k-define? frame)
                    (set-box! (k-define-cell frame) (single-value (k-define-name frame) control))
                    (continue 'value (k-define-name frame) current-env rest)]
                   [(k-dw-enter? frame)
                    (define wf (k-dw-enter-wf frame))
                    (define thunk (k-dw-enter-thunk frame))
                    (define dyn-env (k-dw-enter-env frame))
                    (define winds-before (k-dw-enter-winds-before frame))
                    (define entered-winds (cons wf winds-before))
                    (apply-now thunk '() dyn-env
                              (cons (k-dw-exit (wind-after wf) dyn-env winds-before) rest)
                              entered-winds)]
                   [(k-dw-exit? frame)
                    (define produced control)
                    (define after (k-dw-exit-after frame))
                    (define dyn-env (k-dw-exit-env frame))
                    (define winds-before (k-dw-exit-winds-before frame))
                    (apply-now after '() dyn-env
                              (cons (k-dw-return produced dyn-env winds-before) rest)
                              current-winds)]
                   [(k-dw-return? frame)
                    (continue 'value
                              (k-dw-return-produced frame)
                              (k-dw-return-env frame)
                              rest
                              (k-dw-return-winds-before frame))]
                   [else
                    (error 'minischeme "unknown continuation frame ~a" frame)])))]
          [else
           (error 'minischeme "invalid evaluation mode" mode)])))

    (define (evaluate-program exprs)
      (let loop ([forms exprs]
                 [last-value (void)])
        (if (null? forms)
            last-value
            (call-with-values
             (λ () (cek-evaluate (car forms) global-env))
             (λ (value _env _winds)
               (loop (cdr forms) value))))))

    (define (process-input s)
      (unless global-env
        (reset-state!))
      (define (format-read-error e)
        (string-append "=> read error: " (exn-message e)))
      (define (format-eval-error e)
        (define msg (exn-message e))
        (define prefix "minischeme: ")
        (define normalized
          (if (and (>= (string-length msg) (string-length prefix))
                   (string=? (substring msg 0 (string-length prefix)) prefix))
              (substring msg (string-length prefix))
              msg))
        (string-append "=> eval error: " normalized))
      (define-values (exprs read-error)
        (with-handlers
          ([exn:fail:read?
            (λ (e) (values #f (format-read-error e)))]
           [(λ _ #t)
            (λ (e) (values #f (format-read-error e)))])
          (values (parse-program/read s) #f)))
      (if read-error
          read-error
          (with-handlers
            ([exn:fail? (λ (e) (format-eval-error e))])
            (define expanded (expand-program exprs))
            (if (null? expanded)
                "=> ; no input"
                (let ([value (evaluate-program expanded)])
                  (top-level-value->string value))))))

    (reset-state!)
    (values reset-state! process-input)))
