#lang at-exp racket
(provide run wat->wasm)
(require "fasl.rkt")

;; (run [x #f] 
;;      #:wat        [out.wat    "out.wat"]
;;      #:wasm       [out.wasm   "out.wasm"]
;;      #:runtime.js [runtime.js "runtime.js"])

;; (wat->wasm x
;;            #:wat [out.wat "out.wat"]
;;            #:wasm [out.wasm "out.wasm"])


;;;
;;; ASSEMBLER
;;;

; The assembler takes a Web Assembly program in the folded textual format (.wat)
; and produces a binary (.wasm).

; Currently we use an external tool  `wasm-tools` from the Bytecode Alliance.

;;;
;;; TODO
;;;

; Some of the comments below refer to the external tool `wabt` but
; as it turns out, it doesn't support the GC proposal.


;;;
;;; NOTES
;;; 

; The assembler `wat2wasm` from the "official" wabt tools
; does not support the GC proposal (which includes i31).
; The tool has a flag `--enable-gc` but it has no effect on the assembler.
; The issue is that the options are shared between a set of tools,
; and some of the other tools support the GC proposal.

; (define tool-path "/Users/soegaard/Dropbox/github/wabt/bin")

; The chosen assembler is instead `wasm-tools` which is a Rust project.
; There are prebuilt binaries in the release assets:
;
;     https://github.com/bytecodealliance/wasm-tools/releases
;
; The current version is 1.230.0 (May 2025).

; List the available commands:
;    ./wasm-tools
; Help for the `parse` tool:
;  ./wasm-tools parse --help
; The `parse` tool converts form the textual format (wat) to
; the binary format (wasm). 

;;;
;;; ASSEMBLER
;;;

(define assembler-path "/Users/soegaard/tmp/wasm-tools-1.230.0-aarch64-macos")

;;;
;;; RUNTIME
;;;

(define (runtime #:out [out.wasm "out.wasm"])
@~a{
// Generated by "assembler.rkt". 
import fs from 'node:fs/promises';

const wasmBuffer = await fs.readFile("@|out.wasm|");

var memory = new WebAssembly.Memory({initial:1024});

var output_string = [];

function read_u32(arr, i) {
  return ((arr[i] << 24) | (arr[i + 1] << 16) |
          (arr[i + 2] << 8)  | arr[i + 3]) >>> 0;
}

function fasl_to_js_value(arr, i = 0) {
  const tag = arr[i++];

  function u32() {
    const v = read_u32(arr, i);
    i += 4;
    return v;
  }

  function read_bytes() {
    const len = u32();
    const b = arr.slice(i, i + len);
    i += len;
    return b;
  }

  function read_string() {
    const b = read_bytes();
    return new TextDecoder().decode(b);
  }

  switch(tag) {
    case @|fasl-fixnum|: {
      const raw = u32();
      // Sign-extend the 30-bit payload so negative fixnums decode correctly.
      return [(raw << 2) >> 2, i];
    }
    case @|fasl-character|:
      return [String.fromCodePoint(u32()), i];
    case @|fasl-symbol|:
      return [Symbol.for(read_string()), i];
    case @|fasl-string|:
      return [read_string(), i];
    case @|fasl-bytes|:
      return [read_bytes(), i];
    case @|fasl-boolean|:
      return [arr[i++] !== 0, i];
    case @|fasl-null|:
      return [null, i];
    case @|fasl-pair|: {
      let car, cdr;
      [car, i] = fasl_to_js_value(arr, i);
      [cdr, i] = fasl_to_js_value(arr, i);
      return [{tag:'pair', car, cdr}, i];
    }
    case @|fasl-vector|: {
      const n = u32();
      const vec = new Array(n);
      for(let j = 0; j < n; j++) {
        [vec[j], i] = fasl_to_js_value(arr, i);
      }
      return [vec, i];
    }
    case @|fasl-flonum|: {
      const hi = u32();
      const lo = u32();
      const dv = new DataView(new ArrayBuffer(8));
      dv.setUint32(0, hi);
      dv.setUint32(4, lo);
      return [dv.getFloat64(0), i];
    }
    case @|fasl-void|:
      return [undefined, i];
    case @|fasl-eof|:
      return ['<eof>', i];
    default:
      throw new Error('bad FASL tag ' + tag);
  }
}

var imports = {
    'env': {
        'memory': memory
    },
    'primitives': {
      'console_log': ((x)   => console.log(x)),
      'add':         ((x,y) => x+y),
      'js_output':   ((x)   => output_string.push(x)),
      'js_print_fasl': ((start, len) => {
        const bytes = new Uint8Array(memory.buffer).slice(start, start + len);
        const [v] = fasl_to_js_value(bytes);
        console.log(v);
      })
    }
};

const wasmModule
      = await WebAssembly
      .instantiate(wasmBuffer, imports)
      .then(results  => { const { entry, get_bytes, copy_bytes_to_memory } = results.instance.exports;
                          var result = entry();
                          // console.log( "Output:")
                          // console.log( output_string );      
                          // console.log( "Result:")
                          // console.log( result );

                          // console.log( "Result bytes:" )
                          const bytes  = new Uint8Array(memory.buffer, 0, result);
                          console.log(new TextDecoder().decode(bytes));
                        });
})



;;;
;;; Driver
;;;

;; wat2wasm [options] filename
;;   read a file in the wasm text format, check it for errors, and
;;   convert it to the wasm binary format.
;; 
;;   examples:
;;     # parse test.wat and write to .wasm binary file with the same name
;;     $ wat2wasm test.wat
;;    
;;     # parse test.wat and write to binary file test.wasm
;;     $ wat2wasm test.wat -o test.wasm
;;    
;;     # parse spec-test.wast, and write verbose output to stdout (including
;;     # the meaning of every byte)
;;     $ wat2wasm spec-test.wast -v

(define (wat-pretty-print-table)
  (pretty-print-extend-style-table
   #f
   '(func   module block)
   '(lambda when   begin)))

(define (wat-pretty-write x)
  (parameterize ([current-print write]
                 [pretty-print-current-style-table (wat-pretty-print-table)])
    (pretty-write x)))

(define (print-wat x)
  (wat-pretty-write x))

(define (wat->wasm x #:wat [out.wat "out.wat"] #:wasm [out.wasm "out.wasm"])
  ; The argument x is an s-expresssion.
  ; It represents a WebAssembly module in textual format.

  ; 1. Write the module x to a wat file
  (with-output-to-file out.wat
    (位 ()
      (wat-pretty-write x))
    #:exists 'replace)
  ; 2. Compile the wat file into a wasm file.
  (define success? #t)
  (define compilation-output
    (with-output-to-string
      (位 ()
        (set! success?
              (system
               (format (~a assembler-path "/" "wasm-tools parse ~a -o ~a ")
                       out.wat out.wasm))))))
  ; 3. If there were any errors, display the error messages
  (unless success?
    (displayln "* Compilation Error *")
    (displayln compilation-output))
  ; 4. Return success?
  success?)


(define (run [x #f] 
             #:wat        [out.wat    "out.wat"]
             #:wasm       [out.wasm   "out.wasm"]
             #:runtime.js [runtime.js "runtime.js"])
  ; (print-wat x)
  ; 1. If needed compile textual format to wasm file.  
  (define okay?
    (if x
        (wat->wasm x #:wat out.wat #:wasm out.wasm)
        #t))
  (when okay?
    ; 2. Write runtime
    (with-output-to-file runtime.js
      (位 () (displayln (runtime #:out out.wasm)))
      #:exists 'replace)
    ; 3. Invoke runtime.js using Node
    (define success? #t)
    (define output
      (with-output-to-string
        (位 ()
          (set! success?
                (system (format "/usr/local/bin/node --expose-gc ~a"
                                runtime.js))))))
    ; 3. If there were any errors, display the error messages
    (displayln output)))
