#lang at-exp racket
(provide run wat->wasm runtime)
(require "fasl.rkt")

;;;
;;; ASSEMBLER
;;;

; The assembler takes a Web Assembly program in the folded textual format (.wat)
; and produces a binary (.wasm).

; Currently we use an external tool  `wasm-tools` from the Bytecode Alliance.

; The host file (default: runtime.js) is also generated by the assembler.


;;; USAGE

;; (run [x #f] 
;;      #:wat        [out.wat    "out.wat"]
;;      #:wasm       [out.wasm   "out.wasm"]
;;      #:runtime.js [runtime.js "runtime.js"])

;; (wat->wasm x
;;            #:wat [out.wat "out.wat"]
;;            #:wasm [out.wasm "out.wasm"])


;;;
;;; TODO
;;;

; Some of the comments below refer to the external tool `wabt` but
; as it turns out, it doesn't support the GC proposal.


;;;
;;; NOTES
;;; 

; The assembler `wat2wasm` from the "official" wabt tools
; does not support the GC proposal (which includes i31).
; The tool has a flag `--enable-gc` but it has no effect on the assembler.
; The issue is that the options are shared between a set of tools,
; and some of the other tools support the GC proposal.

; (define tool-path "/Users/soegaard/Dropbox/github/wabt/bin")

; The chosen assembler is instead `wasm-tools` which is a Rust project.
; There are prebuilt binaries in the release assets:
;
;     https://github.com/bytecodealliance/wasm-tools/releases
;
; The current version is 1.230.0 (May 2025).

; List the available commands:
;    ./wasm-tools
; Help for the `parse` tool:
;  ./wasm-tools parse --help
; The `parse` tool converts form the textual format (wat) to
; the binary format (wasm). 

;;;
;;; ASSEMBLER
;;;

(define assembler-path "/Users/soegaard/tmp/wasm-tools-1.230.0-aarch64-macos")

;;;
;;; RUNTIME
;;;

;; The runtime generated for the Node and the Browser is the mostly identical.
;; The only difference is that Node uses `fs.readfile` to load the wasm
;; and the browser needs to fetch it.

(define (runtime-common)
  @~a{
var memory = new WebAssembly.Memory({initial:1024});

var output_string = [];

function read_u32(arr, i) {
  return ((arr[i] << 24) | (arr[i + 1] << 16) |
          (arr[i + 2] << 8)  | arr[i + 3]) >>> 0;
}

function fasl_to_js_value(arr, i = 0) {
                                       
  const tag = arr[i++];

  function u32() {
    const v = read_u32(arr, i);
    i += 4;
    return v;
  }

  function read_bytes() {
    const len = u32();
    const b = arr.slice(i, i + len);
    i += len;
    return b;
  }

  function read_string() {
    const b = read_bytes();
    return new TextDecoder().decode(b);
  }

  switch(tag) {
    case @|fasl-fixnum|: {
      const raw = u32();
      // Sign-extend the 30-bit payload so negative fixnums decode correctly.
      return [(raw << 2) >> 2, i];
    }
    case @|fasl-character|:
      return [String.fromCodePoint(u32()), i];
    case @|fasl-symbol|:
      return [Symbol.for(read_string()), i];
    case @|fasl-string|:
      return [read_string(), i];
    case @|fasl-bytes|:
      return [read_bytes(), i];
    case @|fasl-boolean|:
      return [arr[i++] !== 0, i];
    case @|fasl-null|:
      return [null, i];
    case @|fasl-pair|: {
      let car, cdr;
      [car, i] = fasl_to_js_value(arr, i);
      [cdr, i] = fasl_to_js_value(arr, i);
      return [{tag:'pair', car, cdr}, i];
    }
    case @|fasl-vector|: {
      const n = u32();
      const vec = new Array(n);
      for(let j = 0; j < n; j++) {
        [vec[j], i] = fasl_to_js_value(arr, i);
      }
      return [vec, i];
    }
    case @|fasl-flonum|: {
      const hi = u32();
      const lo = u32();
      const dv = new DataView(new ArrayBuffer(8));
      dv.setUint32(0, hi);
      dv.setUint32(4, lo);
      return [dv.getFloat64(0), i];
    }
    case @|fasl-void|:
      return [undefined, i];
    case @|fasl-eof|:
      return ['<eof>', i];
    default:
      throw new Error('bad FASL tag ' + tag);
  }
}

function js_value_to_fasl(v) {
  const out = [];
  const enc = new TextEncoder();

  // --- low-level writers (big-endian) ---
  function writeByte(b) {
    out.push(b & 0xFF);
  }
  function writeU32(u) {
    out.push((u >>> 24) & 0xFF, (u >>> 16) & 0xFF, (u >>> 8) & 0xFF, u & 0xFF);
  }
  function writeBytes(u8) {
    writeU32(u8.length >>> 0);
    for (let i = 0; i < u8.length; i++) out.push(u8[i] & 0xFF);
  }
  function writeString(s) {
    const u8 = enc.encode(s);
    writeBytes(u8);
  }
  function writeF64(x) {
    const dv = new DataView(new ArrayBuffer(8));
    // Big-endian
    dv.setFloat64(0, x, false);
    const hi = dv.getUint32(0, false);
    const lo = dv.getUint32(4, false);
    writeU32(hi);
    writeU32(lo);
  }

  // --- tagged writers ---
  function writeFixnum(n) {
    // 30-bit signed two's complement payload; range: [-2^29, 2^29-1]
    if (!Number.isInteger(n) || n < -(1 << 29) || n > ((1 << 29) - 1)) {
      throw new RangeError("fixnum out of 30-bit range");
    }
    writeByte(@|fasl-fixnum|);
    const raw30 = n & 0x3FFFFFFF; // 30-bit two's complement payload
    writeU32(raw30 >>> 0);
  }
  function writeFlonum(x) {
    writeByte(@|fasl-flonum|);
    writeF64(x);
  }
  function writeCharacter(cp) {
    // cp = Unicode scalar value (number)
    writeByte(@|fasl-character|);
    writeU32(cp >>> 0);
  }
  function writeSymbol(name) {
    writeByte(@|fasl-symbol|);
    writeString(name);
  }
  function writeStringVal(s) {
    writeByte(@|fasl-string|);
    writeString(s);
  }
  function writeBytesVal(u8) {
    writeByte(@|fasl-bytes|);
    writeBytes(u8);
  }
  function writeBoolean(b) {
    writeByte(@|fasl-boolean|);
    writeByte(b ? 1 : 0);
  }
  function writeNull() {
    writeByte(@|fasl-null|);
  }
  function writeVoid() {
    writeByte(@|fasl-void|);
  }
  function writeEof() {
    writeByte(@|fasl-eof|);
  }
  function writePair(car, cdr) {
    writeByte(@|fasl-pair|);
    writeAny(car);
    writeAny(cdr);
  }
  function writeVector(arr) {
    writeByte(@|fasl-vector|);
    writeU32(arr.length >>> 0);
    for (let i = 0; i < arr.length; i++) writeAny(arr[i]);
  }

  // --- main dispatcher (mirrors fasl_to_js_value mapping) ---
  function writeAny(x) {
    // Fast paths by JS type
    if (typeof x === "number") {
      if (Number.isInteger(x) && x >= -(1 << 29) && x <= ((1 << 29) - 1)) {
        writeFixnum(x);
      } else {
        writeFlonum(x);
      }
      return;
    }
    if (typeof x === "boolean") {
      writeBoolean(x);
      return;
    }
    if (x === null) {
      writeNull();
      return;
    }
    if (x === undefined) {
      writeVoid();
      return;
    }
    // EoF sentinel (match your decoder's '<eof>' convention)
    if (x === "<eof>" || (x && x.tag === "eof")) {
      writeEof();
      return;
    }
    // Character (two accepted forms)
    //   { tag: 'char', cp: <codepoint> }  or  { tag: 'char', ch: 'A' }
    if (x && x.tag === "char") {
      const cp = typeof x.cp === "number" ? x.cp
               : (typeof x.ch === "string" ? x.ch.codePointAt(0) : undefined);
      if (cp === undefined) throw new TypeError("bad char object");
      writeCharacter(cp >>> 0);
      return;
    }
    // Pair (your decoder uses {tag:'pair', car, cdr})
    if (x && x.tag === "pair") {
      writePair(x.car, x.cdr);
      return;
    }
    // Bytes: prefer Uint8Array
    if (x instanceof Uint8Array) {
      writeBytesVal(x);
      return;
    }
    // Accept raw byte arrays too
    if (Array.isArray(x) && x.every(n => Number.isInteger(n) && n >= 0 && n <= 255)) {
      writeBytesVal(Uint8Array.from(x));
      return;
    }
    // Vector: plain JS Array (distinct from bytes above)
    if (Array.isArray(x)) {
      writeVector(x);
      return;
    }
    // Symbol
    if (typeof x === "symbol") {
      const name = Symbol.keyFor(x) ?? x.description ?? "";
      writeSymbol(name);
      return;
    }
    // String
    if (typeof x === "string") {
      writeStringVal(x);
      return;
    }
    throw new TypeError("unsupported value for FASL encoding: " + String(x));
  }
  writeAny(v);
  return Uint8Array.from(out);
}

function testsuite(js_value_to_fasl, fasl_to_js_value, { log = true } = {}) {
  // --- helpers -------------------------------------------------------------
  function charToString(v) {
    if (typeof v === 'string' && v.length === 1) return v;
    if (v && typeof v === 'object' && v.tag === 'char' && typeof v.cp === 'number') {
      try { return String.fromCodePoint(v.cp); } catch { /* fall through */ }
    }
    return null;
  }

  function deepEq(a, b) {
    // Treat "char-wrappers" and 1-char strings as equal
    const ac = charToString(a), bc = charToString(b);
    if (ac !== null || bc !== null) return ac === bc;
    // numbers (handle NaN, -0)
    if (typeof a === 'number' || typeof b === 'number') return Object.is(a, b);
    // Uint8Array (bytes)
    if (a instanceof Uint8Array && b instanceof Uint8Array) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
      return true;
    }
    // Symbols (use registry key or description)
    if (typeof a === 'symbol' && typeof b === 'symbol') {
      const ka = Symbol.keyFor(a) ?? a.description ?? '';
      const kb = Symbol.keyFor(b) ?? b.description ?? '';
      return ka === kb;
    }
    // Pairs
    if (a && b && a.tag === 'pair' && b.tag === 'pair') {
      return deepEq(a.car, b.car) && deepEq(a.cdr, b.cdr);
    }
    // Arrays (vectors)
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) if (!deepEq(a[i], b[i])) return false;
      return true;
    }
    // Strings, booleans, null, undefined, "<eof>"
    return a === b;
  }
  function roundtrip(v) {
    const bytes = js_value_to_fasl(v);
    const [v2] = fasl_to_js_value(bytes);
    const ok = deepEq(v2, v);
    if (!ok && log) {
      console.error('Roundtrip mismatch:', v, '->', v2, 'bytes=', bytes);
    }
    return ok;
  }
  function test(name, v) {
    const ok = roundtrip(v);
    results.push({ name, ok });
    if (log) console.log(`${ok ? 'âœ“' : 'âœ—'} ${name}`);
    if (ok) pass++; else fail++;
  }

  // --- run tests -----------------------------------------------------------
  const results = [];
  let pass = 0, fail = 0;
  
  // Fixnums (30-bit)
  test('fixnum 0', 0);
  test('fixnum 123', 123);
  test('fixnum -5', -5);
  // Flonums
  test('flonum 1.5', 1.5);
  test('flonum -0.0', -0.0);
  test('flonum NaN', NaN);
  test('flonum +Inf', Infinity);
  test('flonum -Inf', -Infinity);
  // Booleans / null / void / eof
  test('boolean true', true);
  test('boolean false', false);
  test('null', null);
  test('void/undefined', undefined);
  test('eof sentinel', '<eof>');
  // Characters (encode via wrapper; decoder yields 1-char string)
  test('char A', { tag: 'char', cp: 'A'.codePointAt(0) });
  test('char snowman', { tag: 'char', cp: 'â˜ƒ'.codePointAt(0) });
  // Symbols
  test('symbol foo', Symbol.for('foo'));
  // Bytes (Uint8Array)
  test('bytes', new Uint8Array([0, 1, 2, 255]));
  // Pairs
  test('pair (1 . null)', { tag: 'pair', car: 1, cdr: null });
  test('list (1 2)',
       { tag: 'pair', car: 1, cdr: { tag: 'pair', car: 2, cdr: null } });
  // Vectors (arrays)
  test('vector mixed',
       [ 1, 2.5, { tag: 'pair', car: 'x', cdr: null }, true ]);
  // Strings
  test('string ascii', 'hello');
  test('string utf8', 'hÃ©llÃ¸ ðŸŒ');

  return { pass, fail, total: pass + fail, results };
}

// Uncomment to run the testsuite for fasl.
// Currently the only failing test is the one for -0.0 which after the round trip becomes 0.0.
// This is not fixabable as long as we convert integers to fixnums.

// const summary = testsuite(js_value_to_fasl, fasl_to_js_value, { log: true });
// console.log(`\nPassed: ${summary.pass}/${summary.total}`);
// if (summary.fail) {
//   console.log('Failures:');
//    for (const r of summary.results.filter(r => !r.ok)) {
//    console.log('  -', r.name);
//  }
// }

// hasDOM gives us a way of determining whether the host is a browser or Node
const hasDOM = typeof document !== 'undefined' && typeof document.createTextNode === 'function';

function from_fasl(index) {
    return fasl_to_js_value(new Uint8Array(memory.buffer), index)[0]
}

var imports = {
    'env': {
        'memory': memory
    },
    'primitives': {
      'console_log': ((x)   => console.log(x)),
      'add':         ((x,y) => x+y),
      'js_output':   ((x)   => output_string.push(x)),
      'js_print_fasl': ((start, len) => {
        const bytes = new Uint8Array(memory.buffer).slice(start, start + len);
        const [v] = fasl_to_js_value(bytes);
        console.log(v);
      }),
      'char_upcase': ((cp) => {
        const s = String.fromCodePoint(cp).toUpperCase();
        const arr = Array.from(s);
        return (arr.length === 1) ? arr[0].codePointAt(0) : cp;
      }),
      'char_downcase': ((cp) => {
        const s = String.fromCodePoint(cp).toLowerCase();
        const arr = Array.from(s);
        return (arr.length === 1) ? arr[0].codePointAt(0) : cp;
      }),
      'char_titlecase': ((cp) => {
        const lower = String.fromCodePoint(cp).toLocaleLowerCase();
        const title = lower.charAt(0).toLocaleUpperCase() + lower.slice(1);
        const arr = Array.from(title);
        return (arr.length === 1) ? arr[0].codePointAt(0) : cp;
      }),
      'char_foldcase': ((cp) => {
        // Note: JavaScript doesn't have builtin unicode aware fold case (year 2025).
        //       For now, we will just use lowercase.                  
        const s = String.fromCodePoint(cp).toLowerCase();
        const arr = Array.from(s);
        return (arr.length === 1) ? arr[0].codePointAt(0) : cp;
      })
    },
    'standard': {
      'global-this':               (() => globalThis),
      'infinity':                  (() => Infinity),
      'nan':                       (() => NaN),
      'undefined':                 (() => undefined),
      'eval':                      ((code) => eval(from_fasl(code))),
      'is-finite':                 ((x) => isFinite(x) ? 1 : 0),
      'is-nan':                    ((x) => isNaN(x) ? 1 : 0),
      'parse-float':               ((s) => parseFloat(from_fasl(s))),
      'parse-int':                 ((s) => parseInt(from_fasl(s))),
      'decode-uri':                ((s) => decodeURI(from_fasl(s))),
      'decode-uri-component':      ((s) => decodeURIComponent(from_fasl(s))),
      'encode-uri':                ((s) => encodeURI(from_fasl(s))),
      'encode-uri-component':      ((s) => encodeURIComponent(from_fasl(s))),
      'escape':                    ((s) => escape(from_fasl(s))),
      'unescape':                  ((s) => unescape(from_fasl(s))),
      'object':                    (() => Object),
      'function':                  (() => Function),
      'boolean':                   (() => Boolean),
      'symbol':                    (() => Symbol),
      'error':                     (() => Error),
      'aggregate-error':           (() => (typeof AggregateError === 'undefined' ? undefined : AggregateError)),
      'eval-error':                (() => EvalError),
      'range-error':               (() => RangeError),
      'reference-error':           (() => ReferenceError),
      'suppressed-error':          (() => (typeof SuppressedError === 'undefined' ? undefined : SuppressedError)),
      'syntax-error':              (() => SyntaxError),
      'type-error':                (() => TypeError),
      'uri-error':                 (() => URIError),
      'internal-error':            (() => (typeof InternalError === 'undefined' ? undefined : InternalError)),
      'number':                    (() => Number),
      'bigint':                    (() => BigInt),
      'math':                      (() => Math),
      'date':                      (() => Date),
      'temporal':                  (() => (typeof Temporal === 'undefined' ? undefined : Temporal)),
      'string':                    (() => String),
      'reg-exp':                   (() => RegExp),
      'array':                     (() => Array),
      'typed-array':               (() => (typeof TypedArray === 'undefined' ? undefined : TypedArray)),
      'int8-array':                (() => Int8Array),
      'uint8-array':               (() => Uint8Array),
      'uint8-clamped-array':       (() => Uint8ClampedArray),
      'int16-array':               (() => Int16Array),
      'uint16-array':              (() => Uint16Array),
      'int32-array':               (() => Int32Array),
      'uint32-array':              (() => Uint32Array),
      'bigint64-array':            (() => (typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array)),
      'biguint64-array':           (() => (typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array)),
      'float16-array':             (() => (typeof Float16Array === 'undefined' ? undefined : Float16Array)),
      'float32-array':             (() => Float32Array),
      'float64-array':             (() => Float64Array),
      'map':                       (() => Map),
      'set':                       (() => Set),
      'weak-map':                  (() => WeakMap),
      'weak-set':                  (() => WeakSet),
      'array-buffer':              (() => ArrayBuffer),
      'shared-array-buffer':       (() => (typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer)),
      'data-view':                 (() => DataView),
      'atomics':                   (() => (typeof Atomics === 'undefined' ? undefined : Atomics)),
      'json':                      (() => JSON),
      'weak-ref':                  (() => (typeof WeakRef === 'undefined' ? undefined : WeakRef)),
      'finalization-registry':     (() => (typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry)),
      'iterator':                  (() => (typeof Iterator === 'undefined' ? undefined : Iterator)),
      'async-iterator':            (() => (typeof AsyncIterator === 'undefined' ? undefined : AsyncIterator)),
      'promise':                   (() => Promise),
      'generator-function':        (() => (typeof GeneratorFunction === 'undefined' ? undefined : GeneratorFunction)),
      'async-generator-function':  (() => (typeof AsyncGeneratorFunction === 'undefined' ? undefined : AsyncGeneratorFunction)),
      'generator':                 (() => (typeof Generator === 'undefined' ? undefined : Generator)),
      'async-generator':           (() => (typeof AsyncGenerator === 'undefined' ? undefined : AsyncGenerator)),
      'async-function':            (() => (typeof AsyncFunction === 'undefined' ? undefined : AsyncFunction)),
      'disposable-stack':          (() => (typeof DisposableStack === 'undefined' ? undefined : DisposableStack)),
      'async-disposable-stack':    (() => (typeof AsyncDisposableStack === 'undefined' ? undefined : AsyncDisposableStack)),
      'reflect':                   (() => Reflect),
      'proxy':                     (() => Proxy),
      'intl':                      (() => Intl),
      'intl-collator':             (() => ('Collator' in Intl ? Intl.Collator : undefined)),
      'intl-date-time-format':     (() => ('DateTimeFormat' in Intl ? Intl.DateTimeFormat : undefined)),
      'intl-display-names':        (() => ('DisplayNames' in Intl ? Intl.DisplayNames : undefined)),
      'intl-duration-format':      (() => ('DurationFormat' in Intl ? Intl.DurationFormat : undefined)),
      'intl-list-format':          (() => ('ListFormat' in Intl ? Intl.ListFormat : undefined)),
      'intl-locale':               (() => ('Locale' in Intl ? Intl.Locale : undefined)),
      'intl-number-format':        (() => ('NumberFormat' in Intl ? Intl.NumberFormat : undefined)),
      'intl-plural-rules':         (() => ('PluralRules' in Intl ? Intl.PluralRules : undefined)),
      'intl-relative-time-format': (() => ('RelativeTimeFormat' in Intl ? Intl.RelativeTimeFormat : undefined)),
      'intl-segmenter':            (() => ('Segmenter' in Intl ? Intl.Segmenter : undefined))
    },
    'math': {
        'abs':    ((x)       => Math.abs(x)),
        'acos':   ((x)       => Math.acos(x)),
        'acosh':  ((x)       => Math.acosh(x)),
        'asin':   ((x)       => Math.asin(x)),
        'asinh':  ((x)       => Math.asinh(x)),
        'atan':   ((x)       => Math.atan(x)),
        'atan2':  ((y, x)    => Math.atan2(y, x)),
        'atanh':  ((x)       => Math.atanh(x)),
        'cbrt':   ((x)       => Math.cbrt(x)),
        'ceil':   ((x)       => Math.ceil(x)),
        'clz32':  ((x)       => Math.clz32(x)),
        'cos':    ((x)       => Math.cos(x)),
        'cosh':   ((x)       => Math.cosh(x)),
        'exp':    ((x)       => Math.exp(x)),
        'expm1':  ((x)       => Math.expm1(x)),
        'floor':  ((x)       => Math.floor(x)),
        'fround': ((x)       => Math.fround(x)),
        'hypot':  ((x, y)    => Math.hypot(x, y)),
        'imul':   ((a, b)    => Math.imul(a, b)),
        'log':    ((x)       => Math.log(x)),
        'log10':  ((x)       => Math.log10(x)),
        'log1p':  ((x)       => Math.log1p(x)),
        'log2':   ((x)       => Math.log2(x)),
        'max':    ((x, y)    => Math.max(x, y)),
        'min':    ((x, y)    => Math.min(x, y)),
        'pow':    ((x, y)    => Math.pow(x, y)),
        'random': (()         => Math.random()),
        'round':  ((x)       => Math.round(x)),
        'sign':   ((x)       => Math.sign(x)),
        'sin':    ((x)       => Math.sin(x)),
        'sinh':   ((x)       => Math.sinh(x)),
        'sqrt':   ((x)       => Math.sqrt(x)),
        'tan':    ((x)       => Math.tan(x)),
        'tanh':   ((x)       => Math.tanh(x)),
        'trunc':  ((x)       => Math.trunc(x))
    },
    // Canvas
    'canvas': hasDOM ? {
        'capture-stream':                ((canvas, rate)                 => canvas.captureStream(rate)),
        'get-context':                   ((canvas, type, opts)           => canvas.getContext(from_fasl(type), opts)),
        'height':                        ((canvas)                       => canvas.height),
        'set-height!':                   ((canvas, h)                    => { canvas.height = h; }),
        'to-blob':                       ((canvas, cb, type, quality)    => canvas.toBlob(cb, from_fasl(type), quality)),
        'to-data-url':                   ((canvas, type, quality)        => canvas.toDataURL(from_fasl(type), quality)),
        'transfer-control-to-offscreen': ((canvas)                       => canvas.transferControlToOffscreen()),
        'width':                         ((canvas)                       => canvas.width),
        'set-width!':                    ((canvas, w)                    => { canvas.width = w; })
    } : {
        'capture-stream'()             { throw new Error('DOM not available in this environment'); },
        'get-context'()                { throw new Error('DOM not available in this environment'); },
        'height'()                     { throw new Error('DOM not available in this environment'); },
        'set-height!'()                { throw new Error('DOM not available in this environment'); },
        'to-blob'()                    { throw new Error('DOM not available in this environment'); },
        'to-data-url'()                { throw new Error('DOM not available in this environment'); },
        'transfer-control-to-offscreen'() { throw new Error('DOM not available in this environment'); },
        'width'()                      { throw new Error('DOM not available in this environment'); },
        'set-width!'()                 { throw new Error('DOM not available in this environment'); }
    },
    // CanvasRenderingContext2D
    'canvas-rendering-context-2d': hasDOM ? {
        'canvas':                 (ctx => ctx.canvas),
        'direction':              (ctx => ctx.direction),
        'set-direction!':         ((ctx, dir) => { ctx.direction = from_fasl(dir); }),
        'fill-style':             (ctx => ctx.fillStyle),
        'set-fill-style!':        ((ctx, style) => { ctx.fillStyle = style; }),
        'set-fill-style!/string': ((ctx, style) => { ctx.fillStyle = from_fasl(style); }),
        'filter':                 (ctx => ctx.filter),
        'set-filter!':            ((ctx, filter) => { ctx.filter = from_fasl(filter); }),
        'font':                   (ctx => ctx.font),
        'set-font!':              ((ctx, font) => { ctx.font = from_fasl(font); }),
        'global-alpha':           (ctx => ctx.globalAlpha),
        'set-global-alpha!':      ((ctx, a) => { ctx.globalAlpha = a; }),
        'global-composite-operation': (ctx => ctx.globalCompositeOperation),
        'set-global-composite-operation!': ((ctx, op) => { ctx.globalCompositeOperation = from_fasl(op); }),
        'image-smoothing-enabled': (ctx => ctx.imageSmoothingEnabled ? 1 : 0),
        'set-image-smoothing-enabled!': ((ctx, flag) => { ctx.imageSmoothingEnabled = !!flag; }),
        'image-smoothing-quality': (ctx => ctx.imageSmoothingQuality),
        'set-image-smoothing-quality!': ((ctx, q) => { ctx.imageSmoothingQuality = from_fasl(q); }),
        'line-cap':               (ctx => ctx.lineCap),
        'set-line-cap!':          ((ctx, cap) => { ctx.lineCap = from_fasl(cap); }),
        'line-dash-offset':       (ctx => ctx.lineDashOffset),
        'set-line-dash-offset!':  ((ctx, off) => { ctx.lineDashOffset = off; }),
        'line-join':              (ctx => ctx.lineJoin),
        'set-line-join!':         ((ctx, join) => { ctx.lineJoin = from_fasl(join); }),
        'line-width':             (ctx => ctx.lineWidth),
        'set-line-width!':        ((ctx, w) => { ctx.lineWidth = w; }),
        'miter-limit':            (ctx => ctx.miterLimit),
        'set-miter-limit!':       ((ctx, m) => { ctx.miterLimit = m; }),
        'shadow-blur':            (ctx => ctx.shadowBlur),
        'set-shadow-blur!':       ((ctx, b) => { ctx.shadowBlur = b; }),
        'shadow-color':           (ctx => ctx.shadowColor),
        'set-shadow-color!':      ((ctx, c) => { ctx.shadowColor = from_fasl(c); }),
        'shadow-offset-x':        (ctx => ctx.shadowOffsetX),
        'set-shadow-offset-x!':   ((ctx, x) => { ctx.shadowOffsetX = x; }),
        'shadow-offset-y':        (ctx => ctx.shadowOffsetY),
        'set-shadow-offset-y!':   ((ctx, y) => { ctx.shadowOffsetY = y; }),
        'stroke-style':           (ctx => ctx.strokeStyle),
        'set-stroke-style!':      ((ctx, style) => { ctx.strokeStyle = style; }),
        'text-align':             (ctx => ctx.textAlign),
        'set-text-align!':        ((ctx, a) => { ctx.textAlign = from_fasl(a); }),
        'text-baseline':          (ctx => ctx.textBaseline),
        'set-text-baseline!':     ((ctx, b) => { ctx.textBaseline = from_fasl(b); }),
        'text-rendering':         (ctx => ctx.textRendering),
        'set-text-rendering!':    ((ctx, r) => { ctx.textRendering = from_fasl(r); }),
        'font-kerning':           (ctx => ctx.fontKerning),
        'set-font-kerning!':      ((ctx, k) => { ctx.fontKerning = from_fasl(k); }),
        'font-stretch':           (ctx => ctx.fontStretch),
        'set-font-stretch!':      ((ctx, s) => { ctx.fontStretch = from_fasl(s); }),
        'font-variant-caps':      (ctx => ctx.fontVariantCaps),
        'set-font-variant-caps!': ((ctx, v) => { ctx.fontVariantCaps = from_fasl(v); }),
        'font-variant-ligatures': (ctx => ctx.fontVariantLigatures),
        'set-font-variant-ligatures!': ((ctx, v) => { ctx.fontVariantLigatures = from_fasl(v); }),
        'font-variant-numeric':   (ctx => ctx.fontVariantNumeric),
        'set-font-variant-numeric!': ((ctx, v) => { ctx.fontVariantNumeric = from_fasl(v); }),
        'letter-spacing':         (ctx => ctx.letterSpacing),
        'set-letter-spacing!':    ((ctx, v) => { ctx.letterSpacing = from_fasl(v); }),
        'word-spacing':           (ctx => ctx.wordSpacing),
        'set-word-spacing!':      ((ctx, v) => { ctx.wordSpacing = from_fasl(v); }),
        'arc': ((ctx, x, y, r, sa, ea, ccw) => ctx.arc(x, y, r, sa, ea, !!ccw)),
        'arc-to': ((ctx, x1, y1, x2, y2, r) => ctx.arcTo(x1, y1, x2, y2, r)),
        'begin-path': (ctx => ctx.beginPath()),
        'bezier-curve-to': ((ctx, cp1x, cp1y, cp2x, cp2y, x, y) => ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)),
        'clear-rect': ((ctx, x, y, w, h) => ctx.clearRect(x, y, w, h)),
        'clip': ((ctx, path, rule) => ctx.clip(path, from_fasl(rule))),
        'close-path': (ctx => ctx.closePath()),
        'create-image-data': ((ctx, sw, sh) => ctx.createImageData(sw, sh)),
        'create-image-data-from': ((ctx, data) => ctx.createImageData(data)),
        'create-linear-gradient': ((ctx, x0, y0, x1, y1) => ctx.createLinearGradient(x0, y0, x1, y1)),
        'create-pattern': ((ctx, img, rep) => ctx.createPattern(img, from_fasl(rep))),
        'create-radial-gradient': ((ctx, x0, y0, r0, x1, y1, r1) => ctx.createRadialGradient(x0, y0, r0, x1, y1, r1)),
        'create-conic-gradient': ((ctx, sa, x, y) => ctx.createConicGradient(sa, x, y)),
        'draw-focus-if-needed!': ((ctx, elem) => ctx.drawFocusIfNeeded(elem)),
        'draw-focus-if-needed-path!': ((ctx, path, elem) => ctx.drawFocusIfNeeded(path, elem)),
        'draw-image': ((ctx, img, dx, dy) => ctx.drawImage(img, dx, dy)),
        'draw-image-5': ((ctx, img, dx, dy, dw, dh) => ctx.drawImage(img, dx, dy, dw, dh)),
        'draw-image-9': ((ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) => ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh)),
        'ellipse': ((ctx, x, y, rx, ry, rot, sa, ea, ccw) => ctx.ellipse(x, y, rx, ry, rot, sa, ea, !!ccw)),
        'fill': ((ctx, path, rule) => ctx.fill(path, from_fasl(rule))),
        'fill-rect': ((ctx, x, y, w, h) => ctx.fillRect(x, y, w, h)),
        'fill-text': ((ctx, text, x, y, mw) => ctx.fillText(from_fasl(text), x, y, mw)),
        'get-image-data': ((ctx, sx, sy, sw, sh, opts) => ctx.getImageData(sx, sy, sw, sh, opts)),
        'get-line-dash': (ctx => ctx.getLineDash()),
        'get-transform': (ctx => ctx.getTransform()),
        'is-point-in-path': ((ctx, path, x, y, rule) => ctx.isPointInPath(path, x, y, from_fasl(rule)) ? 1 : 0),
        'is-point-in-stroke': ((ctx, path, x, y) => ctx.isPointInStroke(path, x, y) ? 1 : 0),
        'line-to': ((ctx, x, y) => ctx.lineTo(x, y)),
        'measure-text': ((ctx, text) => ctx.measureText(from_fasl(text))),
        'move-to': ((ctx, x, y) => ctx.moveTo(x, y)),
        'put-image-data': ((ctx, data, dx, dy, dirtyX, dirtyY, dirtyW, dirtyH) => ctx.putImageData(data, dx, dy, dirtyX, dirtyY, dirtyW, dirtyH)),
        'quadratic-curve-to': ((ctx, cpx, cpy, x, y) => ctx.quadraticCurveTo(cpx, cpy, x, y)),
        'rect': ((ctx, x, y, w, h) => ctx.rect(x, y, w, h)),
        'reset': (ctx => ctx.reset()),
        'reset-transform': (ctx => ctx.resetTransform()),
        'restore': (ctx => ctx.restore()),
        'rotate': ((ctx, angle) => ctx.rotate(angle)),
        'round-rect': ((ctx, x, y, w, h, r) => ctx.roundRect(x, y, w, h, r)),
        'save': (ctx => ctx.save()),
        'scale': ((ctx, x, y) => ctx.scale(x, y)),
        'set-line-dash': ((ctx, arr) => ctx.setLineDash(arr)),
        'set-transform!': ((ctx, a, b, c, d, e, f) => ctx.setTransform(a, b, c, d, e, f)),
        'set-transform-matrix!': ((ctx, m) => ctx.setTransform(m)),
        'stroke': ((ctx, path) => ctx.stroke(path)),
        'stroke-rect': ((ctx, x, y, w, h) => ctx.strokeRect(x, y, w, h)),
        'stroke-text': ((ctx, text, x, y, mw) => ctx.strokeText(from_fasl(text), x, y, mw)),
        'transform': ((ctx, a, b, c, d, e, f) => ctx.transform(a, b, c, d, e, f)),
        'translate': ((ctx, x, y) => ctx.translate(x, y)),
    } : new Proxy({}, { get() { throw new Error('DOM not available in this environment'); } }),
    // Document
    'document': hasDOM ? {
        'body':                     (()                               => document.body),
        'create-element':           ((local_name)                     => document.createElement(from_fasl(local_name))),
        'create-text-node':         ((fasl_start)                     => document.createTextNode(from_fasl(fasl_start))),
        'adopt-node':               ((node)                           => document.adoptNode(node)),
        'caret-range-from-point':   ((x, y)                           => document.caretRangeFromPoint(x, y)),
        'capture-events':           (()                               => document.captureEvents()),
        'clear':                    (()                               => document.clear()),
        'close':                    (()                               => document.close()),
        'create-attribute':         ((name)                           => document.createAttribute(from_fasl(name))),
        'create-attribute-ns':      ((ns, name)                      => document.createAttributeNS(from_fasl(ns), from_fasl(name))),
        'create-cdata-section':     ((data)                           => document.createCDATASection(from_fasl(data))),
        'create-comment':           ((data)                           => document.createComment(from_fasl(data))),
        'create-document-fragment': (()                               => document.createDocumentFragment()),
        'create-element-ns':        ((ns, name)                       => document.createElementNS(from_fasl(ns), from_fasl(name))),
        'create-event':             ((type)                           => document.createEvent(from_fasl(type))),
        'create-expression':        ((expr, resolver)                 => document.createExpression(from_fasl(expr), resolver)),
        'create-ns-resolver':       ((node)                           => document.createNSResolver(node)),
        'create-node-iterator':     ((root, what, filter)             => document.createNodeIterator(root, what, filter)),
        'create-processing-instruction': ((target, data)             => document.createProcessingInstruction(from_fasl(target), from_fasl(data))),
        'create-range':             (()                               => document.createRange()),
        'create-tree-walker':       ((root, what, filter)             => document.createTreeWalker(root, what, filter)),
        'element-from-point':       ((x, y)                           => document.elementFromPoint(x, y)),
        'elements-from-point':      ((x, y)                           => document.elementsFromPoint(x, y)),
        'enable-style-sheets-for-set': ((name)                        => document.enableStyleSheetsForSet(from_fasl(name))),
        'evaluate':                 ((expr, ctx, resolver, type, result) => document.evaluate(from_fasl(expr), ctx, resolver, type, result)),
        'exec-command':             ((cmd, show_ui, value)            => document.execCommand(from_fasl(cmd), !!show_ui, from_fasl(value)) ? 1 : 0),
        'exit-fullscreen':          (()                               => document.exitFullscreen()),
        'exit-picture-in-picture':  (()                               => document.exitPictureInPicture()),
        'exit-pointer-lock':        (()                               => document.exitPointerLock()),
        'get-element-by-id':        ((id)                             => document.getElementById(from_fasl(id))),
        'get-elements-by-class-name': ((class_name)                   => document.getElementsByClassName(from_fasl(class_name))),
        'get-elements-by-name':     ((name)                           => document.getElementsByName(from_fasl(name))),
        'get-elements-by-tag-name': ((name)                           => document.getElementsByTagName(from_fasl(name))),
        'get-elements-by-tag-name-ns': ((ns, name)                    => document.getElementsByTagNameNS(from_fasl(ns), from_fasl(name))),
        'get-selection':            (()                               => document.getSelection()),
        'has-focus':                (()                               => document.hasFocus() ? 1 : 0),
        'import-node':              ((node, deep)                     => document.importNode(node, !!deep)),
        'open':                     (()                               => document.open()),
        // Deprecated:
        // 'query-command-enabled':    ((cmd)                            => document.queryCommandEnabled(from_fasl(cmd)) ? 1 : 0),
        // 'query-command-indeterm':   ((cmd)                            => document.queryCommandIndeterm(from_fasl(cmd)) ? 1 : 0),
        // 'query-command-state':      ((cmd)                            => document.queryCommandState(from_fasl(cmd)) ? 1 : 0),
        // 'query-command-supported':  ((cmd)                            => document.queryCommandSupported(from_fasl(cmd)) ? 1 : 0),
        // 'query-command-value':      ((cmd)                            => document.queryCommandValue(from_fasl(cmd))),
        'query-selector':           ((sel)                            => document.querySelector(from_fasl(sel))),
        'query-selector-all':       ((sel)                            => document.querySelectorAll(from_fasl(sel))),
        'release-events':           (()                               => document.releaseEvents()),
        // Deprecated
        // 'write':                    ((text)                           => document.write(from_fasl(text))),
        // 'writeln':                  ((text)                           => document.writeln(from_fasl(text))),
    }
    : { // Node
        'body'()                     { throw new Error('DOM not available in this environment'); },
        'create-element'()           { throw new Error('DOM not available in this environment'); },
        'create-text-node'()         { throw new Error('DOM not available in this environment'); },
        'adopt-node'()               { throw new Error('DOM not available in this environment'); },
        'caret-range-from-point'()   { throw new Error('DOM not available in this environment'); },
        'capture-events'()           { throw new Error('DOM not available in this environment'); },
        'clear'()                    { throw new Error('DOM not available in this environment'); },
        'close'()                    { throw new Error('DOM not available in this environment'); },
        'create-attribute'()         { throw new Error('DOM not available in this environment'); },
        'create-attribute-ns'()      { throw new Error('DOM not available in this environment'); },
        'create-cdata-section'()     { throw new Error('DOM not available in this environment'); },
        'create-comment'()           { throw new Error('DOM not available in this environment'); },
        'create-document-fragment'() { throw new Error('DOM not available in this environment'); },
        'create-element-ns'()        { throw new Error('DOM not available in this environment'); },
        'create-event'()             { throw new Error('DOM not available in this environment'); },
        'create-expression'()        { throw new Error('DOM not available in this environment'); },
        'create-ns-resolver'()       { throw new Error('DOM not available in this environment'); },
        'create-node-iterator'()     { throw new Error('DOM not available in this environment'); },
        'create-processing-instruction'() { throw new Error('DOM not available in this environment'); },
        'create-range'()             { throw new Error('DOM not available in this environment'); },
        'create-tree-walker'()       { throw new Error('DOM not available in this environment'); },
        'element-from-point'()       { throw new Error('DOM not available in this environment'); },
        'elements-from-point'()      { throw new Error('DOM not available in this environment'); },
        'enable-style-sheets-for-set'() { throw new Error('DOM not available in this environment'); },
        'evaluate'()                 { throw new Error('DOM not available in this environment'); },
        'exec-command'()             { throw new Error('DOM not available in this environment'); },
        'exit-fullscreen'()          { throw new Error('DOM not available in this environment'); },
        'exit-picture-in-picture'()  { throw new Error('DOM not available in this environment'); },
        'exit-pointer-lock'()        { throw new Error('DOM not available in this environment'); },
        'get-element-by-id'()        { throw new Error('DOM not available in this environment'); },
        'get-elements-by-class-name'() { throw new Error('DOM not available in this environment'); },
        'get-elements-by-name'()     { throw new Error('DOM not available in this environment'); },
        'get-elements-by-tag-name'() { throw new Error('DOM not available in this environment'); },
        'get-elements-by-tag-name-ns'() { throw new Error('DOM not available in this environment'); },
        'get-selection'()            { throw new Error('DOM not available in this environment'); },
        'has-focus'()                { throw new Error('DOM not available in this environment'); },
        'import-node'()              { throw new Error('DOM not available in this environment'); },
        'open'()                     { throw new Error('DOM not available in this environment'); },
        'query-command-enabled'()    { throw new Error('DOM not available in this environment'); },
        'query-command-indeterm'()   { throw new Error('DOM not available in this environment'); },
        'query-command-state'()      { throw new Error('DOM not available in this environment'); },
        'query-command-supported'()  { throw new Error('DOM not available in this environment'); },
        'query-command-value'()      { throw new Error('DOM not available in this environment'); },
        'query-selector'()           { throw new Error('DOM not available in this environment'); },
        'query-selector-all'()       { throw new Error('DOM not available in this environment'); },
        'release-events'()           { throw new Error('DOM not available in this environment'); },
        'write'()                    { throw new Error('DOM not available in this environment'); },
        'writeln'()                  { throw new Error('DOM not available in this environment'); },
    },
    // Element
    'element': hasDOM ? {
        'append-child!':           ((parent, child)          => parent.appendChild(child)),
        'set-attribute!':          ((elem, name, value)      => elem.setAttribute(from_fasl(name), from_fasl(value))),
        'after!':                  ((elem, node)            => elem.after(node)),
        'animate':                 ((elem, keyframes, opts) => elem.animate(keyframes, opts)),
        'append!':                 ((elem, node)            => elem.append(node)),
        'attach-shadow!':          ((elem, init)            => elem.attachShadow(init)),
        'before!':                 ((elem, node)            => elem.before(node)),
        'closest':                 ((elem, sel)             => elem.closest(from_fasl(sel))),
        'computed-style-map':      ((elem)                  => elem.computedStyleMap()),
        'get-animations':          ((elem)                  => elem.getAnimations()),
        'get-attribute':           ((elem, name)            => elem.getAttribute(from_fasl(name))),
        'get-attribute-ns':        ((elem, ns, name)       => elem.getAttributeNS(from_fasl(ns), from_fasl(name))),
        'get-attribute-names':     ((elem)                  => elem.getAttributeNames()),
        'get-attribute-node':      ((elem, name)            => elem.getAttributeNode(from_fasl(name))),
        'get-attribute-node-ns':   ((elem, ns, name)       => elem.getAttributeNodeNS(from_fasl(ns), from_fasl(name))),
        'get-bounding-client-rect':((elem)                  => elem.getBoundingClientRect()),
        'get-client-rects':        ((elem)                  => elem.getClientRects()),
        'get-elements-by-class-name': ((elem, class_name)   => elem.getElementsByClassName(from_fasl(class_name))),
        'get-elements-by-tag-name':  ((elem, name)          => elem.getElementsByTagName(from_fasl(name))),
        'get-elements-by-tag-name-ns': ((elem, ns, name)    => elem.getElementsByTagNameNS(from_fasl(ns), from_fasl(name))),
        'has-attribute':           ((elem, name)            => elem.hasAttribute(from_fasl(name)) ? 1 : 0),
        'has-attribute-ns':        ((elem, ns, name)       => elem.hasAttributeNS(from_fasl(ns), from_fasl(name)) ? 1 : 0),
        'has-attributes':          ((elem)                  => elem.hasAttributes() ? 1 : 0),
        'has-pointer-capture':     ((elem, id)             => elem.hasPointerCapture(id) ? 1 : 0),
        'insert-adjacent-element!':((elem, pos, newElem)   => elem.insertAdjacentElement(from_fasl(pos), newElem)),
        'insert-adjacent-html!':   ((elem, pos, data)      => elem.insertAdjacentHTML(from_fasl(pos), from_fasl(data))),
        'insert-adjacent-text!':   ((elem, pos, data)      => elem.insertAdjacentText(from_fasl(pos), from_fasl(data))),
        'matches':                 ((elem, sel)            => elem.matches(from_fasl(sel)) ? 1 : 0),
        'prepend!':                ((elem, node)           => elem.prepend(node)),
        'query-selector':          ((elem, sel)            => elem.querySelector(from_fasl(sel))),
        'query-selector-all':      ((elem, sel)            => elem.querySelectorAll(from_fasl(sel))),
        'release-pointer-capture!':((elem, id)             => elem.releasePointerCapture(id)),
        'remove!':                 ((elem)                  => elem.remove()),
        'remove-attribute!':       ((elem, name)            => elem.removeAttribute(from_fasl(name))),
        'remove-attribute-ns!':    ((elem, ns, name)       => elem.removeAttributeNS(from_fasl(ns), from_fasl(name))),
        'remove-attribute-node!':  ((elem, attr)           => elem.removeAttributeNode(attr)),
        'replace-children!':       ((elem, node)           => elem.replaceChildren(node)),
        'replace-with!':           ((elem, node)           => elem.replaceWith(node)),
        'request-fullscreen':      ((elem)                  => elem.requestFullscreen()),
        'request-pointer-lock':    ((elem)                  => elem.requestPointerLock()),
        'scroll!':                 ((elem, x, y)           => elem.scroll(x, y)),
        'scroll-by!':              ((elem, x, y)           => elem.scrollBy(x, y)),
        'scroll-into-view!':       ((elem, b)              => elem.scrollIntoView(!!b)),
        'scroll-to!':              ((elem, x, y)           => elem.scrollTo(x, y)),
        'set-attribute-ns!':       ((elem, ns, name, value)=> elem.setAttributeNS(from_fasl(ns), from_fasl(name), from_fasl(value))),
        'set-attribute-node!':     ((elem, attr)           => elem.setAttributeNode(attr)),
        'set-attribute-node-ns!':  ((elem, attr)           => elem.setAttributeNodeNS(attr)),
        'set-pointer-capture!':    ((elem, id)             => elem.setPointerCapture(id)),
        'toggle-attribute!':       ((elem, name, force)    => elem.toggleAttribute(from_fasl(name), !!force) ? 1 : 0),
    } : {
        'append-child!'()             { throw new Error('DOM not available in this environment'); },
        'set-attribute!'()            { throw new Error('DOM not available in this environment'); },
        'after!'()                    { throw new Error('DOM not available in this environment'); },
        'animate'()                   { throw new Error('DOM not available in this environment'); },
        'append!'()                   { throw new Error('DOM not available in this environment'); },
        'attach-shadow!'()            { throw new Error('DOM not available in this environment'); },
        'before!'()                   { throw new Error('DOM not available in this environment'); },
        'closest'()                   { throw new Error('DOM not available in this environment'); },
        'computed-style-map'()        { throw new Error('DOM not available in this environment'); },
        'get-animations'()            { throw new Error('DOM not available in this environment'); },
        'get-attribute'()             { throw new Error('DOM not available in this environment'); },
        'get-attribute-ns'()          { throw new Error('DOM not available in this environment'); },
        'get-attribute-names'()       { throw new Error('DOM not available in this environment'); },
        'get-attribute-node'()        { throw new Error('DOM not available in this environment'); },
        'get-attribute-node-ns'()     { throw new Error('DOM not available in this environment'); },
        'get-bounding-client-rect'()  { throw new Error('DOM not available in this environment'); },
        'get-client-rects'()          { throw new Error('DOM not available in this environment'); },
        'get-elements-by-class-name'(){ throw new Error('DOM not available in this environment'); },
        'get-elements-by-tag-name'()  { throw new Error('DOM not available in this environment'); },
        'get-elements-by-tag-name-ns'(){ throw new Error('DOM not available in this environment'); },
        'has-attribute'()             { throw new Error('DOM not available in this environment'); },
        'has-attribute-ns'()          { throw new Error('DOM not available in this environment'); },
        'has-attributes'()            { throw new Error('DOM not available in this environment'); },
        'has-pointer-capture'()       { throw new Error('DOM not available in this environment'); },
        'insert-adjacent-element!'()  { throw new Error('DOM not available in this environment'); },
        'insert-adjacent-html!'()     { throw new Error('DOM not available in this environment'); },
        'insert-adjacent-text!'()     { throw new Error('DOM not available in this environment'); },
        'matches'()                   { throw new Error('DOM not available in this environment'); },
        'prepend!'()                  { throw new Error('DOM not available in this environment'); },
        'query-selector'()            { throw new Error('DOM not available in this environment'); },
        'query-selector-all'()        { throw new Error('DOM not available in this environment'); },
        'release-pointer-capture!'()  { throw new Error('DOM not available in this environment'); },
        'remove!'()                   { throw new Error('DOM not available in this environment'); },
        'remove-attribute!'()         { throw new Error('DOM not available in this environment'); },
        'remove-attribute-ns!'()      { throw new Error('DOM not available in this environment'); },
        'remove-attribute-node!'()    { throw new Error('DOM not available in this environment'); },
        'replace-children!'()         { throw new Error('DOM not available in this environment'); },
        'replace-with!'()             { throw new Error('DOM not available in this environment'); },
        'request-fullscreen'()        { throw new Error('DOM not available in this environment'); },
        'request-pointer-lock'()      { throw new Error('DOM not available in this environment'); },
        'scroll!'()                   { throw new Error('DOM not available in this environment'); },
        'scroll-by!'()                { throw new Error('DOM not available in this environment'); },
        'scroll-into-view!'()         { throw new Error('DOM not available in this environment'); },
        'scroll-to!'()                { throw new Error('DOM not available in this environment'); },
        'set-attribute-ns!'()         { throw new Error('DOM not available in this environment'); },
        'set-attribute-node!'()       { throw new Error('DOM not available in this environment'); },
        'set-attribute-node-ns!'()    { throw new Error('DOM not available in this environment'); },
        'set-pointer-capture!'()      { throw new Error('DOM not available in this environment'); },
        'toggle-attribute!'()         { throw new Error('DOM not available in this environment'); },
    }
};

const wasmModule
      = await WebAssembly
      .instantiate(wasmBuffer, imports)
      .then(results  => { const { entry, get_bytes, copy_bytes_to_memory } = results.instance.exports;
                          var result = entry();
                          // console.log( "Output:")
                          // console.log( output_string );
                          // console.log( "Result:")
                          // console.log( result );

                          // console.log( "Result bytes:" )
                          const bytes  = new Uint8Array(memory.buffer, 0, result);
                          console.log(new TextDecoder().decode(bytes));
                        });





})

(define (node-runtime out.wasm)
  @~a{// Generated by "assembler.rkt".
      import fs from 'node:fs/promises';
      
      const wasmBuffer = await fs.readFile("@|out.wasm|");
      
      @(runtime-common)
})

(define (browser-runtime out.wasm)
  @~a{<!DOCTYPE html>
     <html>
     <head><meta charset="UTF-8"></head>
     <body>
       <script type="module">
       // Generated by "assembler.rkt".
       const wasmBuffer = await fetch("@|out.wasm|").then(r => r.arrayBuffer());
       @(runtime-common)
       </script>
     </body>
     </html>
})

(define (runtime #:out  [out.wasm "out.wasm"]
                 #:host [host 'node])
  (case host
    [(node)    (node-runtime    out.wasm)]
    [(browser) (browser-runtime out.wasm)]
    [else      (error 'runtime (format "unknown host ~a" host))]))


;;;
;;; Driver
;;;

;; wat2wasm [options] filename
;;   read a file in the wasm text format, check it for errors, and
;;   convert it to the wasm binary format.
;; 
;;   examples:
;;     # parse test.wat and write to .wasm binary file with the same name
;;     $ wat2wasm test.wat
;;    
;;     # parse test.wat and write to binary file test.wasm
;;     $ wat2wasm test.wat -o test.wasm
;;    
;;     # parse spec-test.wast, and write verbose output to stdout (including
;;     # the meaning of every byte)
;;     $ wat2wasm spec-test.wast -v

(define (wat-pretty-print-table)
  (pretty-print-extend-style-table
   #f
   '(func   module block)
   '(lambda when   begin)))

(define (wat-pretty-write x)
  (parameterize ([current-print write]
                 [pretty-print-current-style-table (wat-pretty-print-table)])
    (pretty-write x)))

(define (print-wat x)
  (wat-pretty-write x))

(define (wat->wasm x #:wat [out.wat "out.wat"] #:wasm [out.wasm "out.wasm"])
  ; The argument x is an s-expresssion.
  ; It represents a WebAssembly module in textual format.

  ; 1. Write the module x to a wat file
  (with-output-to-file out.wat
    (Î» ()
      (wat-pretty-write x))
    #:exists 'replace)
  ; 2. Compile the wat file into a wasm file.
  (define success? #t)
  (define compilation-output
    (with-output-to-string
      (Î» ()
        (set! success?
              (system
               (format (~a assembler-path "/" "wasm-tools parse ~a -o ~a ")
                       out.wat out.wasm))))))
  ; 3. If there were any errors, display the error messages
  (unless success?
    (displayln "* Compilation Error *")
    (displayln compilation-output))
  ; 4. Return success?
  success?)


(define (run [x #f] 
             #:wat        [out.wat    "out.wat"]
             #:wasm       [out.wasm   "out.wasm"]
             #:runtime.js [runtime.js "runtime.js"])
  ; (print-wat x)
  ; 1. If needed compile textual format to wasm file.  
  (define okay?
    (if x
        (wat->wasm x #:wat out.wat #:wasm out.wasm)
        #t))
  (when okay?
    ; 2. Write runtime
    (with-output-to-file runtime.js
      (Î» () (displayln (runtime #:out out.wasm)))
      #:exists 'replace)
    ; 3. Invoke runtime.js using Node
    (define success? #t)
    (define output
      (with-output-to-string
        (Î» ()
          (set! success?
                (system (format "/usr/local/bin/node --expose-gc ~a"
                                runtime.js))))))
    ; 3. If there were any errors, display the error messages
    (displayln output)))
