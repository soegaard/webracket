#lang at-exp racket
(provide run wat->wasm runtime)
(require "fasl.rkt")

;;;
;;; ASSEMBLER
;;;

; The assembler takes a Web Assembly program in the folded textual format (.wat)
; and produces a binary (.wasm).

; Currently we use an external tool  `wasm-tools` from the Bytecode Alliance.

; The host file (default: runtime.js) is also generated by the assembler.


;;; USAGE

;; (run [x #f] 
;;      #:wat        [out.wat    "out.wat"]
;;      #:wasm       [out.wasm   "out.wasm"]
;;      #:runtime.js [runtime.js "runtime.js"])

;; (wat->wasm x
;;            #:wat [out.wat "out.wat"]
;;            #:wasm [out.wasm "out.wasm"])


;;;
;;; TODO
;;;

; Some of the comments below refer to the external tool `wabt` but
; as it turns out, it doesn't support the GC proposal.


;;;
;;; NOTES
;;; 

; The assembler `wat2wasm` from the "official" wabt tools
; does not support the GC proposal (which includes i31).
; The tool has a flag `--enable-gc` but it has no effect on the assembler.
; The issue is that the options are shared between a set of tools,
; and some of the other tools support the GC proposal.

; (define tool-path "/Users/soegaard/Dropbox/github/wabt/bin")

; The chosen assembler is instead `wasm-tools` which is a Rust project.
; There are prebuilt binaries in the release assets:
;
;     https://github.com/bytecodealliance/wasm-tools/releases
;
; The current version is 1.230.0 (May 2025).

; List the available commands:
;    ./wasm-tools
; Help for the `parse` tool:
;  ./wasm-tools parse --help
; The `parse` tool converts form the textual format (wat) to
; the binary format (wasm). 

;;;
;;; ASSEMBLER
;;;

(define assembler-path "/Users/soegaard/tmp/wasm-tools-1.230.0-aarch64-macos")

;;;
;;; RUNTIME
;;;

;; The runtime generated for the Node and the Browser is the mostly identical.
;; The only difference is that Node uses `fs.readfile` to load the wasm
;; and the browser needs to fetch it.

(define (runtime-common)
  @~a{
var memory = new WebAssembly.Memory({initial:1024});

var output_string = [];

function read_u32(arr, i) {
  return ((arr[i] << 24) | (arr[i + 1] << 16) |
          (arr[i + 2] << 8)  | arr[i + 3]) >>> 0;
}

function fasl_to_js_value(arr, i = 0) {
  console.log(arr);
  console.log(i);
                                       
  const tag = arr[i++];

  function u32() {
    const v = read_u32(arr, i);
    i += 4;
    return v;
  }

  function read_bytes() {
    const len = u32();
    const b = arr.slice(i, i + len);
    i += len;
    return b;
  }

  function read_string() {
    const b = read_bytes();
    return new TextDecoder().decode(b);
  }

  switch(tag) {
    case @|fasl-fixnum|: {
      const raw = u32();
      // Sign-extend the 30-bit payload so negative fixnums decode correctly.
      return [(raw << 2) >> 2, i];
    }
    case @|fasl-character|:
      return [String.fromCodePoint(u32()), i];
    case @|fasl-symbol|:
      return [Symbol.for(read_string()), i];
    case @|fasl-string|:
      return [read_string(), i];
    case @|fasl-bytes|:
      return [read_bytes(), i];
    case @|fasl-boolean|:
      return [arr[i++] !== 0, i];
    case @|fasl-null|:
      return [null, i];
    case @|fasl-pair|: {
      let car, cdr;
      [car, i] = fasl_to_js_value(arr, i);
      [cdr, i] = fasl_to_js_value(arr, i);
      return [{tag:'pair', car, cdr}, i];
    }
    case @|fasl-vector|: {
      const n = u32();
      const vec = new Array(n);
      for(let j = 0; j < n; j++) {
        [vec[j], i] = fasl_to_js_value(arr, i);
      }
      return [vec, i];
    }
    case @|fasl-flonum|: {
      const hi = u32();
      const lo = u32();
      const dv = new DataView(new ArrayBuffer(8));
      dv.setUint32(0, hi);
      dv.setUint32(4, lo);
      return [dv.getFloat64(0), i];
    }
    case @|fasl-void|:
      return [undefined, i];
    case @|fasl-eof|:
      return ['<eof>', i];
    default:
      throw new Error('bad FASL tag ' + tag);
  }
}

function js_value_to_fasl(v) {
  const out = [];
  const enc = new TextEncoder();

  // --- low-level writers (big-endian) ---
  function writeByte(b) {
    out.push(b & 0xFF);
  }
  function writeU32(u) {
    out.push((u >>> 24) & 0xFF, (u >>> 16) & 0xFF, (u >>> 8) & 0xFF, u & 0xFF);
  }
  function writeBytes(u8) {
    writeU32(u8.length >>> 0);
    for (let i = 0; i < u8.length; i++) out.push(u8[i] & 0xFF);
  }
  function writeString(s) {
    const u8 = enc.encode(s);
    writeBytes(u8);
  }
  function writeF64(x) {
    const dv = new DataView(new ArrayBuffer(8));
    // Big-endian
    dv.setFloat64(0, x, false);
    const hi = dv.getUint32(0, false);
    const lo = dv.getUint32(4, false);
    writeU32(hi);
    writeU32(lo);
  }

  // --- tagged writers ---
  function writeFixnum(n) {
    // 30-bit signed two's complement payload; range: [-2^29, 2^29-1]
    if (!Number.isInteger(n) || n < -(1 << 29) || n > ((1 << 29) - 1)) {
      throw new RangeError("fixnum out of 30-bit range");
    }
    writeByte(@|fasl-fixnum|);
    const raw30 = n & 0x3FFFFFFF; // 30-bit two's complement payload
    writeU32(raw30 >>> 0);
  }
  function writeFlonum(x) {
    writeByte(@|fasl-flonum|);
    writeF64(x);
  }
  function writeCharacter(cp) {
    // cp = Unicode scalar value (number)
    writeByte(@|fasl-character|);
    writeU32(cp >>> 0);
  }
  function writeSymbol(name) {
    writeByte(@|fasl-symbol|);
    writeString(name);
  }
  function writeStringVal(s) {
    writeByte(@|fasl-string|);
    writeString(s);
  }
  function writeBytesVal(u8) {
    writeByte(@|fasl-bytes|);
    writeBytes(u8);
  }
  function writeBoolean(b) {
    writeByte(@|fasl-boolean|);
    writeByte(b ? 1 : 0);
  }
  function writeNull() {
    writeByte(@|fasl-null|);
  }
  function writeVoid() {
    writeByte(@|fasl-void|);
  }
  function writeEof() {
    writeByte(@|fasl-eof|);
  }
  function writePair(car, cdr) {
    writeByte(@|fasl-pair|);
    writeAny(car);
    writeAny(cdr);
  }
  function writeVector(arr) {
    writeByte(@|fasl-vector|);
    writeU32(arr.length >>> 0);
    for (let i = 0; i < arr.length; i++) writeAny(arr[i]);
  }

  // --- main dispatcher (mirrors fasl_to_js_value mapping) ---
  function writeAny(x) {
    // Fast paths by JS type
    if (typeof x === "number") {
      if (Number.isInteger(x) && x >= -(1 << 29) && x <= ((1 << 29) - 1)) {
        writeFixnum(x);
      } else {
        writeFlonum(x);
      }
      return;
    }
    if (typeof x === "boolean") {
      writeBoolean(x);
      return;
    }
    if (x === null) {
      writeNull();
      return;
    }
    if (x === undefined) {
      writeVoid();
      return;
    }
    // EoF sentinel (match your decoder's '<eof>' convention)
    if (x === "<eof>" || (x && x.tag === "eof")) {
      writeEof();
      return;
    }
    // Character (two accepted forms)
    //   { tag: 'char', cp: <codepoint> }  or  { tag: 'char', ch: 'A' }
    if (x && x.tag === "char") {
      const cp = typeof x.cp === "number" ? x.cp
               : (typeof x.ch === "string" ? x.ch.codePointAt(0) : undefined);
      if (cp === undefined) throw new TypeError("bad char object");
      writeCharacter(cp >>> 0);
      return;
    }
    // Pair (your decoder uses {tag:'pair', car, cdr})
    if (x && x.tag === "pair") {
      writePair(x.car, x.cdr);
      return;
    }
    // Bytes: prefer Uint8Array
    if (x instanceof Uint8Array) {
      writeBytesVal(x);
      return;
    }
    // Accept raw byte arrays too
    if (Array.isArray(x) && x.every(n => Number.isInteger(n) && n >= 0 && n <= 255)) {
      writeBytesVal(Uint8Array.from(x));
      return;
    }
    // Vector: plain JS Array (distinct from bytes above)
    if (Array.isArray(x)) {
      writeVector(x);
      return;
    }
    // Symbol
    if (typeof x === "symbol") {
      const name = Symbol.keyFor(x) ?? x.description ?? "";
      writeSymbol(name);
      return;
    }
    // String
    if (typeof x === "string") {
      writeStringVal(x);
      return;
    }
    throw new TypeError("unsupported value for FASL encoding: " + String(x));
  }
  writeAny(v);
  return Uint8Array.from(out);
}

function testsuite(js_value_to_fasl, fasl_to_js_value, { log = true } = {}) {
  // --- helpers -------------------------------------------------------------
  function charToString(v) {
    if (typeof v === 'string' && v.length === 1) return v;
    if (v && typeof v === 'object' && v.tag === 'char' && typeof v.cp === 'number') {
      try { return String.fromCodePoint(v.cp); } catch { /* fall through */ }
    }
    return null;
  }

  function deepEq(a, b) {
    // Treat "char-wrappers" and 1-char strings as equal
    const ac = charToString(a), bc = charToString(b);
    if (ac !== null || bc !== null) return ac === bc;
    // numbers (handle NaN, -0)
    if (typeof a === 'number' || typeof b === 'number') return Object.is(a, b);
    // Uint8Array (bytes)
    if (a instanceof Uint8Array && b instanceof Uint8Array) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
      return true;
    }
    // Symbols (use registry key or description)
    if (typeof a === 'symbol' && typeof b === 'symbol') {
      const ka = Symbol.keyFor(a) ?? a.description ?? '';
      const kb = Symbol.keyFor(b) ?? b.description ?? '';
      return ka === kb;
    }
    // Pairs
    if (a && b && a.tag === 'pair' && b.tag === 'pair') {
      return deepEq(a.car, b.car) && deepEq(a.cdr, b.cdr);
    }
    // Arrays (vectors)
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) if (!deepEq(a[i], b[i])) return false;
      return true;
    }
    // Strings, booleans, null, undefined, "<eof>"
    return a === b;
  }
  function roundtrip(v) {
    const bytes = js_value_to_fasl(v);
    const [v2] = fasl_to_js_value(bytes);
    const ok = deepEq(v2, v);
    if (!ok && log) {
      console.error('Roundtrip mismatch:', v, '->', v2, 'bytes=', bytes);
    }
    return ok;
  }
  function test(name, v) {
    const ok = roundtrip(v);
    results.push({ name, ok });
    if (log) console.log(`${ok ? 'âœ“' : 'âœ—'} ${name}`);
    if (ok) pass++; else fail++;
  }

  // --- run tests -----------------------------------------------------------
  const results = [];
  let pass = 0, fail = 0;
  
  // Fixnums (30-bit)
  test('fixnum 0', 0);
  test('fixnum 123', 123);
  test('fixnum -5', -5);
  // Flonums
  test('flonum 1.5', 1.5);
  test('flonum -0.0', -0.0);
  test('flonum NaN', NaN);
  test('flonum +Inf', Infinity);
  test('flonum -Inf', -Infinity);
  // Booleans / null / void / eof
  test('boolean true', true);
  test('boolean false', false);
  test('null', null);
  test('void/undefined', undefined);
  test('eof sentinel', '<eof>');
  // Characters (encode via wrapper; decoder yields 1-char string)
  test('char A', { tag: 'char', cp: 'A'.codePointAt(0) });
  test('char snowman', { tag: 'char', cp: 'â˜ƒ'.codePointAt(0) });
  // Symbols
  test('symbol foo', Symbol.for('foo'));
  // Bytes (Uint8Array)
  test('bytes', new Uint8Array([0, 1, 2, 255]));
  // Pairs
  test('pair (1 . null)', { tag: 'pair', car: 1, cdr: null });
  test('list (1 2)',
       { tag: 'pair', car: 1, cdr: { tag: 'pair', car: 2, cdr: null } });
  // Vectors (arrays)
  test('vector mixed',
       [ 1, 2.5, { tag: 'pair', car: 'x', cdr: null }, true ]);
  // Strings
  test('string ascii', 'hello');
  test('string utf8', 'hÃ©llÃ¸ ðŸŒ');

  return { pass, fail, total: pass + fail, results };
}

// Uncomment to run the testsuite for fasl.
// Currently the only failing test is the one for -0.0 which after the round trip becomes 0.0.
// This is not fixabable as long as we convert integers to fixnums.

// const summary = testsuite(js_value_to_fasl, fasl_to_js_value, { log: true });
// console.log(`\nPassed: ${summary.pass}/${summary.total}`);
// if (summary.fail) {
//   console.log('Failures:');
//    for (const r of summary.results.filter(r => !r.ok)) {
//    console.log('  -', r.name);
//  }
// }

// hasDOM gives us a way of determining whether the host is a browser or Node
const hasDOM = typeof document !== 'undefined' && typeof document.createTextNode === 'function';

var imports = {
    'env': {
        'memory': memory
    },
    'primitives': {
      'console_log': ((x)   => console.log(x)),
      'add':         ((x,y) => x+y),
      'js_output':   ((x)   => output_string.push(x)),
      'js_print_fasl': ((start, len) => {
        const bytes = new Uint8Array(memory.buffer).slice(start, start + len);
        const [v] = fasl_to_js_value(bytes);
        console.log(v);
      })
    },
    document: hasDOM ? {
        // Browser
        body:               (()              => document.body),
        'create-text-node': ((fasl_start)    => document.createTextNode(fasl_to_js_value(new Uint8Array(memory.buffer), fasl_start)[0])),
        'append-child!':    ((parent, child) => parent.appendChild(child)),
    }
    : { // Node
        body()               { throw new Error('DOM not available in this environment'); },
        'create-text-node'() { throw new Error('DOM not available in this environment'); },
        'append-child!'()    { throw new Error('DOM not available in this environment'); },
    }
};

const wasmModule
      = await WebAssembly
      .instantiate(wasmBuffer, imports)
      .then(results  => { const { entry, get_bytes, copy_bytes_to_memory } = results.instance.exports;
                          var result = entry();
                          // console.log( "Output:")
                          // console.log( output_string );
                          // console.log( "Result:")
                          // console.log( result );

                          // console.log( "Result bytes:" )
                          const bytes  = new Uint8Array(memory.buffer, 0, result);
                          console.log(new TextDecoder().decode(bytes));
                        });





})

(define (node-runtime out.wasm)
  @~a{// Generated by "assembler.rkt".
      import fs from 'node:fs/promises';
      
      const wasmBuffer = await fs.readFile("@|out.wasm|");
      
      @(runtime-common)
})

(define (browser-runtime out.wasm)
  @~a{<!DOCTYPE html>
     <html>
     <head><meta charset="UTF-8"></head>
     <body>
       <script type="module">
       // Generated by "assembler.rkt".
       const wasmBuffer = await fetch("@|out.wasm|").then(r => r.arrayBuffer());
       @(runtime-common)
       </script>
     </body>
     </html>
})

(define (runtime #:out  [out.wasm "out.wasm"]
                 #:host [host 'node])
  (case host
    [(node)    (node-runtime    out.wasm)]
    [(browser) (browser-runtime out.wasm)]
    [else      (error 'runtime (format "unknown host ~a" host))]))


;;;
;;; Driver
;;;

;; wat2wasm [options] filename
;;   read a file in the wasm text format, check it for errors, and
;;   convert it to the wasm binary format.
;; 
;;   examples:
;;     # parse test.wat and write to .wasm binary file with the same name
;;     $ wat2wasm test.wat
;;    
;;     # parse test.wat and write to binary file test.wasm
;;     $ wat2wasm test.wat -o test.wasm
;;    
;;     # parse spec-test.wast, and write verbose output to stdout (including
;;     # the meaning of every byte)
;;     $ wat2wasm spec-test.wast -v

(define (wat-pretty-print-table)
  (pretty-print-extend-style-table
   #f
   '(func   module block)
   '(lambda when   begin)))

(define (wat-pretty-write x)
  (parameterize ([current-print write]
                 [pretty-print-current-style-table (wat-pretty-print-table)])
    (pretty-write x)))

(define (print-wat x)
  (wat-pretty-write x))

(define (wat->wasm x #:wat [out.wat "out.wat"] #:wasm [out.wasm "out.wasm"])
  ; The argument x is an s-expresssion.
  ; It represents a WebAssembly module in textual format.

  ; 1. Write the module x to a wat file
  (with-output-to-file out.wat
    (Î» ()
      (wat-pretty-write x))
    #:exists 'replace)
  ; 2. Compile the wat file into a wasm file.
  (define success? #t)
  (define compilation-output
    (with-output-to-string
      (Î» ()
        (set! success?
              (system
               (format (~a assembler-path "/" "wasm-tools parse ~a -o ~a ")
                       out.wat out.wasm))))))
  ; 3. If there were any errors, display the error messages
  (unless success?
    (displayln "* Compilation Error *")
    (displayln compilation-output))
  ; 4. Return success?
  success?)


(define (run [x #f] 
             #:wat        [out.wat    "out.wat"]
             #:wasm       [out.wasm   "out.wasm"]
             #:runtime.js [runtime.js "runtime.js"])
  ; (print-wat x)
  ; 1. If needed compile textual format to wasm file.  
  (define okay?
    (if x
        (wat->wasm x #:wat out.wat #:wasm out.wasm)
        #t))
  (when okay?
    ; 2. Write runtime
    (with-output-to-file runtime.js
      (Î» () (displayln (runtime #:out out.wasm)))
      #:exists 'replace)
    ; 3. Invoke runtime.js using Node
    (define success? #t)
    (define output
      (with-output-to-string
        (Î» ()
          (set! success?
                (system (format "/usr/local/bin/node --expose-gc ~a"
                                runtime.js))))))
    ; 3. If there were any errors, display the error messages
    (displayln output)))
