#lang at-exp racket
(provide run wat->wasm runtime)
(require "fasl.rkt")

;;;
;;; ASSEMBLER
;;;

; The assembler takes a Web Assembly program in the folded textual format (.wat)
; and produces a binary (.wasm).

; Currently we use an external tool  `wasm-tools` from the Bytecode Alliance.

; The host file (default: runtime.js) is also generated by the assembler.


;;; USAGE

;; (run [x #f] 
;;      #:wat        [out.wat    "out.wat"]
;;      #:wasm       [out.wasm   "out.wasm"]
;;      #:runtime.js [runtime.js "runtime.js"])

;; (wat->wasm x
;;            #:wat [out.wat "out.wat"]
;;            #:wasm [out.wasm "out.wasm"])


;;;
;;; TODO
;;;

; Some of the comments below refer to the external tool `wabt` but
; as it turns out, it doesn't support the GC proposal.


;;;
;;; NOTES
;;; 

; The assembler `wat2wasm` from the "official" wabt tools
; does not support the GC proposal (which includes i31).
; The tool has a flag `--enable-gc` but it has no effect on the assembler.
; The issue is that the options are shared between a set of tools,
; and some of the other tools support the GC proposal.

; (define tool-path "/Users/soegaard/Dropbox/github/wabt/bin")

; The chosen assembler is instead `wasm-tools` which is a Rust project.
; There are prebuilt binaries in the release assets:
;
;     https://github.com/bytecodealliance/wasm-tools/releases
;
; The current version is 1.230.0 (May 2025).

; List the available commands:
;    ./wasm-tools
; Help for the `parse` tool:
;  ./wasm-tools parse --help
; The `parse` tool converts form the textual format (wat) to
; the binary format (wasm). 

;;;
;;; ASSEMBLER
;;;

(define assembler-path "/Users/soegaard/tmp/wasm-tools-1.230.0-aarch64-macos")

;;;
;;; RUNTIME
;;;

;; The runtime generated for the Node and the Browser is the mostly identical.
;; The only difference is that Node uses `fs.readfile` to load the wasm
;; and the browser needs to fetch it.

(define (runtime-common)
  @~a{
var memory = new WebAssembly.Memory({initial:1024});

var output_string = [];

function read_u32(arr, i) {
  return ((arr[i] << 24) | (arr[i + 1] << 16) |
          (arr[i + 2] << 8)  | arr[i + 3]) >>> 0;
}

function fasl_to_js_value(arr, i = 0) {
                                       
  const tag = arr[i++];

  function u32() {
    const v = read_u32(arr, i);
    i += 4;
    return v;
  }

  function read_bytes() {
    const len = u32();
    const b = arr.slice(i, i + len);
    i += len;
    return b;
  }

  function read_string() {
    const b = read_bytes();
    return new TextDecoder().decode(b);
  }

  switch(tag) {
    case @|fasl-fixnum|: {
      const raw = u32();
      // Sign-extend the 30-bit payload so negative fixnums decode correctly.
      return [(raw << 2) >> 2, i];
    }
    case @|fasl-character|:
      return [String.fromCodePoint(u32()), i];
    case @|fasl-symbol|:
      return [Symbol.for(read_string()), i];
    case @|fasl-string|:
      return [read_string(), i];
    case @|fasl-bytes|:
      return [read_bytes(), i];
    case @|fasl-boolean|:
      return [arr[i++] !== 0, i];
    case @|fasl-null|:
      return [null, i];
    case @|fasl-pair|: {
      let car, cdr;
      [car, i] = fasl_to_js_value(arr, i);
      [cdr, i] = fasl_to_js_value(arr, i);
      return [{tag:'pair', car, cdr}, i];
    }
    case @|fasl-vector|: {
      const n = u32();
      const vec = new Array(n);
      for(let j = 0; j < n; j++) {
        [vec[j], i] = fasl_to_js_value(arr, i);
      }
      return [vec, i];
    }
    case @|fasl-flonum|: {
      const hi = u32();
      const lo = u32();
      const dv = new DataView(new ArrayBuffer(8));
      dv.setUint32(0, hi);
      dv.setUint32(4, lo);
      return [dv.getFloat64(0), i];
    }
    case @|fasl-void|:
      return [undefined, i];
    case @|fasl-eof|:
      return ['<eof>', i];
    default:
      throw new Error('bad FASL tag ' + tag);
  }
}

function js_value_to_fasl(v) {
  const out = [];
  const enc = new TextEncoder();

  // --- low-level writers (big-endian) ---
  function writeByte(b) {
    out.push(b & 0xFF);
  }
  function writeU32(u) {
    out.push((u >>> 24) & 0xFF, (u >>> 16) & 0xFF, (u >>> 8) & 0xFF, u & 0xFF);
  }
  function writeBytes(u8) {
    writeU32(u8.length >>> 0);
    for (let i = 0; i < u8.length; i++) out.push(u8[i] & 0xFF);
  }
  function writeString(s) {
    const u8 = enc.encode(s);
    writeBytes(u8);
  }
  function writeF64(x) {
    const dv = new DataView(new ArrayBuffer(8));
    // Big-endian
    dv.setFloat64(0, x, false);
    const hi = dv.getUint32(0, false);
    const lo = dv.getUint32(4, false);
    writeU32(hi);
    writeU32(lo);
  }

  // --- tagged writers ---
  function writeFixnum(n) {
    // 30-bit signed two's complement payload; range: [-2^29, 2^29-1]
    if (!Number.isInteger(n) || n < -(1 << 29) || n > ((1 << 29) - 1)) {
      throw new RangeError("fixnum out of 30-bit range");
    }
    writeByte(@|fasl-fixnum|);
    const raw30 = n & 0x3FFFFFFF; // 30-bit two's complement payload
    writeU32(raw30 >>> 0);
  }
  function writeFlonum(x) {
    writeByte(@|fasl-flonum|);
    writeF64(x);
  }
  function writeCharacter(cp) {
    // cp = Unicode scalar value (number)
    writeByte(@|fasl-character|);
    writeU32(cp >>> 0);
  }
  function writeSymbol(name) {
    writeByte(@|fasl-symbol|);
    writeString(name);
  }
  function writeStringVal(s) {
    writeByte(@|fasl-string|);
    writeString(s);
  }
  function writeBytesVal(u8) {
    writeByte(@|fasl-bytes|);
    writeBytes(u8);
  }
  function writeBoolean(b) {
    writeByte(@|fasl-boolean|);
    writeByte(b ? 1 : 0);
  }
  function writeNull() {
    writeByte(@|fasl-null|);
  }
  function writeVoid() {
    writeByte(@|fasl-void|);
  }
  function writeEof() {
    writeByte(@|fasl-eof|);
  }
  function writePair(car, cdr) {
    writeByte(@|fasl-pair|);
    writeAny(car);
    writeAny(cdr);
  }
  function writeVector(arr) {
    writeByte(@|fasl-vector|);
    writeU32(arr.length >>> 0);
    for (let i = 0; i < arr.length; i++) writeAny(arr[i]);
  }

  // --- main dispatcher (mirrors fasl_to_js_value mapping) ---
  function writeAny(x) {
    // Fast paths by JS type
    if (typeof x === "number") {
      if (Number.isInteger(x) && x >= -(1 << 29) && x <= ((1 << 29) - 1)) {
        writeFixnum(x);
      } else {
        writeFlonum(x);
      }
      return;
    }
    if (typeof x === "boolean") {
      writeBoolean(x);
      return;
    }
    if (x === null) {
      writeNull();
      return;
    }
    if (x === undefined) {
      writeVoid();
      return;
    }
    // EoF sentinel (match your decoder's '<eof>' convention)
    if (x === "<eof>" || (x && x.tag === "eof")) {
      writeEof();
      return;
    }
    // Character (two accepted forms)
    //   { tag: 'char', cp: <codepoint> }  or  { tag: 'char', ch: 'A' }
    if (x && x.tag === "char") {
      const cp = typeof x.cp === "number" ? x.cp
               : (typeof x.ch === "string" ? x.ch.codePointAt(0) : undefined);
      if (cp === undefined) throw new TypeError("bad char object");
      writeCharacter(cp >>> 0);
      return;
    }
    // Pair (your decoder uses {tag:'pair', car, cdr})
    if (x && x.tag === "pair") {
      writePair(x.car, x.cdr);
      return;
    }
    // Bytes: prefer Uint8Array
    if (x instanceof Uint8Array) {
      writeBytesVal(x);
      return;
    }
    // Accept raw byte arrays too
    if (Array.isArray(x) && x.every(n => Number.isInteger(n) && n >= 0 && n <= 255)) {
      writeBytesVal(Uint8Array.from(x));
      return;
    }
    // Vector: plain JS Array (distinct from bytes above)
    if (Array.isArray(x)) {
      writeVector(x);
      return;
    }
    // Symbol
    if (typeof x === "symbol") {
      const name = Symbol.keyFor(x) ?? x.description ?? "";
      writeSymbol(name);
      return;
    }
    // String
    if (typeof x === "string") {
      writeStringVal(x);
      return;
    }
    throw new TypeError("unsupported value for FASL encoding: " + String(x));
  }
  writeAny(v);
  return Uint8Array.from(out);
}

function testsuite(js_value_to_fasl, fasl_to_js_value, { log = true } = {}) {
  // --- helpers -------------------------------------------------------------
  function charToString(v) {
    if (typeof v === 'string' && v.length === 1) return v;
    if (v && typeof v === 'object' && v.tag === 'char' && typeof v.cp === 'number') {
      try { return String.fromCodePoint(v.cp); } catch { /* fall through */ }
    }
    return null;
  }

  function deepEq(a, b) {
    // Treat "char-wrappers" and 1-char strings as equal
    const ac = charToString(a), bc = charToString(b);
    if (ac !== null || bc !== null) return ac === bc;
    // numbers (handle NaN, -0)
    if (typeof a === 'number' || typeof b === 'number') return Object.is(a, b);
    // Uint8Array (bytes)
    if (a instanceof Uint8Array && b instanceof Uint8Array) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
      return true;
    }
    // Symbols (use registry key or description)
    if (typeof a === 'symbol' && typeof b === 'symbol') {
      const ka = Symbol.keyFor(a) ?? a.description ?? '';
      const kb = Symbol.keyFor(b) ?? b.description ?? '';
      return ka === kb;
    }
    // Pairs
    if (a && b && a.tag === 'pair' && b.tag === 'pair') {
      return deepEq(a.car, b.car) && deepEq(a.cdr, b.cdr);
    }
    // Arrays (vectors)
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) if (!deepEq(a[i], b[i])) return false;
      return true;
    }
    // Strings, booleans, null, undefined, "<eof>"
    return a === b;
  }
  function roundtrip(v) {
    const bytes = js_value_to_fasl(v);
    const [v2] = fasl_to_js_value(bytes);
    const ok = deepEq(v2, v);
    if (!ok && log) {
      console.error('Roundtrip mismatch:', v, '->', v2, 'bytes=', bytes);
    }
    return ok;
  }
  function test(name, v) {
    const ok = roundtrip(v);
    results.push({ name, ok });
    if (log) console.log(`${ok ? 'âœ“' : 'âœ—'} ${name}`);
    if (ok) pass++; else fail++;
  }

  // --- run tests -----------------------------------------------------------
  const results = [];
  let pass = 0, fail = 0;
  
  // Fixnums (30-bit)
  test('fixnum 0', 0);
  test('fixnum 123', 123);
  test('fixnum -5', -5);
  // Flonums
  test('flonum 1.5', 1.5);
  test('flonum -0.0', -0.0);
  test('flonum NaN', NaN);
  test('flonum +Inf', Infinity);
  test('flonum -Inf', -Infinity);
  // Booleans / null / void / eof
  test('boolean true', true);
  test('boolean false', false);
  test('null', null);
  test('void/undefined', undefined);
  test('eof sentinel', '<eof>');
  // Characters (encode via wrapper; decoder yields 1-char string)
  test('char A', { tag: 'char', cp: 'A'.codePointAt(0) });
  test('char snowman', { tag: 'char', cp: 'â˜ƒ'.codePointAt(0) });
  // Symbols
  test('symbol foo', Symbol.for('foo'));
  // Bytes (Uint8Array)
  test('bytes', new Uint8Array([0, 1, 2, 255]));
  // Pairs
  test('pair (1 . null)', { tag: 'pair', car: 1, cdr: null });
  test('list (1 2)',
       { tag: 'pair', car: 1, cdr: { tag: 'pair', car: 2, cdr: null } });
  // Vectors (arrays)
  test('vector mixed',
       [ 1, 2.5, { tag: 'pair', car: 'x', cdr: null }, true ]);
  // Strings
  test('string ascii', 'hello');
  test('string utf8', 'hÃ©llÃ¸ ðŸŒ');

  return { pass, fail, total: pass + fail, results };
}

// Uncomment to run the testsuite for fasl.
// Currently the only failing test is the one for -0.0 which after the round trip becomes 0.0.
// This is not fixabable as long as we convert integers to fixnums.

// const summary = testsuite(js_value_to_fasl, fasl_to_js_value, { log: true });
// console.log(`\nPassed: ${summary.pass}/${summary.total}`);
// if (summary.fail) {
//   console.log('Failures:');
//    for (const r of summary.results.filter(r => !r.ok)) {
//    console.log('  -', r.name);
//  }
// }

// hasDOM gives us a way of determining whether the host is a browser or Node
const hasDOM = typeof document !== 'undefined' && typeof document.createTextNode === 'function';

function from_fasl(index) {
    return fasl_to_js_value(new Uint8Array(memory.buffer), index)[0]
}

var imports = {
    'env': {
        'memory': memory
    },
    'primitives': {
      'console_log': ((x)   => console.log(x)),
      'add':         ((x,y) => x+y),
      'js_output':   ((x)   => output_string.push(x)),
      'js_print_fasl': ((start, len) => {
        const bytes = new Uint8Array(memory.buffer).slice(start, start + len);
        const [v] = fasl_to_js_value(bytes);
        console.log(v);
      })
    },
    'math': {
        'abs':    ((x)       => Math.abs(x)),
        'acos':   ((x)       => Math.acos(x)),
        'acosh':  ((x)       => Math.acosh(x)),
        'asin':   ((x)       => Math.asin(x)),
        'asinh':  ((x)       => Math.asinh(x)),
        'atan':   ((x)       => Math.atan(x)),
        'atan2':  ((y, x)    => Math.atan2(y, x)),
        'atanh':  ((x)       => Math.atanh(x)),
        'cbrt':   ((x)       => Math.cbrt(x)),
        'ceil':   ((x)       => Math.ceil(x)),
        'clz32':  ((x)       => Math.clz32(x)),
        'cos':    ((x)       => Math.cos(x)),
        'cosh':   ((x)       => Math.cosh(x)),
        'exp':    ((x)       => Math.exp(x)),
        'expm1':  ((x)       => Math.expm1(x)),
        'floor':  ((x)       => Math.floor(x)),
        'fround': ((x)       => Math.fround(x)),
        'hypot':  ((x, y)    => Math.hypot(x, y)),
        'imul':   ((a, b)    => Math.imul(a, b)),
        'log':    ((x)       => Math.log(x)),
        'log10':  ((x)       => Math.log10(x)),
        'log1p':  ((x)       => Math.log1p(x)),
        'log2':   ((x)       => Math.log2(x)),
        'max':    ((x, y)    => Math.max(x, y)),
        'min':    ((x, y)    => Math.min(x, y)),
        'pow':    ((x, y)    => Math.pow(x, y)),
        'random': (()         => Math.random()),
        'round':  ((x)       => Math.round(x)),
        'sign':   ((x)       => Math.sign(x)),
        'sin':    ((x)       => Math.sin(x)),
        'sinh':   ((x)       => Math.sinh(x)),
        'sqrt':   ((x)       => Math.sqrt(x)),
        'tan':    ((x)       => Math.tan(x)),
        'tanh':   ((x)       => Math.tanh(x)),
        'trunc':  ((x)       => Math.trunc(x))
    },
    // Document
    'document': hasDOM ? {
        'body':                     (()                               => document.body),
        'create-element':           ((local_name)                     => document.createElement(from_fasl(local_name))),
        'create-text-node':         ((fasl_start)                     => document.createTextNode(from_fasl(fasl_start))),
        'adopt-node':               ((node)                           => document.adoptNode(node)),
        'caret-range-from-point':   ((x, y)                           => document.caretRangeFromPoint(x, y)),
        'capture-events':           (()                               => document.captureEvents()),
        'clear':                    (()                               => document.clear()),
        'close':                    (()                               => document.close()),
        'create-attribute':         ((name)                           => document.createAttribute(from_fasl(name))),
        'create-attribute-ns':      ((ns, name)                      => document.createAttributeNS(from_fasl(ns), from_fasl(name))),
        'create-cdata-section':     ((data)                           => document.createCDATASection(from_fasl(data))),
        'create-comment':           ((data)                           => document.createComment(from_fasl(data))),
        'create-document-fragment': (()                               => document.createDocumentFragment()),
        'create-element-ns':        ((ns, name)                       => document.createElementNS(from_fasl(ns), from_fasl(name))),
        'create-event':             ((type)                           => document.createEvent(from_fasl(type))),
        'create-expression':        ((expr, resolver)                 => document.createExpression(from_fasl(expr), resolver)),
        'create-ns-resolver':       ((node)                           => document.createNSResolver(node)),
        'create-node-iterator':     ((root, what, filter)             => document.createNodeIterator(root, what, filter)),
        'create-processing-instruction': ((target, data)             => document.createProcessingInstruction(from_fasl(target), from_fasl(data))),
        'create-range':             (()                               => document.createRange()),
        'create-tree-walker':       ((root, what, filter)             => document.createTreeWalker(root, what, filter)),
        'element-from-point':       ((x, y)                           => document.elementFromPoint(x, y)),
        'elements-from-point':      ((x, y)                           => document.elementsFromPoint(x, y)),
        'enable-style-sheets-for-set': ((name)                        => document.enableStyleSheetsForSet(from_fasl(name))),
        'evaluate':                 ((expr, ctx, resolver, type, result) => document.evaluate(from_fasl(expr), ctx, resolver, type, result)),
        'exec-command':             ((cmd, show_ui, value)            => document.execCommand(from_fasl(cmd), !!show_ui, from_fasl(value)) ? 1 : 0),
        'exit-fullscreen':          (()                               => document.exitFullscreen()),
        'exit-picture-in-picture':  (()                               => document.exitPictureInPicture()),
        'exit-pointer-lock':        (()                               => document.exitPointerLock()),
        'get-element-by-id':        ((id)                             => document.getElementById(from_fasl(id))),
        'get-elements-by-class-name': ((class_name)                   => document.getElementsByClassName(from_fasl(class_name))),
        'get-elements-by-name':     ((name)                           => document.getElementsByName(from_fasl(name))),
        'get-elements-by-tag-name': ((name)                           => document.getElementsByTagName(from_fasl(name))),
        'get-elements-by-tag-name-ns': ((ns, name)                    => document.getElementsByTagNameNS(from_fasl(ns), from_fasl(name))),
        'get-selection':            (()                               => document.getSelection()),
        'has-focus':                (()                               => document.hasFocus() ? 1 : 0),
        'import-node':              ((node, deep)                     => document.importNode(node, !!deep)),
        'open':                     (()                               => document.open()),
        // Deprecated:
        // 'query-command-enabled':    ((cmd)                            => document.queryCommandEnabled(from_fasl(cmd)) ? 1 : 0),
        // 'query-command-indeterm':   ((cmd)                            => document.queryCommandIndeterm(from_fasl(cmd)) ? 1 : 0),
        // 'query-command-state':      ((cmd)                            => document.queryCommandState(from_fasl(cmd)) ? 1 : 0),
        // 'query-command-supported':  ((cmd)                            => document.queryCommandSupported(from_fasl(cmd)) ? 1 : 0),
        // 'query-command-value':      ((cmd)                            => document.queryCommandValue(from_fasl(cmd))),
        'query-selector':           ((sel)                            => document.querySelector(from_fasl(sel))),
        'query-selector-all':       ((sel)                            => document.querySelectorAll(from_fasl(sel))),
        'release-events':           (()                               => document.releaseEvents()),
        // Deprecated
        // 'write':                    ((text)                           => document.write(from_fasl(text))),
        // 'writeln':                  ((text)                           => document.writeln(from_fasl(text))),
    }
    : { // Node
        'body'()                     { throw new Error('DOM not available in this environment'); },
        'create-element'()           { throw new Error('DOM not available in this environment'); },
        'create-text-node'()         { throw new Error('DOM not available in this environment'); },
        'adopt-node'()               { throw new Error('DOM not available in this environment'); },
        'caret-range-from-point'()   { throw new Error('DOM not available in this environment'); },
        'capture-events'()           { throw new Error('DOM not available in this environment'); },
        'clear'()                    { throw new Error('DOM not available in this environment'); },
        'close'()                    { throw new Error('DOM not available in this environment'); },
        'create-attribute'()         { throw new Error('DOM not available in this environment'); },
        'create-attribute-ns'()      { throw new Error('DOM not available in this environment'); },
        'create-cdata-section'()     { throw new Error('DOM not available in this environment'); },
        'create-comment'()           { throw new Error('DOM not available in this environment'); },
        'create-document-fragment'() { throw new Error('DOM not available in this environment'); },
        'create-element-ns'()        { throw new Error('DOM not available in this environment'); },
        'create-event'()             { throw new Error('DOM not available in this environment'); },
        'create-expression'()        { throw new Error('DOM not available in this environment'); },
        'create-ns-resolver'()       { throw new Error('DOM not available in this environment'); },
        'create-node-iterator'()     { throw new Error('DOM not available in this environment'); },
        'create-processing-instruction'() { throw new Error('DOM not available in this environment'); },
        'create-range'()             { throw new Error('DOM not available in this environment'); },
        'create-tree-walker'()       { throw new Error('DOM not available in this environment'); },
        'element-from-point'()       { throw new Error('DOM not available in this environment'); },
        'elements-from-point'()      { throw new Error('DOM not available in this environment'); },
        'enable-style-sheets-for-set'() { throw new Error('DOM not available in this environment'); },
        'evaluate'()                 { throw new Error('DOM not available in this environment'); },
        'exec-command'()             { throw new Error('DOM not available in this environment'); },
        'exit-fullscreen'()          { throw new Error('DOM not available in this environment'); },
        'exit-picture-in-picture'()  { throw new Error('DOM not available in this environment'); },
        'exit-pointer-lock'()        { throw new Error('DOM not available in this environment'); },
        'get-element-by-id'()        { throw new Error('DOM not available in this environment'); },
        'get-elements-by-class-name'() { throw new Error('DOM not available in this environment'); },
        'get-elements-by-name'()     { throw new Error('DOM not available in this environment'); },
        'get-elements-by-tag-name'() { throw new Error('DOM not available in this environment'); },
        'get-elements-by-tag-name-ns'() { throw new Error('DOM not available in this environment'); },
        'get-selection'()            { throw new Error('DOM not available in this environment'); },
        'has-focus'()                { throw new Error('DOM not available in this environment'); },
        'import-node'()              { throw new Error('DOM not available in this environment'); },
        'open'()                     { throw new Error('DOM not available in this environment'); },
        'query-command-enabled'()    { throw new Error('DOM not available in this environment'); },
        'query-command-indeterm'()   { throw new Error('DOM not available in this environment'); },
        'query-command-state'()      { throw new Error('DOM not available in this environment'); },
        'query-command-supported'()  { throw new Error('DOM not available in this environment'); },
        'query-command-value'()      { throw new Error('DOM not available in this environment'); },
        'query-selector'()           { throw new Error('DOM not available in this environment'); },
        'query-selector-all'()       { throw new Error('DOM not available in this environment'); },
        'release-events'()           { throw new Error('DOM not available in this environment'); },
        'write'()                    { throw new Error('DOM not available in this environment'); },
        'writeln'()                  { throw new Error('DOM not available in this environment'); },
    },
    // Element
    'element': hasDOM ? {
        'append-child!':           ((parent, child)          => parent.appendChild(child)),
        'set-attribute!':          ((elem, name, value)      => elem.setAttribute(from_fasl(name), from_fasl(value))),
        'after!':                  ((elem, node)            => elem.after(node)),
        'animate':                 ((elem, keyframes, opts) => elem.animate(keyframes, opts)),
        'append!':                 ((elem, node)            => elem.append(node)),
        'attach-shadow!':          ((elem, init)            => elem.attachShadow(init)),
        'before!':                 ((elem, node)            => elem.before(node)),
        'closest':                 ((elem, sel)             => elem.closest(from_fasl(sel))),
        'computed-style-map':      ((elem)                  => elem.computedStyleMap()),
        'get-animations':          ((elem)                  => elem.getAnimations()),
        'get-attribute':           ((elem, name)            => elem.getAttribute(from_fasl(name))),
        'get-attribute-ns':        ((elem, ns, name)       => elem.getAttributeNS(from_fasl(ns), from_fasl(name))),
        'get-attribute-names':     ((elem)                  => elem.getAttributeNames()),
        'get-attribute-node':      ((elem, name)            => elem.getAttributeNode(from_fasl(name))),
        'get-attribute-node-ns':   ((elem, ns, name)       => elem.getAttributeNodeNS(from_fasl(ns), from_fasl(name))),
        'get-bounding-client-rect':((elem)                  => elem.getBoundingClientRect()),
        'get-client-rects':        ((elem)                  => elem.getClientRects()),
        'get-elements-by-class-name': ((elem, class_name)   => elem.getElementsByClassName(from_fasl(class_name))),
        'get-elements-by-tag-name':  ((elem, name)          => elem.getElementsByTagName(from_fasl(name))),
        'get-elements-by-tag-name-ns': ((elem, ns, name)    => elem.getElementsByTagNameNS(from_fasl(ns), from_fasl(name))),
        'has-attribute':           ((elem, name)            => elem.hasAttribute(from_fasl(name)) ? 1 : 0),
        'has-attribute-ns':        ((elem, ns, name)       => elem.hasAttributeNS(from_fasl(ns), from_fasl(name)) ? 1 : 0),
        'has-attributes':          ((elem)                  => elem.hasAttributes() ? 1 : 0),
        'has-pointer-capture':     ((elem, id)             => elem.hasPointerCapture(id) ? 1 : 0),
        'insert-adjacent-element!':((elem, pos, newElem)   => elem.insertAdjacentElement(from_fasl(pos), newElem)),
        'insert-adjacent-html!':   ((elem, pos, data)      => elem.insertAdjacentHTML(from_fasl(pos), from_fasl(data))),
        'insert-adjacent-text!':   ((elem, pos, data)      => elem.insertAdjacentText(from_fasl(pos), from_fasl(data))),
        'matches':                 ((elem, sel)            => elem.matches(from_fasl(sel)) ? 1 : 0),
        'prepend!':                ((elem, node)           => elem.prepend(node)),
        'query-selector':          ((elem, sel)            => elem.querySelector(from_fasl(sel))),
        'query-selector-all':      ((elem, sel)            => elem.querySelectorAll(from_fasl(sel))),
        'release-pointer-capture!':((elem, id)             => elem.releasePointerCapture(id)),
        'remove!':                 ((elem)                  => elem.remove()),
        'remove-attribute!':       ((elem, name)            => elem.removeAttribute(from_fasl(name))),
        'remove-attribute-ns!':    ((elem, ns, name)       => elem.removeAttributeNS(from_fasl(ns), from_fasl(name))),
        'remove-attribute-node!':  ((elem, attr)           => elem.removeAttributeNode(attr)),
        'replace-children!':       ((elem, node)           => elem.replaceChildren(node)),
        'replace-with!':           ((elem, node)           => elem.replaceWith(node)),
        'request-fullscreen':      ((elem)                  => elem.requestFullscreen()),
        'request-pointer-lock':    ((elem)                  => elem.requestPointerLock()),
        'scroll!':                 ((elem, x, y)           => elem.scroll(x, y)),
        'scroll-by!':              ((elem, x, y)           => elem.scrollBy(x, y)),
        'scroll-into-view!':       ((elem, b)              => elem.scrollIntoView(!!b)),
        'scroll-to!':              ((elem, x, y)           => elem.scrollTo(x, y)),
        'set-attribute-ns!':       ((elem, ns, name, value)=> elem.setAttributeNS(from_fasl(ns), from_fasl(name), from_fasl(value))),
        'set-attribute-node!':     ((elem, attr)           => elem.setAttributeNode(attr)),
        'set-attribute-node-ns!':  ((elem, attr)           => elem.setAttributeNodeNS(attr)),
        'set-pointer-capture!':    ((elem, id)             => elem.setPointerCapture(id)),
        'toggle-attribute!':       ((elem, name, force)    => elem.toggleAttribute(from_fasl(name), !!force) ? 1 : 0),
    } : {
        'append-child!'()             { throw new Error('DOM not available in this environment'); },
        'set-attribute!'()            { throw new Error('DOM not available in this environment'); },
        'after!'()                    { throw new Error('DOM not available in this environment'); },
        'animate'()                   { throw new Error('DOM not available in this environment'); },
        'append!'()                   { throw new Error('DOM not available in this environment'); },
        'attach-shadow!'()            { throw new Error('DOM not available in this environment'); },
        'before!'()                   { throw new Error('DOM not available in this environment'); },
        'closest'()                   { throw new Error('DOM not available in this environment'); },
        'computed-style-map'()        { throw new Error('DOM not available in this environment'); },
        'get-animations'()            { throw new Error('DOM not available in this environment'); },
        'get-attribute'()             { throw new Error('DOM not available in this environment'); },
        'get-attribute-ns'()          { throw new Error('DOM not available in this environment'); },
        'get-attribute-names'()       { throw new Error('DOM not available in this environment'); },
        'get-attribute-node'()        { throw new Error('DOM not available in this environment'); },
        'get-attribute-node-ns'()     { throw new Error('DOM not available in this environment'); },
        'get-bounding-client-rect'()  { throw new Error('DOM not available in this environment'); },
        'get-client-rects'()          { throw new Error('DOM not available in this environment'); },
        'get-elements-by-class-name'(){ throw new Error('DOM not available in this environment'); },
        'get-elements-by-tag-name'()  { throw new Error('DOM not available in this environment'); },
        'get-elements-by-tag-name-ns'(){ throw new Error('DOM not available in this environment'); },
        'has-attribute'()             { throw new Error('DOM not available in this environment'); },
        'has-attribute-ns'()          { throw new Error('DOM not available in this environment'); },
        'has-attributes'()            { throw new Error('DOM not available in this environment'); },
        'has-pointer-capture'()       { throw new Error('DOM not available in this environment'); },
        'insert-adjacent-element!'()  { throw new Error('DOM not available in this environment'); },
        'insert-adjacent-html!'()     { throw new Error('DOM not available in this environment'); },
        'insert-adjacent-text!'()     { throw new Error('DOM not available in this environment'); },
        'matches'()                   { throw new Error('DOM not available in this environment'); },
        'prepend!'()                  { throw new Error('DOM not available in this environment'); },
        'query-selector'()            { throw new Error('DOM not available in this environment'); },
        'query-selector-all'()        { throw new Error('DOM not available in this environment'); },
        'release-pointer-capture!'()  { throw new Error('DOM not available in this environment'); },
        'remove!'()                   { throw new Error('DOM not available in this environment'); },
        'remove-attribute!'()         { throw new Error('DOM not available in this environment'); },
        'remove-attribute-ns!'()      { throw new Error('DOM not available in this environment'); },
        'remove-attribute-node!'()    { throw new Error('DOM not available in this environment'); },
        'replace-children!'()         { throw new Error('DOM not available in this environment'); },
        'replace-with!'()             { throw new Error('DOM not available in this environment'); },
        'request-fullscreen'()        { throw new Error('DOM not available in this environment'); },
        'request-pointer-lock'()      { throw new Error('DOM not available in this environment'); },
        'scroll!'()                   { throw new Error('DOM not available in this environment'); },
        'scroll-by!'()                { throw new Error('DOM not available in this environment'); },
        'scroll-into-view!'()         { throw new Error('DOM not available in this environment'); },
        'scroll-to!'()                { throw new Error('DOM not available in this environment'); },
        'set-attribute-ns!'()         { throw new Error('DOM not available in this environment'); },
        'set-attribute-node!'()       { throw new Error('DOM not available in this environment'); },
        'set-attribute-node-ns!'()    { throw new Error('DOM not available in this environment'); },
        'set-pointer-capture!'()      { throw new Error('DOM not available in this environment'); },
        'toggle-attribute!'()         { throw new Error('DOM not available in this environment'); },
    }
};

const wasmModule
      = await WebAssembly
      .instantiate(wasmBuffer, imports)
      .then(results  => { const { entry, get_bytes, copy_bytes_to_memory } = results.instance.exports;
                          var result = entry();
                          // console.log( "Output:")
                          // console.log( output_string );
                          // console.log( "Result:")
                          // console.log( result );

                          // console.log( "Result bytes:" )
                          const bytes  = new Uint8Array(memory.buffer, 0, result);
                          console.log(new TextDecoder().decode(bytes));
                        });





})

(define (node-runtime out.wasm)
  @~a{// Generated by "assembler.rkt".
      import fs from 'node:fs/promises';
      
      const wasmBuffer = await fs.readFile("@|out.wasm|");
      
      @(runtime-common)
})

(define (browser-runtime out.wasm)
  @~a{<!DOCTYPE html>
     <html>
     <head><meta charset="UTF-8"></head>
     <body>
       <script type="module">
       // Generated by "assembler.rkt".
       const wasmBuffer = await fetch("@|out.wasm|").then(r => r.arrayBuffer());
       @(runtime-common)
       </script>
     </body>
     </html>
})

(define (runtime #:out  [out.wasm "out.wasm"]
                 #:host [host 'node])
  (case host
    [(node)    (node-runtime    out.wasm)]
    [(browser) (browser-runtime out.wasm)]
    [else      (error 'runtime (format "unknown host ~a" host))]))


;;;
;;; Driver
;;;

;; wat2wasm [options] filename
;;   read a file in the wasm text format, check it for errors, and
;;   convert it to the wasm binary format.
;; 
;;   examples:
;;     # parse test.wat and write to .wasm binary file with the same name
;;     $ wat2wasm test.wat
;;    
;;     # parse test.wat and write to binary file test.wasm
;;     $ wat2wasm test.wat -o test.wasm
;;    
;;     # parse spec-test.wast, and write verbose output to stdout (including
;;     # the meaning of every byte)
;;     $ wat2wasm spec-test.wast -v

(define (wat-pretty-print-table)
  (pretty-print-extend-style-table
   #f
   '(func   module block)
   '(lambda when   begin)))

(define (wat-pretty-write x)
  (parameterize ([current-print write]
                 [pretty-print-current-style-table (wat-pretty-print-table)])
    (pretty-write x)))

(define (print-wat x)
  (wat-pretty-write x))

(define (wat->wasm x #:wat [out.wat "out.wat"] #:wasm [out.wasm "out.wasm"])
  ; The argument x is an s-expresssion.
  ; It represents a WebAssembly module in textual format.

  ; 1. Write the module x to a wat file
  (with-output-to-file out.wat
    (Î» ()
      (wat-pretty-write x))
    #:exists 'replace)
  ; 2. Compile the wat file into a wasm file.
  (define success? #t)
  (define compilation-output
    (with-output-to-string
      (Î» ()
        (set! success?
              (system
               (format (~a assembler-path "/" "wasm-tools parse ~a -o ~a ")
                       out.wat out.wasm))))))
  ; 3. If there were any errors, display the error messages
  (unless success?
    (displayln "* Compilation Error *")
    (displayln compilation-output))
  ; 4. Return success?
  success?)


(define (run [x #f] 
             #:wat        [out.wat    "out.wat"]
             #:wasm       [out.wasm   "out.wasm"]
             #:runtime.js [runtime.js "runtime.js"])
  ; (print-wat x)
  ; 1. If needed compile textual format to wasm file.  
  (define okay?
    (if x
        (wat->wasm x #:wat out.wat #:wasm out.wasm)
        #t))
  (when okay?
    ; 2. Write runtime
    (with-output-to-file runtime.js
      (Î» () (displayln (runtime #:out out.wasm)))
      #:exists 'replace)
    ; 3. Invoke runtime.js using Node
    (define success? #t)
    (define output
      (with-output-to-string
        (Î» ()
          (set! success?
                (system (format "/usr/local/bin/node --expose-gc ~a"
                                runtime.js))))))
    ; 3. If there were any errors, display the error messages
    (displayln output)))
