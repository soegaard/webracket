// Generated by "assembler.rkt".
import fs from 'node:fs/promises';

const wasmBuffer = await fs.readFile("tmp-char-lt-direct.wasm");

var memory = new WebAssembly.Memory({initial:1024});

var output_string = [];
var externals = [];
var callback_export;

function read_u32(arr, i) {
  return ((arr[i] << 24) | (arr[i + 1] << 16) |
          (arr[i + 2] << 8)  | arr[i + 3]) >>> 0;
}

function fasl_to_js_value(arr, i = 0) {

  const tag = arr[i++];

  function u32() {
    const v = read_u32(arr, i);
    i += 4;
    return v;
  }

  function read_bytes() {
    const len = u32();
    const b = arr.slice(i, i + len);
    i += len;
    return b;
  }

  function read_string() {
    const b = read_bytes();
    return new TextDecoder().decode(b);
  }

  switch(tag) {
    case 0: {
      const raw = u32();
      // Sign-extend the 30-bit payload so negative fixnums decode correctly.
      return [(raw << 2) >> 2, i];
    }
    case 1:
      return [String.fromCodePoint(u32()), i];
    case 2:
      return [Symbol.for(read_string()), i];
    case 3:
      return [read_string(), i];
    case 4:
      return [read_bytes(), i];
    case 5:
      return [arr[i++] !== 0, i];
    case 6:
      return [null, i];
    case 7: {
      let car, cdr;
      [car, i] = fasl_to_js_value(arr, i);
      [cdr, i] = fasl_to_js_value(arr, i);
      return [{tag:'pair', car, cdr}, i];
    }
    case 8: {
      const n = u32();
      const vec = new Array(n);
      for(let j = 0; j < n; j++) {
        [vec[j], i] = fasl_to_js_value(arr, i);
      }
      return [vec, i];
    }
    case 9: {
      const hi = u32();
      const lo = u32();
      const dv = new DataView(new ArrayBuffer(8));
      dv.setUint32(0, hi);
      dv.setUint32(4, lo);
      return [dv.getFloat64(0), i];
    }
    case 10:
      return [undefined, i];
    case 11:
      return ['<eof>', i];
    case 12: {
      const idx = u32();
      return [externals[idx], i];
    }
    default:
      throw new Error('bad FASL tag ' + tag);
  }
}


function js_value_to_fasl(v) {
  const out = [];
  const enc = new TextEncoder();

  // --- low-level writers (big-endian) ---
  function writeByte(b) {
    out.push(b & 0xFF);
  }
  function writeU32(u) {
    out.push((u >>> 24) & 0xFF, (u >>> 16) & 0xFF, (u >>> 8) & 0xFF, u & 0xFF);
  }
  function writeBytes(u8) {
    writeU32(u8.length >>> 0);
    for (let i = 0; i < u8.length; i++) out.push(u8[i] & 0xFF);
  }
  function writeString(s) {
    const u8 = enc.encode(s);
    writeBytes(u8);
  }
  function writeF64(x) {
    const dv = new DataView(new ArrayBuffer(8));
    // Big-endian
    dv.setFloat64(0, x, false);
    const hi = dv.getUint32(0, false);
    const lo = dv.getUint32(4, false);
    writeU32(hi);
    writeU32(lo);
  }

  // --- tagged writers ---
  function writeFixnum(n) {
    // 30-bit signed two's complement payload; range: [-2^29, 2^29-1]
    if (!Number.isInteger(n) || n < -(1 << 29) || n > ((1 << 29) - 1)) {
      throw new RangeError("fixnum out of 30-bit range");
    }
    writeByte(0);
    const raw30 = n & 0x3FFFFFFF; // 30-bit two's complement payload
    writeU32(raw30 >>> 0);
  }
  function writeFlonum(x) {
    writeByte(9);
    writeF64(x);
  }
  function writeCharacter(cp) {
    // cp = Unicode scalar value (number)
    writeByte(1);
    writeU32(cp >>> 0);
  }
  function writeSymbol(name) {
    writeByte(2);
    writeString(name);
  }
  function writeStringVal(s) {
    writeByte(3);
    writeString(s);
  }
  function writeBytesVal(u8) {
    writeByte(4);
    writeBytes(u8);
  }
  function writeBoolean(b) {
    writeByte(5);
    writeByte(b ? 1 : 0);
  }
  function writeNull() {
    writeByte(6);
  }
  function writeVoid() {
    writeByte(10);
  }
  function writeEof() {
    writeByte(11);
  }
  function writePair(car, cdr) {
    writeByte(7);
    writeAny(car);
    writeAny(cdr);
  }
  function writeVector(arr) {
    writeByte(8);
    writeU32(arr.length >>> 0);
    for (let i = 0; i < arr.length; i++) writeAny(arr[i]);
  }

  // --- main dispatcher (mirrors fasl_to_js_value mapping) ---
  function writeAny(x) {
    // Fast paths by JS type
    if (typeof x === "number") {
      if (Number.isInteger(x) && x >= -(1 << 29) && x <= ((1 << 29) - 1)) {
        writeFixnum(x);
      } else {
        writeFlonum(x);
      }
      return;
    }
    // Number object
    if ( (typeof x === "object") && (x instanceof Number) ) {
      writeFlonum(x.valueOf());
      return;
    }
    if (typeof x === "boolean") {
      writeBoolean(x);
      return;
    }
    if (x === null) {
      writeNull();
      return;
    }
    if (x === undefined) {
      writeVoid();
      return;
    }
    // EoF sentinel (match your decoder's '<eof>' convention)
    if (x === "<eof>" || (x && x.tag === "eof")) {
      writeEof();
      return;
    }
    // Character (two accepted forms)
    //   { tag: 'char', cp: <codepoint> }  or  { tag: 'char', ch: 'A' }
    if (x && x.tag === "char") {
      const cp = typeof x.cp === "number" ? x.cp
               : (typeof x.ch === "string" ? x.ch.codePointAt(0) : undefined);
      if (cp === undefined) throw new TypeError("bad char object");
      writeCharacter(cp >>> 0);
      return;
    }
    // Pair (your decoder uses {tag:'pair', car, cdr})
    if (x && x.tag === "pair") {
      writePair(x.car, x.cdr);
      return;
    }
    // Bytes: prefer Uint8Array
    if (x instanceof Uint8Array) {
      writeBytesVal(x);
      return;
    }
    // TODO
    //   - an empty array -- is than an vector or a byte string?
    //   - no way to produce a vector with small integers
    //   - do something else to return byte strings.

    // // Accept raw byte arrays too
    // if (Array.isArray(x) && x.every(n => Number.isInteger(n) && n >= 0 && n <= 255)) {
    //   console.log("writeAny - array with bytes => bytes")
    //   writeBytesVal(Uint8Array.from(x));
    //   return;
    // }
    // Vector: plain JS Array (distinct from bytes above)
    if (Array.isArray(x)) {
      writeVector(x);
      return;
    }
    // Symbol
    if (typeof x === "symbol") {
      const name = Symbol.keyFor(x) ?? x.description ?? "";
      writeSymbol(name);
      return;
    }
    // String
    if (typeof x === "string") {
      writeStringVal(x);
      return;
    }
    // Fallback: treat value as external reference
    const idx = externals.push(x) - 1;
    writeByte(12);
    writeU32(idx >>> 0);
    return;
  }
  writeAny(v);
  return Uint8Array.from(out);
}

function is_pair(v) {
    return v && typeof v === 'object' && v.tag === 'pair'
}

function is_alist(v) {
    let list = v
    while (list !== null) {
        if (!is_pair(list)) return false
        if (!is_pair(list.car)) return false
        list = list.cdr
    }
    return true
}

function alist_to_vector_pairs(alist) {
    const result = []
    let   list   = alist
    while (list !== null) {
        const entry = list.car
        result.push([entry.car, entry.cdr])
        list = list.cdr
    }
    return result
}


function testsuite(js_value_to_fasl, fasl_to_js_value, { log = true } = {}) {
  // --- helpers -------------------------------------------------------------
  function charToString(v) {
    if (typeof v === 'string' && v.length === 1) return v;
    if (v && typeof v === 'object' && v.tag === 'char' && typeof v.cp === 'number') {
      try { return String.fromCodePoint(v.cp); } catch { /* fall through */ }
    }
    return null;
  }

  function deepEq(a, b) {
    // Treat "char-wrappers" and 1-char strings as equal
    const ac = charToString(a), bc = charToString(b);
    if (ac !== null || bc !== null) return ac === bc;
    // numbers (handle NaN, -0)
    if (typeof a === 'number' || typeof b === 'number') return Object.is(a, b);
    // Uint8Array (bytes)
    if (a instanceof Uint8Array && b instanceof Uint8Array) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
      return true;
    }
    // Symbols (use registry key or description)
    if (typeof a === 'symbol' && typeof b === 'symbol') {
      const ka = Symbol.keyFor(a) ?? a.description ?? '';
      const kb = Symbol.keyFor(b) ?? b.description ?? '';
      return ka === kb;
    }
    // Pairs
    if (a && b && a.tag === 'pair' && b.tag === 'pair') {
      return deepEq(a.car, b.car) && deepEq(a.cdr, b.cdr);
    }
    // Arrays (vectors)
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) if (!deepEq(a[i], b[i])) return false;
      return true;
    }
    // Strings, booleans, null, undefined, "<eof>"
    return a === b;
  }
  function roundtrip(v) {
    const bytes = js_value_to_fasl(v);
    const [v2] = fasl_to_js_value(bytes);
    const ok = deepEq(v2, v);
    if (!ok && log) {
      console.error('Roundtrip mismatch:', v, '->', v2, 'bytes=', bytes);
    }
    return ok;
  }
  function test(name, v) {
    const ok = roundtrip(v);
    results.push({ name, ok });
    if (log) console.log(`${ok ? 'âœ“' : 'âœ—'} ${name}`);
    if (ok) pass++; else fail++;
  }

  // --- run tests -----------------------------------------------------------
  const results = [];
  let pass = 0, fail = 0;

  // Fixnums (30-bit)
  test('fixnum 0', 0);
  test('fixnum 123', 123);
  test('fixnum -5', -5);
  // Flonums
  test('flonum 1.5', 1.5);
  test('flonum -0.0', -0.0);
  test('flonum NaN', NaN);
  test('flonum +Inf', Infinity);
  test('flonum -Inf', -Infinity);
  // Booleans / null / void / eof
  test('boolean true', true);
  test('boolean false', false);
  test('null', null);
  test('void/undefined', undefined);
  test('eof sentinel', '<eof>');
  // Characters (encode via wrapper; decoder yields 1-char string)
  test('char A', { tag: 'char', cp: 'A'.codePointAt(0) });
  test('char snowman', { tag: 'char', cp: 'â˜ƒ'.codePointAt(0) });
  // Symbols
  test('symbol foo', Symbol.for('foo'));
  // Bytes (Uint8Array)
  test('bytes', new Uint8Array([0, 1, 2, 255]));
  // Pairs
  test('pair (1 . null)', { tag: 'pair', car: 1, cdr: null });
  test('list (1 2)',
       { tag: 'pair', car: 1, cdr: { tag: 'pair', car: 2, cdr: null } });
  // Vectors (arrays)
  test('vector mixed',
       [ 1, 2.5, { tag: 'pair', car: 'x', cdr: null }, true ]);
  // Strings
  test('string ascii', 'hello');
  test('string utf8', 'hÃ©llÃ¸ ðŸŒ');

  return { pass, fail, total: pass + fail, results };
}

// Uncomment to run the testsuite for fasl.
// Currently the only failing test is the one for -0.0 which after the round trip becomes 0.0.
// This is not fixabable as long as we convert integers to fixnums.

// const summary = testsuite(js_value_to_fasl, fasl_to_js_value, { log: true });
// console.log(`\nPassed: ${summary.pass}/${summary.total}`);
// if (summary.fail) {
//   console.log('Failures:');
//    for (const r of summary.results.filter(r => !r.ok)) {
//    console.log('  -', r.name);
//  }
// }

// hasDOM gives us a way of determining whether the host is a browser or Node
const hasDOM = typeof document !== 'undefined' && typeof document.createTextNode === 'function';

// hasXterm indicates whether XTermJS is available
// const hasXterm = typeof Terminal !== 'undefined';
const hasXterm = true;

function from_fasl(index) {
    return fasl_to_js_value(new Uint8Array(memory.buffer), index)[0]
}

function from_fasl2(index) {
    const arr = new Uint8Array(memory.buffer)
    const [v1, i1] = fasl_to_js_value(arr, index)
    const [v2] = fasl_to_js_value(arr, i1)
    return [v1, v2]
}

function from_fasl3(index) {
    const arr = new Uint8Array(memory.buffer)
    const [v1, i1] = fasl_to_js_value(arr, index)
    const [v2, i2] = fasl_to_js_value(arr, i1)
    const [v3] = fasl_to_js_value(arr, i2)
    return [v1, v2, v3]
}



// The procedure to call has been given an `id` by `callback-register` in the wasm runtime.
// To call it, fasl encode an array of arguments and use `callback`.
export function make_callback(id) {
    return (...args) => {
        const fasl = js_value_to_fasl(Array.from(args));
        new Uint8Array(memory.buffer).set(fasl, 0);
        const len = callback_export(id, 0);
        return fasl_to_js_value(new Uint8Array(memory.buffer, 0, len))[0];
    };
}

// For data types that can fit into an i32/u32/f64 it is more effecient
// pass them as an i32/u32/f64 than it is to use fasl.

// For booleans we can convert back and forth using these helpers.

function i32_to_boolean(x) {
  return x !== 0;
}

function boolean_to_i32(x) {
  return x ? 1 : 0;
}

function to_fasl(v) {
  const fasl = js_value_to_fasl(v);
  new Uint8Array(memory.buffer).set(fasl, 0);
  return 0
}

function to_string(v) {
  return to_fasl(v);
}

var imports = {
    'env': {
        'memory': memory
    },
    'primitives': {
      'console_log': ((x)   => console.log(x)),
      'add':         ((x,y) => x+y),
      'make_callback': make_callback,
      'js_output':   ((x)   => output_string.push(x)),
      'js_print_fasl': ((start, len) => {
        const bytes = new Uint8Array(memory.buffer).slice(start, start + len);
        const [v] = fasl_to_js_value(bytes);
        console.log(v);
      }),
      'register_external': (obj => { externals.push(obj); return externals.length - 1; }),
      'lookup_external':   (idx => externals[idx]),
      'external_number_to_f64': (obj =>
        (typeof obj === 'number'
         ? obj
         : (obj instanceof Number ? obj.valueOf() : NaN))),
      'external_string_to_string': (obj =>
        (typeof obj === 'string'
         ? to_string(obj)
         : (obj instanceof String ? to_string(obj.valueOf())
                                   : to_string(String(obj))))),
      'char_upcase': ((cp) => {
        const s = String.fromCodePoint(cp).toUpperCase();
        const arr = Array.from(s);
        return (arr.length === 1) ? arr[0].codePointAt(0) : cp;
      }),
      'char_downcase': ((cp) => {
        const s = String.fromCodePoint(cp).toLowerCase();
        const arr = Array.from(s);
        return (arr.length === 1) ? arr[0].codePointAt(0) : cp;
      }),
      'char_titlecase': ((cp) => {
        const lower = String.fromCodePoint(cp).toLocaleLowerCase();
        const title = lower.charAt(0).toLocaleUpperCase() + lower.slice(1);
        const arr = Array.from(title);
        return (arr.length === 1) ? arr[0].codePointAt(0) : cp;
      }),
      'char_foldcase': ((cp) => {
        // Note: JavaScript doesn't have builtin unicode aware fold case (year 2025).
        //       For now, we will just use lowercase.
        const s = String.fromCodePoint(cp).toLowerCase();
        const arr = Array.from(s);
        return (arr.length === 1) ? arr[0].codePointAt(0) : cp;
      }),
      // NOTE: This classification covers only a subset of Unicode's
      // grapheme break property table and should be expanded.
      'char_grapheme_break_property': (cp => {
        if (cp === 0x000D) return 1; // CR
        if (cp === 0x000A) return 2; // LF
        if ((cp >= 0x0000 && cp <= 0x001F && cp !== 0x000A && cp !== 0x000D) ||
            (cp >= 0x007F && cp <= 0x009F)) return 3; // Control
        if ((cp >= 0x0300 && cp <= 0x036F) ||
            (cp >= 0x1AB0 && cp <= 0x1AFF) ||
            (cp >= 0x1DC0 && cp <= 0x1DFF) ||
            (cp >= 0x20D0 && cp <= 0x20FF) ||
            (cp >= 0xFE20 && cp <= 0xFE2F) ||
            cp === 0x200C) return 4; // Extend
        if (cp === 0x200D) return 5; // ZWJ
        if (cp >= 0x1F1E6 && cp <= 0x1F1FF) return 6; // Regional Indicator
        if ((cp >= 0x0600 && cp <= 0x0605) || cp === 0x06DD || cp === 0x070F || cp === 0x08E2)
          return 7; // Prepend (subset)
        if (cp === 0x0903 || cp === 0x093B ||
            (cp >= 0x093E && cp <= 0x0940) ||
            (cp >= 0x0949 && cp <= 0x094C) ||
            (cp >= 0x094E && cp <= 0x094F) ||
            (cp >= 0x0982 && cp <= 0x0983))
          return 8; // SpacingMark (subset)
        if ((cp >= 0x1100 && cp <= 0x115F) || (cp >= 0xA960 && cp <= 0xA97C)) return 9; // L
        if ((cp >= 0x1160 && cp <= 0x11A7) || (cp >= 0xD7B0 && cp <= 0xD7C6)) return 10; // V
        if ((cp >= 0x11A8 && cp <= 0x11FF) || (cp >= 0xD7CB && cp <= 0xD7FB)) return 11; // T
        if (cp >= 0xAC00 && cp <= 0xD7A3) {
          const sIndex = cp - 0xAC00;
          return (sIndex % 28 === 0) ? 12 : 13; // LV or LVT
        }
        return 0; // Other
      }),
      'char_general_category': ((cp) => {
        const s = String.fromCodePoint(cp);
        if (/\p{Lu}/u.test(s)) return 0;
        if (/\p{Ll}/u.test(s)) return 1;
        if (/\p{Lt}/u.test(s)) return 2;
        if (/\p{Lm}/u.test(s)) return 3;
        if (/\p{Lo}/u.test(s)) return 4;
        if (/\p{Mn}/u.test(s)) return 5;
        if (/\p{Mc}/u.test(s)) return 6;
        if (/\p{Me}/u.test(s)) return 7;
        if (/\p{Nd}/u.test(s)) return 8;
        if (/\p{Nl}/u.test(s)) return 9;
        if (/\p{No}/u.test(s)) return 10;
        if (/\p{Ps}/u.test(s)) return 11;
        if (/\p{Pe}/u.test(s)) return 12;
        if (/\p{Pi}/u.test(s)) return 13;
        if (/\p{Pf}/u.test(s)) return 14;
        if (/\p{Pd}/u.test(s)) return 15;
        if (/\p{Pc}/u.test(s)) return 16;
        if (/\p{Po}/u.test(s)) return 17;
        if (/\p{Sc}/u.test(s)) return 18;
        if (/\p{Sm}/u.test(s)) return 19;
        if (/\p{Sk}/u.test(s)) return 20;
        if (/\p{So}/u.test(s)) return 21;
        if (/\p{Zs}/u.test(s)) return 22;
        if (/\p{Zp}/u.test(s)) return 23;
        if (/\p{Zl}/u.test(s)) return 24;
        if (/\p{Cc}/u.test(s)) return 25;
        if (/\p{Cf}/u.test(s)) return 26;
        if (/\p{Cs}/u.test(s)) return 27;
        if (/\p{Co}/u.test(s)) return 28;
        return 29; // Cn
      }),
      'char_alphabetic': ((cp) =>
        Number(/\p{Alphabetic}/u.test(String.fromCodePoint(cp)))),
      'char_lower_case': ((cp) =>
        Number(/\p{Lowercase}/u.test(String.fromCodePoint(cp)))),
      'char_upper_case': ((cp) =>
        Number(/\p{Uppercase}/u.test(String.fromCodePoint(cp)))),
      'char_title_case': ((cp) =>
        Number(/\p{gc=Lt}/u.test(String.fromCodePoint(cp)))),
      'char_numeric': ((cp) =>
        Number(/\p{Number}/u.test(String.fromCodePoint(cp)))),
      'char_symbolic': ((cp) =>
        Number(/\p{gc=Sm}|\p{gc=Sc}|\p{gc=Sk}|\p{gc=So}/u.test(String.fromCodePoint(cp)))),
      'char_punctuation': ((cp) =>
        Number(/\p{gc=Pc}|\p{gc=Pd}|\p{gc=Ps}|\p{gc=Pe}|\p{gc=Pi}|\p{gc=Pf}|\p{gc=Po}/u.test(String.fromCodePoint(cp)))),
      'char_graphic': ((cp) =>
        Number(/\p{gc=Ll}|\p{gc=Lm}|\p{gc=Lo}|\p{gc=Lt}|\p{gc=Lu}|\p{gc=Nd}|\p{gc=Nl}|\p{gc=No}|\p{gc=Mn}|\p{gc=Mc}|\p{gc=Me}|\p{Alphabetic}|\p{Number}|\p{gc=Sm}|\p{gc=Sc}|\p{gc=Sk}|\p{gc=So}|\p{gc=Pc}|\p{gc=Pd}|\p{gc=Ps}|\p{gc=Pe}|\p{gc=Pi}|\p{gc=Pf}|\p{gc=Po}/u.test(String.fromCodePoint(cp)))),
      'char_extended_pictographic': ((cp) =>
        Number(/\p{Extended_Pictographic}/u.test(String.fromCodePoint(cp))))
    },
    'standard': {
      'global-this':               (() => globalThis),
      'infinity':                  (() => Infinity),
      'nan':                       (() => NaN),
      'undefined':                 (() => undefined),
      'eval':                      ((code) => eval(from_fasl(code))),
      'is-finite':                 ((x) => isFinite(x) ? 1 : 0),
      'is-nan':                    ((x) => isNaN(x) ? 1 : 0),
      'parse-float':               ((s) => parseFloat(from_fasl(s))),
      'parse-int':                 ((s) => parseInt(from_fasl(s))),
      'decode-uri':                ((s) => to_string( decodeURI(from_fasl(s)))),
      'decode-uri-component':      ((s) => to_string( decodeURIComponent(from_fasl(s)))),
      'encode-uri':                ((s) => to_string( encodeURI(from_fasl(s)))),
      'encode-uri-component':      ((s) => to_string( encodeURIComponent(from_fasl(s)))),
      'var':                       ((name) => globalThis[from_fasl(name)]),
      'ref/value':                 ((obj, key) => to_fasl(obj[from_fasl(key)])),
      'ref/extern':                ((obj, key) => obj[from_fasl(key)]),
      'set!':                      ((obj, key, val) => ( obj[from_fasl(key)] = from_fasl(val) )),
      'index':                     ((obj, prop) => to_fasl( obj[ from_fasl(prop) ] ) ),
      'assign':                    ((name, val) => (globalThis[from_fasl(name)] = from_fasl(val))),
      'new':                       ((ctor, args) => new ctor(...(from_fasl(args) || []))),
      'send':                      ((obj, name, args) => obj[from_fasl(name)](...(from_fasl(args) || [])) ),
      'send/flonum':               ((obj, name, args) => {
                                    const x = obj[from_fasl(name)](...(from_fasl(args) || []))
                                    return (( (typeof x === "object") && (x instanceof Number) ) ? x.valueOf() : x)
                                    }),
      'throw':                     (exn => { throw from_fasl(exn); }),
      'null':                      (() => null),
      'this':                      (function () { return this; }),
      'object':                    (fields => {
                                     const decoded = from_fasl(fields);
                                     const entries = is_alist(decoded)
                                       ? alist_to_vector_pairs(decoded)
                                       : (decoded || []);
                                     const o = {};
                                     for (const [k, v] of entries) {
                                       o[k] = v;
                                     }
                                     return o;
                                   }),
      'array':                     (args => { const as = from_fasl(args);
                                              return to_fasl( [...( as ? as : [])])
                                    }),
      'array/extern':               (args => { const as = from_fasl(args);
                                              return [...( as ? as : [])]
                                    }),
      'typeof':                    ((obj) => to_string(typeof obj)),
      'value->string':             ((obj) => to_string(String(obj))),
      'instanceof':                ((obj, type) => (obj instanceof type) ? 1 : 0),
      'operator':                  ((op, operands) => {
                                     const o = from_fasl(op);
                                     const args = from_fasl(operands) || [];
                                     if (args.length === 1) {
                                       return Function('a', `return ${o} a;`)(args[0]);
                                     } else if (args.length === 2) {
                                       return Function('a','b', `return a ${o} b;`)(args[0], args[1]);
                                     } else {
                                       return Function('args', `return args.reduce((a,b)=>a ${o} b);`)(args);
                                     }
                                       }),
      // The following returns the prototype object
      // Some are guarded by a test. These might not be available everywhere.
      'Object':                    (() => Object),
      'Function':                  (() => Function),
      'Boolean':                   (() => Boolean),
      'Symbol':                    (() => Symbol),
      'Error':                     (() => Error),
      'AggregateError':            (() => (typeof AggregateError === 'undefined' ? undefined : AggregateError)),
      'EvalError':                 (() => EvalError),
      'RangeError':                (() => RangeError),
      'ReferenceError':            (() => ReferenceError),
      'SuppressedError':           (() => (typeof SuppressedError === 'undefined' ? undefined : SuppressedError)),
      'SyntaxError':               (() => SyntaxError),
      'TypeError':                 (() => TypeError),
      'URIError':                  (() => URIError),
      'InternalError':             (() => (typeof InternalError === 'undefined' ? undefined : InternalError)),
      'Number':                    (() => Number),
      'BigInt':                    (() => BigInt),
      'Math':                      (() => Math),
      'Date':                      (() => Date),
      'Temporal':                  (() => (typeof Temporal === 'undefined' ? undefined : Temporal)),
      'String':                    (() => String),
      'RegExp':                    (() => RegExp),
      'Array':                     (() => Array),
      'TypedArray':                (() => (typeof TypedArray === 'undefined' ? undefined : TypedArray)),
      'Int8Array':                 (() => Int8Array),
      'Uint8Array':                (() => Uint8Array),
      'Uint8ClampedArray':         (() => Uint8ClampedArray),
      'Int16Array':                (() => Int16Array),
      'Uint16Array':               (() => Uint16Array),
      'Int32Array':                (() => Int32Array),
      'Uint32Array':               (() => Uint32Array),
      'BigInt64Array':             (() => (typeof BigInt64Array  === 'undefined' ? undefined : BigInt64Array)),
      'BigUint64Array':            (() => (typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array)),
      'Float16Array':              (() => (typeof Float16Array   === 'undefined' ? undefined : Float16Array)),  // Baseline 2025
      'Float32Array':              (() => Float32Array),
      'Float64Array':              (() => Float64Array),
      'Map':                       (() => Map),
      'Set':                       (() => Set),
      'WeakMap':                   (() => WeakMap),
      'WeakSet':                   (() => WeakSet),
      'ArrayBuffer':               (() => ArrayBuffer),
      'SharedArrayBuffer':        (() => (typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer)),
      'DataView':                  (() => DataView),
      'Atomics':                   (() => (typeof Atomics === 'undefined' ? undefined : Atomics)),
      'JSON':                      (() => JSON),
      'WeakRef':                   (() => (typeof WeakRef === 'undefined' ? undefined : WeakRef)),
      'FinalizationRegistry':      (() => (typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry)),
      'Iterator':                  (() => (typeof Iterator === 'undefined' ? undefined : Iterator)),
      'AsyncIterator':             (() => (typeof AsyncIterator === 'undefined' ? undefined : AsyncIterator)),
      'Promise':                   (() => Promise),
      'GeneratorFunction':         (() => (typeof GeneratorFunction === 'undefined' ? undefined : GeneratorFunction)),
      'AsyncGeneratorFunction':    (() => (typeof AsyncGeneratorFunction === 'undefined' ? undefined : AsyncGeneratorFunction)),
      'Generator':                 (() => (typeof Generator === 'undefined' ? undefined : Generator)),
      'AsyncGenerator':            (() => (typeof AsyncGenerator === 'undefined' ? undefined : AsyncGenerator)),
      'AsyncFunction':             (() => (typeof AsyncFunction === 'undefined' ? undefined : AsyncFunction)),
      'DisposableStack':           (() => (typeof DisposableStack === 'undefined' ? undefined : DisposableStack)),
      'AsyncDisposableStack':     (() => (typeof AsyncDisposableStack === 'undefined' ? undefined : AsyncDisposableStack)),
      'Reflect':                   (() => Reflect),
      'Proxy':                     (() => Proxy),
      'Intl':                      (() => Intl),
      'Intl.Collator':             (() => ('Collator' in Intl ? Intl.Collator : undefined)),
      'Intl.DateTimeFormat':       (() => ('DateTimeFormat' in Intl ? Intl.DateTimeFormat : undefined)),
      'Intl.DisplayNames':         (() => ('DisplayNames' in Intl ? Intl.DisplayNames : undefined)),
      'Intl.DurationFormat':       (() => ('DurationFormat' in Intl ? Intl.DurationFormat : undefined)),
      'Intl.ListFormat':           (() => ('ListFormat' in Intl ? Intl.ListFormat : undefined)),
      'Intl.Locale':               (() => ('Locale' in Intl ? Intl.Locale : undefined)),
      'Intl.NumberFormat':         (() => ('NumberFormat' in Intl ? Intl.NumberFormat : undefined)),
      'Intl.PluralRules':          (() => ('PluralRules' in Intl ? Intl.PluralRules : undefined)),
      'Intl.RelativeTimeFormat':   (() => ('RelativeTimeFormat' in Intl ? Intl.RelativeTimeFormat : undefined)),
      'Intl.Segmenter':            (() => ('Segmenter' in Intl ? Intl.Segmenter : undefined))
    },
    'math': {
        'abs':    ((x)       => Math.abs(x)),
        'acos':   ((x)       => Math.acos(x)),
        'acosh':  ((x)       => Math.acosh(x)),
        'asin':   ((x)       => Math.asin(x)),
        'asinh':  ((x)       => Math.asinh(x)),
        'atan':   ((x)       => Math.atan(x)),
        'atan2':  ((y, x)    => Math.atan2(y, x)),
        'atanh':  ((x)       => Math.atanh(x)),
        'cbrt':   ((x)       => Math.cbrt(x)),
        'ceil':   ((x)       => Math.ceil(x)),
        'clz32':  ((x)       => Math.clz32(x)),
        'cos':    ((x)       => Math.cos(x)),
        'cosh':   ((x)       => Math.cosh(x)),
        'exp':    ((x)       => Math.exp(x)),
        'expm1':  ((x)       => Math.expm1(x)),
        'floor':  ((x)       => Math.floor(x)),
        'fround': ((x)       => Math.fround(x)),
        'hypot':  ((x, y)    => Math.hypot(x, y)),
        'imul':   ((a, b)    => Math.imul(a, b)),
        'log':    ((x)       => Math.log(x)),
        'log10':  ((x)       => Math.log10(x)),
        'log1p':  ((x)       => Math.log1p(x)),
        'log2':   ((x)       => Math.log2(x)),
        'max':    ((x, y)    => Math.max(x, y)),
        'min':    ((x, y)    => Math.min(x, y)),
        'pow':    ((x, y)    => Math.pow(x, y)),
        'random': (()        => Math.random()),
        'round':  ((x)       => Math.round(x)),
        'sign':   ((x)       => Math.sign(x)),
        'sin':    ((x)       => Math.sin(x)),
        'sinh':   ((x)       => Math.sinh(x)),
        'sqrt':   ((x)       => Math.sqrt(x)),
        'tan':    ((x)       => Math.tan(x)),
        'tanh':   ((x)       => Math.tanh(x)),
        'trunc':  ((x)       => Math.trunc(x))
    },
    'number': {
        // Machine epsilon constant.
        'epsilon':           (() => Number.EPSILON),
        // Largest safe integer.
        'max-safe-integer':  (() => Number.MAX_SAFE_INTEGER),
        // Greatest finite number.
        'max-value':         (() => Number.MAX_VALUE),
        // Smallest safe integer.
        'min-safe-integer':  (() => Number.MIN_SAFE_INTEGER),
        // Smallest positive non-zero number.
        'min-value':         (() => Number.MIN_VALUE),
        // IEEE NaN value.
        'nan':               (() => Number.NaN),
        // Negative infinity constant.
        'negative-infinity': (() => Number.NEGATIVE_INFINITY),
        // Positive infinity constant.
        'positive-infinity': (() => Number.POSITIVE_INFINITY),
        // Test whether a value is finite.
        'is-finite':         (x => boolean_to_i32(Number.isFinite(x))),
        // Test whether a value is an integer.
        'is-integer':        (x => boolean_to_i32(Number.isInteger(x))),
        // Test whether a value is NaN.
        'is-nan':            (x => boolean_to_i32(Number.isNaN(x))),
        // Test whether a value is a safe integer.
        'is-safe-integer':   (x => boolean_to_i32(Number.isSafeInteger(x))),
        // Parse string into floating-point number.
        'parse-float':       (s => Number.parseFloat(from_fasl(s))),
        // Parse string into integer.
        'parse-int':         (s => Number.parseInt(from_fasl(s))),
        // Convert number to exponential notation.
        'to-exponential':    ((x, fd) => {
                                 const d = from_fasl(fd);
                                 const r = d === undefined ? x.toExponential() : x.toExponential(d);
                                 return to_fasl(r);
                               }),
        // Format number with fixed-point notation.
        'to-fixed':          ((x, digits) => {
                                 const d = from_fasl(digits);
                                 return to_fasl( d === undefined ? x.toFixed() : x.toFixed(d) );
                               }),
        // Format number using locale-specific rules.
        'to-locale-string':  ((x, locales, options) => to_fasl( x.toLocaleString(from_fasl(locales), from_fasl(options))) ),
        // Format number with specified precision.
        'to-precision':      ((x, precision) => {
                                 const p = from_fasl(precision);
                                 return to_fasl( p === undefined ? x.toPrecision() : x.toPrecision(p) );
                               }),
        // Convert number to string with optional radix.
        'to-string':         ((x, radix) => {
                                 const r = from_fasl(radix);
                                 return to_fasl( r === undefined ? x.toString() : x.toString(r) );
                               }),
        // Extract primitive numeric value.
        'value-of':          (x => x.valueOf())
    },
    'array': {
        'length':            (arr => arr.length),
        'set-length!':       ((arr, len) => { arr.length = len; }),
        'from':              ((arrLike, mapFn, thisArg) => {
            const a = from_fasl(arrLike);
            const m = mapFn;
            const t = from_fasl(thisArg);
            if (m === undefined) {
                return Array.from(a);
            } else if (t === undefined) {
                return Array.from(a, m);
            } else {
                return Array.from(a, m, t);
            }
        }),
        'from-async':        ((arrLike, mapFn, thisArg) => {
            const a = from_fasl(arrLike);
            const m = mapFn;
            const t = from_fasl(thisArg);
            if (m === undefined) {
                return Array.fromAsync(a);
            } else if (t === undefined) {
                return Array.fromAsync(a, m);
            } else {
                return Array.fromAsync(a, m, t);
            }
        }),
        'is-array':          (v => Array.isArray(from_fasl(v)) ? 1 : 0),
        'of':                (items => Array.of(...(from_fasl(items) || []))),
        'at':                ((arr, index) => arr.at(index)),
        'concat':            ((arr, items) => arr.concat(...(from_fasl(items) || []))),
        'copy-within':       ((arr, target, start, end) => {
            const e = from_fasl(end);
            return e === undefined ? arr.copyWithin(target, start)
                                   : arr.copyWithin(target, start, e);
        }),
        'entries':           (arr => arr.entries()),
        'every':             ((arr, fn, thisArg) => arr.every(fn, from_fasl(thisArg)) ? 1 : 0),
        'fill':              ((arr, value, start, end) => arr.fill(from_fasl(value), from_fasl(start), from_fasl(end))),
        'filter':            ((arr, fn, thisArg) => arr.filter(fn, from_fasl(thisArg))),
        'find':              ((arr, fn, thisArg) => arr.find(fn, from_fasl(thisArg))),
        'find-index':        ((arr, fn, thisArg) => arr.findIndex(fn, from_fasl(thisArg))),
        'find-last':         ((arr, fn, thisArg) => arr.findLast(fn, from_fasl(thisArg))),
        'find-last-index':   ((arr, fn, thisArg) => arr.findLastIndex(fn, from_fasl(thisArg))),
        'flat':              ((arr, depth) => arr.flat(from_fasl(depth))),
        'flat-map':          ((arr, fn, thisArg) => arr.flatMap(fn, from_fasl(thisArg))),
        'for-each':          ((arr, fn, thisArg) => { arr.forEach(fn, from_fasl(thisArg)); }),
        'includes':          ((arr, value, fromIndex) => arr.includes(from_fasl(value), from_fasl(fromIndex)) ? 1 : 0),
        'index-of':          ((arr, value, fromIndex) => arr.indexOf(from_fasl(value), from_fasl(fromIndex))),
        'join':              ((arr, sep) => arr.join(from_fasl(sep))),
        'keys':              (arr => arr.keys()),
        'last-index-of':     ((arr, value, fromIndex) => arr.lastIndexOf(from_fasl(value), from_fasl(fromIndex))),
        'map':               ((arr, fn, thisArg) => arr.map(fn, from_fasl(thisArg))),
        'pop':               (arr => arr.pop()),
        'push':              ((arr, items) => arr.push(...(from_fasl(items) || []))),
        'reduce':            ((arr, fn, init) => {
            const i = from_fasl(init);
            return i === undefined ? arr.reduce(fn) : arr.reduce(fn, i);
        }),
        'reduce-right':      ((arr, fn, init) => {
            const i = from_fasl(init);
            return i === undefined ? arr.reduceRight(fn) : arr.reduceRight(fn, i);
        }),
        'reverse':           (arr => arr.reverse()),
        'shift':             (arr => arr.shift()),
        'slice':             ((arr, start, end) => arr.slice(from_fasl(start), from_fasl(end))),
        'some':              ((arr, fn, thisArg) => arr.some(fn, from_fasl(thisArg)) ? 1 : 0),
        'sort':              ((arr, fn) => arr.sort(fn)),
        'splice':            ((arr, items) => arr.splice(...(from_fasl(items) || []))),
        'to-locale-string':  ((arr, args) => arr.toLocaleString(...(from_fasl(args) || []))),
        'to-string':         (arr => arr.toString()),
        'unshift':           ((arr, items) => arr.unshift(...(from_fasl(items) || []))),
        'values':            (arr => arr.values()),
        'to-reversed':       (arr => (arr.toReversed ? arr.toReversed() : [...arr].reverse())),
        'to-sorted':         ((arr, fn) => (arr.toSorted ? arr.toSorted(fn) : [...arr].sort(fn))),
        'to-spliced':        ((arr, items) => (arr.toSpliced ? arr.toSpliced(...(from_fasl(items) || [])) : (() => { const b = arr.slice(); b.splice(...(from_fasl(items) || [])); return b; })())),
        'with':              ((arr, index, value) => (arr.with ? arr.with(index, from_fasl(value)) : (() => { const b = arr.slice(); b[index] = from_fasl(value); return b; })())),
    },
    // Canvas
    'canvas': hasDOM ? {
        'capture-stream':                ((canvas, rate)                 => canvas.captureStream(rate)),
        'get-context':                   ((canvas, type, opts)           => canvas.getContext(from_fasl(type), opts)),
        'height':                        ((canvas)                       => canvas.height),
        'set-height!':                   ((canvas, h)                    => { canvas.height = h; }),
        'to-blob':                       ((canvas, cb, type, quality)    => canvas.toBlob(cb, from_fasl(type), quality)),
        'to-data-url':                   ((canvas, type, quality)        => canvas.toDataURL(from_fasl(type), quality)),
        'transfer-control-to-offscreen': ((canvas)                       => canvas.transferControlToOffscreen()),
        'width':                         ((canvas)                       => canvas.width),
        'set-width!':                    ((canvas, w)                    => { canvas.width = w; })
    } : {
        'capture-stream'()                { throw new Error('DOM not available in this environment'); },
        'get-context'()                   { throw new Error('DOM not available in this environment'); },
        'height'()                        { throw new Error('DOM not available in this environment'); },
        'set-height!'()                   { throw new Error('DOM not available in this environment'); },
        'to-blob'()                       { throw new Error('DOM not available in this environment'); },
        'to-data-url'()                   { throw new Error('DOM not available in this environment'); },
        'transfer-control-to-offscreen'() { throw new Error('DOM not available in this environment'); },
        'width'()                         { throw new Error('DOM not available in this environment'); },
        'set-width!'()                    { throw new Error('DOM not available in this environment'); }
    },
    // CanvasRenderingContext2D
    'canvas-rendering-context-2d': hasDOM ? {
        'canvas':                 (ctx => ctx.canvas),
        'direction':              (ctx => ctx.direction),
        'set-direction!':         ((ctx, dir) => { ctx.direction = from_fasl(dir); }),
        'fill-style':             (ctx => ctx.fillStyle),
        'set-fill-style!':        ((ctx, style) => { ctx.fillStyle = from_fasl(style); }),
        'filter':                 (ctx => ctx.filter),
        'set-filter!':            ((ctx, filter) => { ctx.filter = from_fasl(filter); }),
        'font':                   (ctx => ctx.font),
        'set-font!':              ((ctx, font) => { ctx.font = from_fasl(font); }),
        'global-alpha':           (ctx => ctx.globalAlpha),
        'set-global-alpha!':      ((ctx, a) => { ctx.globalAlpha = a; }),
        'global-composite-operation': (ctx => ctx.globalCompositeOperation),
        'set-global-composite-operation!': ((ctx, op) => { ctx.globalCompositeOperation = from_fasl(op); }),
        'image-smoothing-enabled': (ctx => ctx.imageSmoothingEnabled ? 1 : 0),
        'set-image-smoothing-enabled!': ((ctx, flag) => { ctx.imageSmoothingEnabled = !!flag; }),
        'image-smoothing-quality': (ctx => ctx.imageSmoothingQuality),
        'set-image-smoothing-quality!': ((ctx, q) => { ctx.imageSmoothingQuality = from_fasl(q); }),
        'line-cap':               (ctx => ctx.lineCap),
        'set-line-cap!':          ((ctx, cap) => { ctx.lineCap = from_fasl(cap); }),
        'line-dash-offset':       (ctx => ctx.lineDashOffset),
        'set-line-dash-offset!':  ((ctx, off) => { ctx.lineDashOffset = off; }),
        'line-join':              (ctx => ctx.lineJoin),
        'set-line-join!':         ((ctx, join) => { ctx.lineJoin = from_fasl(join); }),
        'line-width':             (ctx => ctx.lineWidth),
        'set-line-width!':        ((ctx, w) => { ctx.lineWidth = w; }),
        'miter-limit':            (ctx => ctx.miterLimit),
        'set-miter-limit!':       ((ctx, m) => { ctx.miterLimit = m; }),
        'shadow-blur':            (ctx => ctx.shadowBlur),
        'set-shadow-blur!':       ((ctx, b) => { ctx.shadowBlur = b; }),
        'shadow-color':           (ctx => ctx.shadowColor),
        'set-shadow-color!':      ((ctx, c) => { ctx.shadowColor = from_fasl(c); }),
        'shadow-offset-x':        (ctx => ctx.shadowOffsetX),
        'set-shadow-offset-x!':   ((ctx, x) => { ctx.shadowOffsetX = x; }),
        'shadow-offset-y':        (ctx => ctx.shadowOffsetY),
        'set-shadow-offset-y!':   ((ctx, y) => { ctx.shadowOffsetY = y; }),
        'stroke-style':           (ctx => ctx.strokeStyle),
        'set-stroke-style!':      ((ctx, style) => { ctx.strokeStyle = from_fasl(style); }),
        'text-align':             (ctx => ctx.textAlign),
        'set-text-align!':        ((ctx, a) => { ctx.textAlign = from_fasl(a); }),
        'text-baseline':          (ctx => ctx.textBaseline),
        'set-text-baseline!':     ((ctx, b) => { ctx.textBaseline = from_fasl(b); }),
        'text-rendering':         (ctx => ctx.textRendering),
        'set-text-rendering!':    ((ctx, r) => { ctx.textRendering = from_fasl(r); }),
        'font-kerning':           (ctx => ctx.fontKerning),
        'set-font-kerning!':      ((ctx, k) => { ctx.fontKerning = from_fasl(k); }),
        'font-stretch':           (ctx => ctx.fontStretch),
        'set-font-stretch!':      ((ctx, s) => { ctx.fontStretch = from_fasl(s); }),
        'font-variant-caps':      (ctx => ctx.fontVariantCaps),
        'set-font-variant-caps!': ((ctx, v) => { ctx.fontVariantCaps = from_fasl(v); }),
        'font-variant-ligatures': (ctx => ctx.fontVariantLigatures),
        'set-font-variant-ligatures!': ((ctx, v) => { ctx.fontVariantLigatures = from_fasl(v); }),
        'font-variant-numeric':   (ctx => ctx.fontVariantNumeric),
        'set-font-variant-numeric!': ((ctx, v) => { ctx.fontVariantNumeric = from_fasl(v); }),
        'letter-spacing':         (ctx => ctx.letterSpacing),
        'set-letter-spacing!':    ((ctx, v) => { ctx.letterSpacing = from_fasl(v); }),
        'word-spacing':           (ctx => ctx.wordSpacing),
        'set-word-spacing!':      ((ctx, v) => { ctx.wordSpacing = from_fasl(v); }),
        'arc': ((ctx, x, y, r, sa, ea, ccw) => ctx.arc(x, y, r, sa, ea, !!ccw)),
        'arc-to': ((ctx, x1, y1, x2, y2, r) => ctx.arcTo(x1, y1, x2, y2, r)),
        'begin-path': (ctx => ctx.beginPath()),
        'bezier-curve-to': ((ctx, cp1x, cp1y, cp2x, cp2y, x, y) => ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)),
        'clear-rect': ((ctx, x, y, w, h) => ctx.clearRect(x, y, w, h)),
        'clip': ((ctx, path, rule) => {
          // `(void)` is decoded as `undefined`
          const p = from_fasl(path);
          const r = from_fasl(rule);
          if (p === undefined && r === undefined) {
            ctx.clip();
          } else if (p === undefined) {
            ctx.clip(r);
          } else if (r === undefined) {
            ctx.clip(p);
          } else {
            ctx.clip(p, r);
          }
        }),
        'close-path': (ctx => ctx.closePath()),
        'create-image-data': ((ctx, sw, sh) => ctx.createImageData(sw, sh)),
        'create-image-data-from': ((ctx, data) => ctx.createImageData(data)),
        'create-linear-gradient': ((ctx, x0, y0, x1, y1) => ctx.createLinearGradient(x0, y0, x1, y1)),
        'create-pattern': ((ctx, img, rep) => ctx.createPattern(img, from_fasl(rep))),
        'create-radial-gradient': ((ctx, x0, y0, r0, x1, y1, r1) => ctx.createRadialGradient(x0, y0, r0, x1, y1, r1)),
        'create-conic-gradient': ((ctx, sa, x, y) => ctx.createConicGradient(sa, x, y)),
        'draw-focus-if-needed!': ((ctx, elem) => ctx.drawFocusIfNeeded(elem)),
        'draw-focus-if-needed-path!': ((ctx, path, elem) => ctx.drawFocusIfNeeded(path, elem)),
        'draw-image': ((ctx, img, dx, dy) => ctx.drawImage(img, dx, dy)),
        'draw-image-5': ((ctx, img, dx, dy, dw, dh) => ctx.drawImage(img, dx, dy, dw, dh)),
        'draw-image-9': ((ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) => ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh)),
        'ellipse': ((ctx, x, y, rx, ry, rot, sa, ea, ccw) => ctx.ellipse(x, y, rx, ry, rot, sa, ea, !!ccw)),
        'fill': ((ctx, path, rule) => {
          // `(void)` is decoded as `undefined`
          const p = from_fasl(path);
          const r = from_fasl(rule);
          if (p === undefined && r === undefined) {
            ctx.fill();
          } else if (p === undefined) {
            ctx.fill(r);
          } else if (r === undefined) {
            ctx.fill(p);
          } else {
            ctx.fill(p, r);
          }
        }),
        'fill-rect': ((ctx, x, y, w, h) => ctx.fillRect(x, y, w, h)),
        'fill-text': ((ctx, text, x, y, mw) => {
          const m = from_fasl(mw);
          if (m === undefined) {
            ctx.fillText(from_fasl(text), x, y);
          } else {
            ctx.fillText(from_fasl(text), x, y, m);
          }
        }),
        'get-image-data': ((ctx, sx, sy, sw, sh, opts) => {
          const o = from_fasl(opts);
          if (o === undefined) {
            return ctx.getImageData(sx, sy, sw, sh);
          } else {
            return ctx.getImageData(sx, sy, sw, sh, o);
          }
        }),
        'get-line-dash': (ctx => ctx.getLineDash()),
        'get-transform': (ctx => ctx.getTransform()),
        'is-point-in-path': ((ctx, path, x, y, rule) => {
          const p = from_fasl(path);
          const r = from_fasl(rule);
          if (p === undefined && r === undefined) {
            return ctx.isPointInPath(x, y) ? 1 : 0;
          } else if (p === undefined) {
            return ctx.isPointInPath(x, y, r) ? 1 : 0;
          } else if (r === undefined) {
            return ctx.isPointInPath(p, x, y) ? 1 : 0;
          } else {
            return ctx.isPointInPath(p, x, y, r) ? 1 : 0;
          }
        }),
        'is-point-in-stroke': ((ctx, path, x, y) => {
          const p = from_fasl(path);
          if (p === undefined) {
            return ctx.isPointInStroke(x, y) ? 1 : 0;
          } else {
            return ctx.isPointInStroke(p, x, y) ? 1 : 0;
          }
        }),
        'line-to': ((ctx, x, y) => ctx.lineTo(x, y)),
        'measure-text': ((ctx, text) => ctx.measureText(from_fasl(text))),
        'move-to': ((ctx, x, y) => ctx.moveTo(x, y)),
        'put-image-data': ((ctx, data, dx, dy, dirtyX, dirtyY, dirtyW, dirtyH) => {
          const dX = from_fasl(dirtyX);
          const dY = from_fasl(dirtyY);
          const dW = from_fasl(dirtyW);
          const dH = from_fasl(dirtyH);
          if (dX === undefined && dY === undefined && dW === undefined && dH === undefined) {
            ctx.putImageData(data, dx, dy);
          } else {
            ctx.putImageData(data, dx, dy, dX, dY, dW, dH);
          }
        }),
        'quadratic-curve-to': ((ctx, cpx, cpy, x, y) => ctx.quadraticCurveTo(cpx, cpy, x, y)),
        'rect': ((ctx, x, y, w, h) => ctx.rect(x, y, w, h)),
        'reset': (ctx => ctx.reset()),
        'reset-transform': (ctx => ctx.resetTransform()),
        'restore': (ctx => ctx.restore()),
        'rotate': ((ctx, angle) => ctx.rotate(angle)),
        'round-rect': ((ctx, x, y, w, h, r) => {
          const rad = from_fasl(r);
          if (rad === undefined) {
            ctx.roundRect(x, y, w, h);
          } else {
            ctx.roundRect(x, y, w, h, rad);
          }
        }),
        'save': (ctx => ctx.save()),
        'scale': ((ctx, x, y) => ctx.scale(x, y)),
        'set-line-dash': ((ctx, arr) => ctx.setLineDash(arr)),
        'set-transform!': ((ctx, a, b, c, d, e, f) => ctx.setTransform(a, b, c, d, e, f)),
        'set-transform-matrix!': ((ctx, m) => ctx.setTransform(m)),
        'stroke': ((ctx, path) => {
          const p = from_fasl(path);
          if (p === undefined) {
            ctx.stroke();
          } else {
            ctx.stroke(p);
          }
        }),
        'stroke-rect': ((ctx, x, y, w, h) => ctx.strokeRect(x, y, w, h)),
        'stroke-text': ((ctx, text, x, y, mw) => {
          const m = from_fasl(mw);
          if (m === undefined) {
            ctx.strokeText(from_fasl(text), x, y);
          } else {
            ctx.strokeText(from_fasl(text), x, y, m);
          }
        }),
        'transform': ((ctx, a, b, c, d, e, f) => ctx.transform(a, b, c, d, e, f)),
        'translate': ((ctx, x, y) => ctx.translate(x, y)),
    } : new Proxy({}, { get() { throw new Error('DOM not available in this environment'); } }),
    // Window
    'window': hasDOM ? {
        'window':               (() => window),
        'self':                 (() => self),
        'document':             (() => document),
        'name':                 (() => window.name),
        'set-name!':            (n => { window.name = from_fasl(n); }),
        'location':             (() => window.location),
        'set-location!':        (loc => { window.location = from_fasl(loc); }),
        'custom-elements':      (() => window.customElements),
        'history':              (() => window.history),
        'locationbar':          (() => window.locationbar),
        'menubar':              (() => window.menubar),
        'personalbar':          (() => window.personalbar),
        'scrollbars':           (() => window.scrollbars),
        'statusbar':            (() => window.statusbar),
        'toolbar':              (() => window.toolbar),
        'status':               (() => window.status),
        'set-status!':          (s => { window.status = from_fasl(s); }),
        'closed':               (() => window.closed ? 1 : 0),
        'frames':               (() => window.frames),
        'length':               (() => window.length),
        'opener':               (() => window.opener),
        'set-opener!':          (o => { window.opener = o; }),
        'parent':               (() => window.parent),
        'top':                  (() => window.top),
        'visual-viewport':      (() => window.visualViewport),
        'navigator':            (() => window.navigator),
        'origin':               (() => window.origin),
        'crypto':               (() => window.crypto),
        'device-pixel-ratio':   (() => window.devicePixelRatio),
        'event':                (() => window.event),
        'frame-element':        (() => window.frameElement),
        'inner-height':         (() => window.innerHeight),
        'inner-width':          (() => window.innerWidth),
        'outer-height':         (() => window.outerHeight),
        'outer-width':          (() => window.outerWidth),
        'screen-x':             (() => window.screenX),
        'screen-y':             (() => window.screenY),
        'screen-left':          (() => window.screenLeft),
        'screen-top':           (() => window.screenTop),
        'page-x-offset':        (() => window.pageXOffset),
        'page-y-offset':        (() => window.pageYOffset),
        'scroll-x':             (() => window.scrollX),
        'scroll-y':             (() => window.scrollY),
        'screen':               (() => window.screen),
        'local-storage':        (() => window.localStorage),
        'session-storage':      (() => window.sessionStorage),
        'performance':          (() => window.performance),
        'indexed-db':           (() => window.indexedDB),
        'is-secure-context':    (() => window.isSecureContext ? 1 : 0),
        'cross-origin-isolated':(() => window.crossOriginIsolated ? 1 : 0),
        'caches':               (() => window.caches),
        'speech-synthesis':     (() => window.speechSynthesis),
        'style-media':          (() => window.styleMedia),
        'alert':                (msg => window.alert(from_fasl(msg))),
        'atob':                 (s => window.atob(from_fasl(s))),
        'btoa':                 (s => window.btoa(from_fasl(s))),
        'blur':                 (() => window.blur()),
        'cancel-animation-frame': (id => window.cancelAnimationFrame(id)),
        'cancel-idle-callback': (id => window.cancelIdleCallback(id)),
        'clear-interval':       (id => window.clearInterval(id)),
        'clear-timeout':        (id => window.clearTimeout(id)),
        'close':                (() => window.close()),
        'confirm':              (msg => window.confirm(from_fasl(msg)) ? 1 : 0),
        'create-image-bitmap':  ((image, sx, sy, sw, sh, opts) => {
            const Sx = from_fasl(sx);
            const Sy = from_fasl(sy);
            const Sw = from_fasl(sw);
            const Sh = from_fasl(sh);
            const o  = from_fasl(opts);
            if (Sx === undefined) {
                return window.createImageBitmap(image);
            } else if (o === undefined) {
                return window.createImageBitmap(image, Sx, Sy, Sw, Sh);
            } else {
                return window.createImageBitmap(image, Sx, Sy, Sw, Sh, o);
            }
        }),
        'fetch': ((input, init) => {
            const inp = from_fasl(input);
            const i   = from_fasl(init);
            if (i === undefined) {
                return fetch(inp);
            } else {
                return fetch(inp, i);
            }
        }),
        'focus':                (() => window.focus()),
        'get-computed-style':   ((elt, pseudo) => {
            const p = from_fasl(pseudo);
            return window.getComputedStyle(elt, p);
        }),
        'get-selection':        (() => window.getSelection()),
        'match-media':          (q => window.matchMedia(from_fasl(q))),
        'move-by':              ((x, y) => window.moveBy(x, y)),
        'move-to':              ((x, y) => window.moveTo(x, y)),
        'open':                 ((url, target, features, replace) => {
            const u = from_fasl(url);
            const t = from_fasl(target);
            const f = from_fasl(features);
            const r = from_fasl(replace);
            if (t === undefined && f === undefined && r === undefined) {
                return window.open(u);
            } else if (f === undefined && r === undefined) {
                return window.open(u, t);
            } else if (r === undefined) {
                return window.open(u, t, f);
            } else {
                return window.open(u, t, f, r);
            }
        }),
        'post-message':        ((msg, target, transfer) => {
            const t = from_fasl(transfer);
            if (t === undefined) {
                window.postMessage(from_fasl(msg), from_fasl(target));
            } else {
                window.postMessage(from_fasl(msg), from_fasl(target), t);
            }
        }),
        'print':               (() => window.print()),
        'prompt':              ((msg, def) => window.prompt(from_fasl(msg), from_fasl(def))),
        'request-animation-frame': (cb => window.requestAnimationFrame(cb)),
        'request-idle-callback': ((cb, opts) => {
            const o = from_fasl(opts);
            if (o === undefined) {
                return window.requestIdleCallback(cb);
            } else {
                return window.requestIdleCallback(cb, o);
            }
        }),
        'resize-by':           ((x, y) => window.resizeBy(x, y)),
        'resize-to':           ((w, h) => window.resizeTo(w, h)),
        'scroll':              ((x, y, opts) => {
            const o = from_fasl(opts);
            if (o === undefined) {
                window.scroll(x, y);
            } else {
                window.scroll(o);
            }
        }),
        'scroll-by':           ((x, y, opts) => {
            const o = from_fasl(opts);
            if (o === undefined) {
                window.scrollBy(x, y);
            } else {
                window.scrollBy(o);
            }
        }),
        'scroll-to':           ((x, y, opts) => {
            const o = from_fasl(opts);
            if (o === undefined) {
                window.scrollTo(x, y);
            } else {
                window.scrollTo(o);
            }
        }),
        'set-interval':        ((handler, delay) => window.setInterval(handler, delay)),
        'set-timeout':         ((handler)        => window.setTimeout(handler)),
        'set-timeout/delay':   ((handler, delay) => window.setTimeout(handler, delay)),
        'stop':                (() => window.stop()),
        'structured-clone':    ((value, options) => {
            const o = from_fasl(options);
            if (o === undefined) {
                return window.structuredClone(from_fasl(value));
            } else {
                return window.structuredClone(from_fasl(value), o);
            }
        }),
        'queue-microtask':     (cb => window.queueMicrotask(cb)),
        'report-error':        (err => window.reportError(from_fasl(err)))
    } : new Proxy({}, { get() { throw new Error('DOM not available in this environment'); } }),
    // Performance
    'performance': hasDOM ? {
        'now':                 (() => performance.now())
    } : new Proxy({}, { get() { throw new Error('DOM not available in this environment'); } }),
    // Document
    'document': hasDOM ? {
        'document':                 (()                               => document),
        'head':                     (()                               => document.head),
        'body':                     (()                               => document.body),
        'document-element':         (()                               => document.documentElement),
        'create-element':           ((local_name)                     => document.createElement(from_fasl(local_name))),
        'create-text-node':         ((fasl_start)                     => document.createTextNode(from_fasl(fasl_start))),
        'adopt-node':               ((node)                           => document.adoptNode(node)),
        'caret-range-from-point':   ((x, y)                           => document.caretRangeFromPoint(x, y)),
        'capture-events':           (()                               => document.captureEvents()),
        'clear':                    (()                               => document.clear()),
        'close':                    (()                               => document.close()),
        'create-attribute':         ((name)                           => document.createAttribute(from_fasl(name))),
        'create-attribute-ns':      ((ns, name)                      => document.createAttributeNS(from_fasl(ns), from_fasl(name))),
        'create-cdata-section':     ((data)                           => document.createCDATASection(from_fasl(data))),
        'create-comment':           ((data)                           => document.createComment(from_fasl(data))),
        'create-document-fragment': (()                               => document.createDocumentFragment()),
        'create-element-ns':        ((ns, name)                       => document.createElementNS(from_fasl(ns), from_fasl(name))),
        'create-event':             ((type)                           => document.createEvent(from_fasl(type))),
        'create-expression':        ((expr, resolver)                 => document.createExpression(from_fasl(expr), resolver)),
        'create-ns-resolver':       ((node)                           => document.createNSResolver(node)),
        'create-node-iterator':     ((root, what, filter)             => document.createNodeIterator(root, what, filter)),
        'create-processing-instruction': ((target, data)             => document.createProcessingInstruction(from_fasl(target), from_fasl(data))),
        'create-range':             (()                               => document.createRange()),
        'create-tree-walker':       ((root, what, filter)             => document.createTreeWalker(root, what, filter)),
        'element-from-point':       ((x, y)                           => document.elementFromPoint(x, y)),
        'elements-from-point':      ((x, y)                           => document.elementsFromPoint(x, y)),
        'enable-style-sheets-for-set': ((name)                        => document.enableStyleSheetsForSet(from_fasl(name))),
        'evaluate':                 ((expr, ctx, resolver, type, result) => document.evaluate(from_fasl(expr), ctx, resolver, type, result)),
        'exec-command':             ((cmd, show_ui, value)            => document.execCommand(from_fasl(cmd), !!show_ui, from_fasl(value)) ? 1 : 0),
        'exit-fullscreen':          (()                               => document.exitFullscreen()),
        'exit-picture-in-picture':  (()                               => document.exitPictureInPicture()),
        'exit-pointer-lock':        (()                               => document.exitPointerLock()),
        'get-element-by-id':        ((id)                             => document.getElementById(from_fasl(id))),
        'get-elements-by-class-name': ((class_name)                   => document.getElementsByClassName(from_fasl(class_name))),
        'get-elements-by-name':     ((name)                           => document.getElementsByName(from_fasl(name))),
        'get-elements-by-tag-name': ((name)                           => document.getElementsByTagName(from_fasl(name))),
        'get-elements-by-tag-name-ns': ((ns, name)                    => document.getElementsByTagNameNS(from_fasl(ns), from_fasl(name))),
        'get-selection':            (()                               => document.getSelection()),
        'has-focus':                (()                               => document.hasFocus() ? 1 : 0),
        'import-node':              ((node, deep)                     => document.importNode(node, !!deep)),
        'open':                     (()                               => document.open()),
        // Deprecated:
        // 'query-command-enabled':    ((cmd)                            => document.queryCommandEnabled(from_fasl(cmd)) ? 1 : 0),
        // 'query-command-indeterm':   ((cmd)                            => document.queryCommandIndeterm(from_fasl(cmd)) ? 1 : 0),
        // 'query-command-state':      ((cmd)                            => document.queryCommandState(from_fasl(cmd)) ? 1 : 0),
        // 'query-command-supported':  ((cmd)                            => document.queryCommandSupported(from_fasl(cmd)) ? 1 : 0),
        // 'query-command-value':      ((cmd)                            => document.queryCommandValue(from_fasl(cmd))),
        'query-selector':           ((sel)                            => document.querySelector(from_fasl(sel))),
        'query-selector-all':       ((sel)                            => document.querySelectorAll(from_fasl(sel))),
        'release-events':           (()                               => document.releaseEvents()),
        // Deprecated
        // 'write':                    ((text)                           => document.write(from_fasl(text))),
        // 'writeln':                  ((text)                           => document.writeln(from_fasl(text))),
    }
    : { // Node
        'document'()                 { throw new Error('DOM not available in this environment'); },
        'head'()                     { throw new Error('DOM not available in this environment'); },
        'body'()                     { throw new Error('DOM not available in this environment'); },
        'document-element'()         { throw new Error('DOM not available in this environment'); },
        'create-element'()           { throw new Error('DOM not available in this environment'); },
        'create-text-node'()         { throw new Error('DOM not available in this environment'); },
        'adopt-node'()               { throw new Error('DOM not available in this environment'); },
        'caret-range-from-point'()   { throw new Error('DOM not available in this environment'); },
        'capture-events'()           { throw new Error('DOM not available in this environment'); },
        'clear'()                    { throw new Error('DOM not available in this environment'); },
        'close'()                    { throw new Error('DOM not available in this environment'); },
        'create-attribute'()         { throw new Error('DOM not available in this environment'); },
        'create-attribute-ns'()      { throw new Error('DOM not available in this environment'); },
        'create-cdata-section'()     { throw new Error('DOM not available in this environment'); },
        'create-comment'()           { throw new Error('DOM not available in this environment'); },
        'create-document-fragment'() { throw new Error('DOM not available in this environment'); },
        'create-element-ns'()        { throw new Error('DOM not available in this environment'); },
        'create-event'()             { throw new Error('DOM not available in this environment'); },
        'create-expression'()        { throw new Error('DOM not available in this environment'); },
        'create-ns-resolver'()       { throw new Error('DOM not available in this environment'); },
        'create-node-iterator'()     { throw new Error('DOM not available in this environment'); },
        'create-processing-instruction'() { throw new Error('DOM not available in this environment'); },
        'create-range'()             { throw new Error('DOM not available in this environment'); },
        'create-tree-walker'()       { throw new Error('DOM not available in this environment'); },
        'element-from-point'()       { throw new Error('DOM not available in this environment'); },
        'elements-from-point'()      { throw new Error('DOM not available in this environment'); },
        'enable-style-sheets-for-set'() { throw new Error('DOM not available in this environment'); },
        'evaluate'()                 { throw new Error('DOM not available in this environment'); },
        'exec-command'()             { throw new Error('DOM not available in this environment'); },
        'exit-fullscreen'()          { throw new Error('DOM not available in this environment'); },
        'exit-picture-in-picture'()  { throw new Error('DOM not available in this environment'); },
        'exit-pointer-lock'()        { throw new Error('DOM not available in this environment'); },
        'get-element-by-id'()        { throw new Error('DOM not available in this environment'); },
        'get-elements-by-class-name'() { throw new Error('DOM not available in this environment'); },
        'get-elements-by-name'()     { throw new Error('DOM not available in this environment'); },
        'get-elements-by-tag-name'() { throw new Error('DOM not available in this environment'); },
        'get-elements-by-tag-name-ns'() { throw new Error('DOM not available in this environment'); },
        'get-selection'()            { throw new Error('DOM not available in this environment'); },
        'has-focus'()                { throw new Error('DOM not available in this environment'); },
        'import-node'()              { throw new Error('DOM not available in this environment'); },
        'open'()                     { throw new Error('DOM not available in this environment'); },
        'query-command-enabled'()    { throw new Error('DOM not available in this environment'); },
        'query-command-indeterm'()   { throw new Error('DOM not available in this environment'); },
        'query-command-state'()      { throw new Error('DOM not available in this environment'); },
        'query-command-supported'()  { throw new Error('DOM not available in this environment'); },
        'query-command-value'()      { throw new Error('DOM not available in this environment'); },
        'query-selector'()           { throw new Error('DOM not available in this environment'); },
        'query-selector-all'()       { throw new Error('DOM not available in this environment'); },
        'release-events'()           { throw new Error('DOM not available in this environment'); },
        'write'()                    { throw new Error('DOM not available in this environment'); },
        'writeln'()                  { throw new Error('DOM not available in this environment'); },
    },
    // Media
    'media': hasDOM ? {
        'audio-tracks': (m => m.audioTracks),
        'autoplay': (m => m.autoplay ? 1 : 0),
        'set-autoplay!': ((m, flag) => { m.autoplay = !!flag; }),
        'buffered': (m => m.buffered),
        'controls': (m => m.controls ? 1 : 0),
        'set-controls!': ((m, flag) => { m.controls = !!flag; }),
        'controls-list': (m => m.controlsList),
        'cross-origin': (m => m.crossOrigin),
        'set-cross-origin!': ((m, o) => { m.crossOrigin = from_fasl(o); }),
        'current-src': (m => m.currentSrc),
        'current-time': (m => m.currentTime),
        'set-current-time!': ((m, t) => { m.currentTime = t; }),
        'default-muted': (m => m.defaultMuted ? 1 : 0),
        'set-default-muted!': ((m, flag) => { m.defaultMuted = !!flag; }),
        'default-playback-rate': (m => m.defaultPlaybackRate),
        'set-default-playback-rate!': ((m, r) => { m.defaultPlaybackRate = r; }),
        'disable-remote-playback': (m => m.disableRemotePlayback ? 1 : 0),
        'set-disable-remote-playback!': ((m, flag) => { m.disableRemotePlayback = !!flag; }),
        'duration': (m => m.duration),
        'ended': (m => m.ended ? 1 : 0),
        'error': (m => m.error),
        'loop': (m => m.loop ? 1 : 0),
        'set-loop!': ((m, flag) => { m.loop = !!flag; }),
        'media-keys': (m => m.mediaKeys),
        'media-group': (m => m.mediaGroup),
        'set-media-group!': ((m, g) => { m.mediaGroup = from_fasl(g); }),
        'muted': (m => m.muted ? 1 : 0),
        'set-muted!': ((m, flag) => { m.muted = !!flag; }),
        'network-state': (m => m.networkState),
        'paused': (m => m.paused ? 1 : 0),
        'playback-rate': (m => m.playbackRate),
        'set-playback-rate!': ((m, r) => { m.playbackRate = r; }),
        'played': (m => m.played),
        'preload': (m => m.preload),
        'set-preload!': ((m, p) => { m.preload = from_fasl(p); }),
        'preserves-pitch': (m => m.preservesPitch ? 1 : 0),
        'set-preserves-pitch!': ((m, flag) => { m.preservesPitch = !!flag; }),
        'ready-state': (m => m.readyState),
        'seekable': (m => m.seekable),
        'seeking': (m => m.seeking ? 1 : 0),
        'sink-id': (m => m.sinkId),
        'src': (m => m.src),
        'set-src!': ((m, s) => { m.src = from_fasl(s); }),
        'src-object': (m => m.srcObject),
        'set-src-object!': ((m, obj) => { m.srcObject = obj; }),
        'text-tracks': (m => m.textTracks),
        'video-tracks': (m => m.videoTracks),
        'volume': (m => m.volume),
        'set-volume!': ((m, v) => { m.volume = v; }),
        'add-text-track!': ((m, kind, label, lang) => {
            const l = from_fasl(label);
            const g = from_fasl(lang);
            if (l === undefined && g === undefined) {
                return m.addTextTrack(from_fasl(kind));
            } else if (g === undefined) {
                return m.addTextTrack(from_fasl(kind), from_fasl(label));
            } else {
                return m.addTextTrack(from_fasl(kind), from_fasl(label), from_fasl(lang));
            }
        }),
        'can-play-type': ((m, type) => m.canPlayType(from_fasl(type))),
        'capture-stream': ((m, rate) => {
            const r = from_fasl(rate);
            if (r === undefined) {
                return m.captureStream();
            } else {
                return m.captureStream(r);
            }
        }),
        'fast-seek!': ((m, t) => { m.fastSeek(t); }),
        'load!': (m => { m.load(); }),
        'pause': (m => m.pause()),
        'play': (m => m.play()),
        'set-media-keys!': ((m, keys) => m.setMediaKeys(keys)),
        'set-sink-id!': ((m, id) => m.setSinkId(from_fasl(id))),
    } : {
        'audio-tracks'() { throw new Error('DOM not available in this environment'); },
        'autoplay'() { throw new Error('DOM not available in this environment'); },
        'set-autoplay!'() { throw new Error('DOM not available in this environment'); },
        'buffered'() { throw new Error('DOM not available in this environment'); },
        'controls'() { throw new Error('DOM not available in this environment'); },
        'set-controls!'() { throw new Error('DOM not available in this environment'); },
        'controls-list'() { throw new Error('DOM not available in this environment'); },
        'cross-origin'() { throw new Error('DOM not available in this environment'); },
        'set-cross-origin!'() { throw new Error('DOM not available in this environment'); },
        'current-src'() { throw new Error('DOM not available in this environment'); },
        'current-time'() { throw new Error('DOM not available in this environment'); },
        'set-current-time!'() { throw new Error('DOM not available in this environment'); },
        'default-muted'() { throw new Error('DOM not available in this environment'); },
        'set-default-muted!'() { throw new Error('DOM not available in this environment'); },
        'default-playback-rate'() { throw new Error('DOM not available in this environment'); },
        'set-default-playback-rate!'() { throw new Error('DOM not available in this environment'); },
        'disable-remote-playback'() { throw new Error('DOM not available in this environment'); },
        'set-disable-remote-playback!'() { throw new Error('DOM not available in this environment'); },
        'duration'() { throw new Error('DOM not available in this environment'); },
        'ended'() { throw new Error('DOM not available in this environment'); },
        'error'() { throw new Error('DOM not available in this environment'); },
        'loop'() { throw new Error('DOM not available in this environment'); },
        'set-loop!'() { throw new Error('DOM not available in this environment'); },
        'media-keys'() { throw new Error('DOM not available in this environment'); },
        'media-group'() { throw new Error('DOM not available in this environment'); },
        'set-media-group!'() { throw new Error('DOM not available in this environment'); },
        'muted'() { throw new Error('DOM not available in this environment'); },
        'set-muted!'() { throw new Error('DOM not available in this environment'); },
        'network-state'() { throw new Error('DOM not available in this environment'); },
        'paused'() { throw new Error('DOM not available in this environment'); },
        'playback-rate'() { throw new Error('DOM not available in this environment'); },
        'set-playback-rate!'() { throw new Error('DOM not available in this environment'); },
        'played'() { throw new Error('DOM not available in this environment'); },
        'preload'() { throw new Error('DOM not available in this environment'); },
        'set-preload!'() { throw new Error('DOM not available in this environment'); },
        'preserves-pitch'() { throw new Error('DOM not available in this environment'); },
        'set-preserves-pitch!'() { throw new Error('DOM not available in this environment'); },
        'ready-state'() { throw new Error('DOM not available in this environment'); },
        'seekable'() { throw new Error('DOM not available in this environment'); },
        'seeking'() { throw new Error('DOM not available in this environment'); },
        'sink-id'() { throw new Error('DOM not available in this environment'); },
        'src'() { throw new Error('DOM not available in this environment'); },
        'set-src!'() { throw new Error('DOM not available in this environment'); },
        'src-object'() { throw new Error('DOM not available in this environment'); },
        'set-src-object!'() { throw new Error('DOM not available in this environment'); },
        'text-tracks'() { throw new Error('DOM not available in this environment'); },
        'video-tracks'() { throw new Error('DOM not available in this environment'); },
        'volume'() { throw new Error('DOM not available in this environment'); },
        'set-volume!'() { throw new Error('DOM not available in this environment'); },
        'add-text-track!'() { throw new Error('DOM not available in this environment'); },
        'can-play-type'() { throw new Error('DOM not available in this environment'); },
        'capture-stream'() { throw new Error('DOM not available in this environment'); },
        'fast-seek!'() { throw new Error('DOM not available in this environment'); },
        'load!'() { throw new Error('DOM not available in this environment'); },
        'pause'() { throw new Error('DOM not available in this environment'); },
        'play'() { throw new Error('DOM not available in this environment'); },
        'set-media-keys!'() { throw new Error('DOM not available in this environment'); },
        'set-sink-id!'() { throw new Error('DOM not available in this environment'); },
    },
    // Image
    'image': hasDOM ? {
        'new': ((width, height) => {
            const w = from_fasl(width);
            const h = from_fasl(height);
            if (w === undefined && h === undefined) {
                return new Image();
            } else if (h === undefined) {
                return new Image(w);
            } else {
                return new Image(w, h);
            }
        }),
        'alt': (img => img.alt),
        'set-alt!': ((img, alt) => { img.alt = from_fasl(alt); }),
        'src': (img => img.src),
        'set-src!': ((img, src) => { img.src = from_fasl(src); }),
        'srcset': (img => img.srcset),
        'set-srcset!': ((img, s) => { img.srcset = from_fasl(s); }),
        'sizes': (img => img.sizes),
        'set-sizes!': ((img, s) => { img.sizes = from_fasl(s); }),
        'cross-origin': (img => img.crossOrigin),
        'set-cross-origin!': ((img, o) => { img.crossOrigin = from_fasl(o); }),
        'use-map': (img => img.useMap),
        'set-use-map!': ((img, m) => { img.useMap = from_fasl(m); }),
        'is-map': (img => img.isMap ? 1 : 0),
        'set-is-map!': ((img, flag) => { img.isMap = !!flag; }),
        'width': (img => img.width),
        'set-width!': ((img, w) => { img.width = w; }),
        'height': (img => img.height),
        'set-height!': ((img, h) => { img.height = h; }),
        'natural-width': (img => img.naturalWidth),
        'natural-height': (img => img.naturalHeight),
        'complete': (img => img.complete ? 1 : 0),
        'current-src': (img => img.currentSrc),
        'decoding': (img => img.decoding),
        'set-decoding!': ((img, d) => { img.decoding = from_fasl(d); }),
        'fetch-priority': (img => img.fetchPriority),
        'set-fetch-priority!': ((img, p) => { img.fetchPriority = from_fasl(p); }),
        'loading': (img => img.loading),
        'set-loading!': ((img, l) => { img.loading = from_fasl(l); }),
        'referrer-policy': (img => img.referrerPolicy),
        'set-referrer-policy!': ((img, p) => { img.referrerPolicy = from_fasl(p); }),
        'name': (img => img.name),
        'set-name!': ((img, n) => { img.name = from_fasl(n); }),
        'x': (img => img.x),
        'y': (img => img.y),
        'decode': (img => img.decode())
    } : {
        'new'() { throw new Error('DOM not available in this environment'); },
        'alt'() { throw new Error('DOM not available in this environment'); },
        'set-alt!'() { throw new Error('DOM not available in this environment'); },
        'src'() { throw new Error('DOM not available in this environment'); },
        'set-src!'() { throw new Error('DOM not available in this environment'); },
        'srcset'() { throw new Error('DOM not available in this environment'); },
        'set-srcset!'() { throw new Error('DOM not available in this environment'); },
        'sizes'() { throw new Error('DOM not available in this environment'); },
        'set-sizes!'() { throw new Error('DOM not available in this environment'); },
        'cross-origin'() { throw new Error('DOM not available in this environment'); },
        'set-cross-origin!'() { throw new Error('DOM not available in this environment'); },
        'use-map'() { throw new Error('DOM not available in this environment'); },
        'set-use-map!'() { throw new Error('DOM not available in this environment'); },
        'is-map'() { throw new Error('DOM not available in this environment'); },
        'set-is-map!'() { throw new Error('DOM not available in this environment'); },
        'width'() { throw new Error('DOM not available in this environment'); },
        'set-width!'() { throw new Error('DOM not available in this environment'); },
        'height'() { throw new Error('DOM not available in this environment'); },
        'set-height!'() { throw new Error('DOM not available in this environment'); },
        'natural-width'() { throw new Error('DOM not available in this environment'); },
        'natural-height'() { throw new Error('DOM not available in this environment'); },
        'complete'() { throw new Error('DOM not available in this environment'); },
        'current-src'() { throw new Error('DOM not available in this environment'); },
        'decoding'() { throw new Error('DOM not available in this environment'); },
        'set-decoding!'() { throw new Error('DOM not available in this environment'); },
        'fetch-priority'() { throw new Error('DOM not available in this environment'); },
        'set-fetch-priority!'() { throw new Error('DOM not available in this environment'); },
        'loading'() { throw new Error('DOM not available in this environment'); },
        'set-loading!'() { throw new Error('DOM not available in this environment'); },
        'referrer-policy'() { throw new Error('DOM not available in this environment'); },
        'set-referrer-policy!'() { throw new Error('DOM not available in this environment'); },
        'name'() { throw new Error('DOM not available in this environment'); },
        'set-name!'() { throw new Error('DOM not available in this environment'); },
        'x'() { throw new Error('DOM not available in this environment'); },
        'y'() { throw new Error('DOM not available in this environment'); },
        'decode'() { throw new Error('DOM not available in this environment'); }
    },
    // Event
    'event': hasDOM ? {
        'new': ((type, init) => {
            const t = from_fasl(type);
            const i = from_fasl(init);
            if (i === undefined) {
                return new Event(t);
            } else {
                return new Event(t, i);
            }
        }),
        'type': (evt => evt.type),
        'target': (evt => evt.target),
        'current-target': (evt => evt.currentTarget),
        'event-phase': (evt => evt.eventPhase),
        'bubbles': (evt => evt.bubbles ? 1 : 0),
        'cancelable': (evt => evt.cancelable ? 1 : 0),
        'default-prevented': (evt => evt.defaultPrevented ? 1 : 0),
        'composed': (evt => evt.composed ? 1 : 0),
        'is-trusted': (evt => evt.isTrusted ? 1 : 0),
        'time-stamp': (evt => evt.timeStamp),
        'composed-path': (evt => evt.composedPath()),
        'prevent-default': (evt => evt.preventDefault()),
        'stop-propagation': (evt => evt.stopPropagation()),
        'stop-immediate-propagation': (evt => evt.stopImmediatePropagation())
    } : {
        'new'() { throw new Error('DOM not available in this environment'); },
        'type'() { throw new Error('DOM not available in this environment'); },
        'target'() { throw new Error('DOM not available in this environment'); },
        'current-target'() { throw new Error('DOM not available in this environment'); },
        'event-phase'() { throw new Error('DOM not available in this environment'); },
        'bubbles'() { throw new Error('DOM not available in this environment'); },
        'cancelable'() { throw new Error('DOM not available in this environment'); },
        'default-prevented'() { throw new Error('DOM not available in this environment'); },
        'composed'() { throw new Error('DOM not available in this environment'); },
        'is-trusted'() { throw new Error('DOM not available in this environment'); },
        'time-stamp'() { throw new Error('DOM not available in this environment'); },
        'composed-path'() { throw new Error('DOM not available in this environment'); },
        'prevent-default'() { throw new Error('DOM not available in this environment'); },
        'stop-propagation'() { throw new Error('DOM not available in this environment'); },
        'stop-immediate-propagation'() { throw new Error('DOM not available in this environment'); }
    },
    // EventTarget
    'event-target': hasDOM ? {
        'add-event-listener!': ((target, type, listener) => target.addEventListener(from_fasl(type), listener))
    } : {
        'add-event-listener!'() { throw new Error('DOM not available in this environment'); }
    },
    // Element
    'element': hasDOM ? {
        'append-child!':           ((parent, child)          => parent.appendChild(child)),
        'set-attribute!':          ((elem, name, value)      => elem.setAttribute(from_fasl(name), from_fasl(value))),
        'after!':                  ((elem, node)            => elem.after(node)),
        'animate':                 ((elem, keyframes, opts) => elem.animate(keyframes, opts)),
        'append!':                 ((elem, node)            => elem.append(node)),
        'attach-shadow!':          ((elem, init)            => elem.attachShadow(init)),
        'before!':                 ((elem, node)            => elem.before(node)),
        'closest':                 ((elem, sel)             => elem.closest(from_fasl(sel))),
        'computed-style-map':      ((elem)                  => elem.computedStyleMap()),
        'get-animations':          ((elem)                  => elem.getAnimations()),
        'get-attribute':           ((elem, name)            => elem.getAttribute(from_fasl(name))),
        'get-attribute-ns':        ((elem, ns, name)       => elem.getAttributeNS(from_fasl(ns), from_fasl(name))),
        'get-attribute-names':     ((elem)                  => elem.getAttributeNames()),
        'get-attribute-node':      ((elem, name)            => elem.getAttributeNode(from_fasl(name))),
        'get-attribute-node-ns':   ((elem, ns, name)       => elem.getAttributeNodeNS(from_fasl(ns), from_fasl(name))),
        'get-bounding-client-rect':((elem)                  => elem.getBoundingClientRect()),
        'get-client-rects':        ((elem)                  => elem.getClientRects()),
        'get-elements-by-class-name': ((elem, class_name)   => elem.getElementsByClassName(from_fasl(class_name))),
        'get-elements-by-tag-name':  ((elem, name)          => elem.getElementsByTagName(from_fasl(name))),
        'get-elements-by-tag-name-ns': ((elem, ns, name)    => elem.getElementsByTagNameNS(from_fasl(ns), from_fasl(name))),
        'has-attribute':           ((elem, name)            => elem.hasAttribute(from_fasl(name)) ? 1 : 0),
        'has-attribute-ns':        ((elem, ns, name)       => elem.hasAttributeNS(from_fasl(ns), from_fasl(name)) ? 1 : 0),
        'has-attributes':          ((elem)                  => elem.hasAttributes() ? 1 : 0),
        'has-pointer-capture':     ((elem, id)             => elem.hasPointerCapture(id) ? 1 : 0),
        'insert-adjacent-element!':((elem, pos, newElem)   => elem.insertAdjacentElement(from_fasl(pos), newElem)),
        'insert-adjacent-html!':   ((elem, pos, data)      => elem.insertAdjacentHTML(from_fasl(pos), from_fasl(data))),
        'insert-adjacent-text!':   ((elem, pos, data)      => elem.insertAdjacentText(from_fasl(pos), from_fasl(data))),
        'matches':                 ((elem, sel)            => elem.matches(from_fasl(sel)) ? 1 : 0),
        'prepend!':                ((elem, node)           => elem.prepend(node)),
        'query-selector':          ((elem, sel)            => elem.querySelector(from_fasl(sel))),
        'query-selector-all':      ((elem, sel)            => elem.querySelectorAll(from_fasl(sel))),
        'release-pointer-capture!':((elem, id)             => elem.releasePointerCapture(id)),
        'remove!':                 ((elem)                  => elem.remove()),
        'remove-attribute!':       ((elem, name)            => elem.removeAttribute(from_fasl(name))),
        'remove-attribute-ns!':    ((elem, ns, name)       => elem.removeAttributeNS(from_fasl(ns), from_fasl(name))),
        'remove-attribute-node!':  ((elem, attr)           => elem.removeAttributeNode(attr)),
        'replace-children!':       ((elem, node)           => elem.replaceChildren(node)),
        'replace-with!':           ((elem, node)           => elem.replaceWith(node)),
        'request-fullscreen':      ((elem)                  => elem.requestFullscreen()),
        'request-pointer-lock':    ((elem)                  => elem.requestPointerLock()),
        'scroll!':                 ((elem, x, y)           => elem.scroll(x, y)),
        'scroll-by!':              ((elem, x, y)           => elem.scrollBy(x, y)),
        'scroll-into-view!':       ((elem, b)              => elem.scrollIntoView(!!b)),
        'scroll-to!':              ((elem, x, y)           => elem.scrollTo(x, y)),
        'set-attribute-ns!':       ((elem, ns, name, value)=> elem.setAttributeNS(from_fasl(ns), from_fasl(name), from_fasl(value))),
        'set-attribute-node!':     ((elem, attr)           => elem.setAttributeNode(attr)),
        'set-attribute-node-ns!':  ((elem, attr)           => elem.setAttributeNodeNS(attr)),
        'set-pointer-capture!':    ((elem, id)             => elem.setPointerCapture(id)),
        'toggle-attribute!':       ((elem, name, force)    => elem.toggleAttribute(from_fasl(name), !!force) ? 1 : 0),
    } : {
        'append-child!'()             { throw new Error('DOM not available in this environment'); },
        'set-attribute!'()            { throw new Error('DOM not available in this environment'); },
        'after!'()                    { throw new Error('DOM not available in this environment'); },
        'animate'()                   { throw new Error('DOM not available in this environment'); },
        'append!'()                   { throw new Error('DOM not available in this environment'); },
        'attach-shadow!'()            { throw new Error('DOM not available in this environment'); },
        'before!'()                   { throw new Error('DOM not available in this environment'); },
        'closest'()                   { throw new Error('DOM not available in this environment'); },
        'computed-style-map'()        { throw new Error('DOM not available in this environment'); },
        'get-animations'()            { throw new Error('DOM not available in this environment'); },
        'get-attribute'()             { throw new Error('DOM not available in this environment'); },
        'get-attribute-ns'()          { throw new Error('DOM not available in this environment'); },
        'get-attribute-names'()       { throw new Error('DOM not available in this environment'); },
        'get-attribute-node'()        { throw new Error('DOM not available in this environment'); },
        'get-attribute-node-ns'()     { throw new Error('DOM not available in this environment'); },
        'get-bounding-client-rect'()  { throw new Error('DOM not available in this environment'); },
        'get-client-rects'()          { throw new Error('DOM not available in this environment'); },
        'get-elements-by-class-name'(){ throw new Error('DOM not available in this environment'); },
        'get-elements-by-tag-name'()  { throw new Error('DOM not available in this environment'); },
        'get-elements-by-tag-name-ns'(){ throw new Error('DOM not available in this environment'); },
        'has-attribute'()             { throw new Error('DOM not available in this environment'); },
        'has-attribute-ns'()          { throw new Error('DOM not available in this environment'); },
        'has-attributes'()            { throw new Error('DOM not available in this environment'); },
        'has-pointer-capture'()       { throw new Error('DOM not available in this environment'); },
        'insert-adjacent-element!'()  { throw new Error('DOM not available in this environment'); },
        'insert-adjacent-html!'()     { throw new Error('DOM not available in this environment'); },
        'insert-adjacent-text!'()     { throw new Error('DOM not available in this environment'); },
        'matches'()                   { throw new Error('DOM not available in this environment'); },
        'prepend!'()                  { throw new Error('DOM not available in this environment'); },
        'query-selector'()            { throw new Error('DOM not available in this environment'); },
        'query-selector-all'()        { throw new Error('DOM not available in this environment'); },
        'release-pointer-capture!'()  { throw new Error('DOM not available in this environment'); },
        'remove!'()                   { throw new Error('DOM not available in this environment'); },
        'remove-attribute!'()         { throw new Error('DOM not available in this environment'); },
        'remove-attribute-ns!'()      { throw new Error('DOM not available in this environment'); },
        'remove-attribute-node!'()    { throw new Error('DOM not available in this environment'); },
        'replace-children!'()         { throw new Error('DOM not available in this environment'); },
        'replace-with!'()             { throw new Error('DOM not available in this environment'); },
        'request-fullscreen'()        { throw new Error('DOM not available in this environment'); },
        'request-pointer-lock'()      { throw new Error('DOM not available in this environment'); },
        'scroll!'()                   { throw new Error('DOM not available in this environment'); },
        'scroll-by!'()                { throw new Error('DOM not available in this environment'); },
        'scroll-into-view!'()         { throw new Error('DOM not available in this environment'); },
        'scroll-to!'()                { throw new Error('DOM not available in this environment'); },
        'set-attribute-ns!'()         { throw new Error('DOM not available in this environment'); },
        'set-attribute-node!'()       { throw new Error('DOM not available in this environment'); },
        'set-attribute-node-ns!'()    { throw new Error('DOM not available in this environment'); },
        'set-pointer-capture!'()      { throw new Error('DOM not available in this environment'); },
        'toggle-attribute!'()         { throw new Error('DOM not available in this environment'); },
    },
    'xterm-terminal': hasXterm ? {
        'create': (options => {
            const opts = from_fasl(options);
            return opts === undefined ? new Terminal() : new Terminal(opts);
        }),
        'buffer': (term => term.buffer),
        'cols': (term => term.cols),
        'rows': (term => term.rows),
        'element': (term => term.element),
        'textarea': (term => term.textarea),
        'markers':  (term => term.markers),
        'modes':    (term => term.modes),
        'options': (term => term.options),
        'set-options!': ((term, options) => {
            const opts = from_fasl(options);
            if (opts !== undefined) {
                term.options = opts;
            }
        }),
        'parser': (term => term.parser),
        'unicode': (term => term.unicode),
        'on-bell': (term => term.onBell),
        'on-binary': (term => term.onBinary),
        'on-cursor-move': (term => term.onCursorMove),
        'on-data': (term => term.onData),
        'on-key': (term => term.onKey),
        'on-line-feed': (term => term.onLineFeed),
        'on-render': (term => term.onRender),
        'on-resize': (term => term.onResize),
        'on-scroll': (term => term.onScroll),
        'on-selection-change': (term => term.onSelectionChange),
        'on-title-change': (term => term.onTitleChange),
        'on-write-parsed': (term => term.onWriteParsed),
        'attach-custom-key-event-handler': ((term, handler) => { term.attachCustomKeyEventHandler(handler); }),
        'attach-custom-wheel-event-handler': ((term, handler) => { term.attachCustomWheelEventHandler(handler); }),
        'blur': (term => { term.blur(); }),
        'focus': (term => { term.focus(); }),
        'dispose': (term => { term.dispose(); }),
        'clear': (term => { term.clear(); }),
        'clear-selection': (term => { term.clearSelection(); }),
        'clear-texture-atlas': (term => { term.clearTextureAtlas(); }),
        'deregister-character-joiner': ((term, joinerId) => { term.deregisterCharacterJoiner(joinerId); }),
        'get-selection': (term => term.getSelection()),
        'get-selection-position': (term => term.getSelectionPosition()),
        'has-selection': (term => term.hasSelection() ? 1 : 0),
        'input': ((term, data, wasUserInput) => {
            const d = from_fasl(data);
            const w = from_fasl(wasUserInput);
            if (w === undefined) {
                term.input(d);
            } else {
                term.input(d, w);
            }
        }),
        'load-addon': ((term, addon) => { term.loadAddon(addon); }),
        'open': ((term, parent) => { term.open(parent); }),
        'paste': ((term, data) => { term.paste(from_fasl(data)); }),
        'refresh': ((term, start, end) => { term.refresh(start, end); }),
        'register-character-joiner': ((term, handler) => term.registerCharacterJoiner(handler)),
        'register-decoration': ((term, options) => term.registerDecoration(options)),
        'register-link-provider': ((term, provider) => term.registerLinkProvider(provider)),
        'register-marker': ((term, cursorYOffset) => {
            const offset = from_fasl(cursorYOffset);
            return offset === undefined ? term.registerMarker() : term.registerMarker(offset);
        }),
        'reset': (term => { term.reset(); }),
        'resize': ((term, columns, rows) => { term.resize(columns, rows); }),
        'scroll-lines': ((term, amount) => { term.scrollLines(amount); }),
        'scroll-pages': ((term, pageCount) => { term.scrollPages(pageCount); }),
        'scroll-to-bottom': (term => { term.scrollToBottom(); }),
        'scroll-to-line': ((term, line) => { term.scrollToLine(line); }),
        'scroll-to-top': (term => { term.scrollToTop(); }),
        'select': ((term, column, row, length) => { term.select(column, row, length); }),
        'select-all': (term => { term.selectAll(); }),
        'select-lines': ((term, start, end) => { term.selectLines(start, end); }),
        'write': ((term, data, callback) => {
            const d = from_fasl(data);
            const cb = from_fasl(callback);
            if (cb === undefined) {
                term.write(d);
            } else {
                term.write(d, cb);
            }
        }),
        'writeln': ((term, data, callback) => {
            const d = from_fasl(data);
            const cb = from_fasl(callback);
            if (cb === undefined) {
                term.writeln(d);
            } else {
                term.writeln(d, cb);
            }
        })
    } : new Proxy({}, { get() { throw new Error('xterm.js not available in this environment'); } }),
    // Fir AddOn for Xtermjs
    'xterm-fit-addon': true // hasFitAddon
                       ? {
        'create':   (()                => new FitAddon()),
        'activate': ((addon, terminal) => { addon.activate(terminal); }),
        'dispose':   (addon            => { addon.dispose(); }),
        'fit':       (addon            => { addon.fit(); }),
        'propose-dimensions': (addon => {
            const dims = addon.proposeDimensions();
            if (dims === undefined || dims === null) {
                return to_fasl(undefined);
            }
            const colsPair = { tag: 'pair', car: Symbol.for('cols'), cdr: dims.cols };
            const rowsPair = { tag: 'pair', car: Symbol.for('rows'), cdr: dims.rows };
            const alist = {
                tag: 'pair',
                car: colsPair,
                cdr: { tag: 'pair', car: rowsPair, cdr: null }
            };
            return to_fasl(alist);
        })
    } : new Proxy({}, { get() { throw new Error('xterm.js fit addon not available in this environment'); } }),
    // JSXGraph Point
    'jsx-point': hasDOM ? {
        'is-point':                    (v => boolean_to_i32(JXG.isPoint(v))),
        'attractor-distance':          (pt => pt.attractorDistance),
        'set-attractor-distance!':     ((pt, d) => { pt.attractorDistance = d; }),
        'attractors':                  (pt => pt.attractors),
        'set-attractors!':             ((pt, a) => { pt.attractors = a; }),
        'attractor-unit':              (pt => pt.attractorUnit),
        'set-attractor-unit!':         ((pt, u) => { pt.attractorUnit = from_fasl(u); }),
        'attract-to-grid':             (pt => pt.attractToGrid ? 1 : 0),
        'set-attract-to-grid!':        ((pt, flag) => { pt.attractToGrid = !!flag; }),
        'face':                        (pt => pt.face),
        'set-face!':                   ((pt, f) => { pt.face = from_fasl(f); }),
        'ignored-snap-to-points':      (pt => pt.ignoredSnapToPoints),
        'set-ignored-snap-to-points!': ((pt, p) => { pt.ignoredSnapToPoints = p; }),
        'infobox-digits':              (pt => pt.infoboxDigits),
        'set-infobox-digits!':         ((pt, n) => { pt.infoboxDigits = n; }),
        'show-infobox':                (pt => pt.showInfobox ? 1 : 0),
        'set-show-infobox!':           ((pt, flag) => { pt.showInfobox = !!flag; }),
        'size':                        (pt => pt.size),
        'set-size!':                   ((pt, s) => { pt.size = s; }),
        'size-unit':                   (pt => pt.sizeUnit),
        'set-size-unit!':              ((pt, u) => { pt.sizeUnit = from_fasl(u); }),
        'snap-size-x':                 (pt => pt.snapSizeX),
        'set-snap-size-x!':            ((pt, x) => { pt.snapSizeX = x; }),
        'snap-size-y':                 (pt => pt.snapSizeY),
        'set-snap-size-y!':            ((pt, y) => { pt.snapSizeY = y; }),
        'snap-to-grid':                (pt => pt.snapToGrid ? 1 : 0),
        'set-snap-to-grid!':           ((pt, flag) => { pt.snapToGrid = !!flag; }),
        'snap-to-points':              (pt => pt.snapToPoints ? 1 : 0),
        'set-snap-to-points!':         ((pt, flag) => { pt.snapToPoints = !!flag; }),
        'snatch-distance':             (pt => pt.snatchDistance),
        'set-snatch-distance!':        ((pt, d) => { pt.snatchDistance = d; }),
        'style':                       (pt => pt.style),
        'set-style!':                  ((pt, s) => { pt.style = s; }),
        'x':                           (pt => pt.X()),
        'y':                           (pt => pt.Y()),
        'zoom':                        (pt => pt.zoom ? 1 : 0),
        'set-zoom!':                   ((pt, flag) => { pt.zoom = !!flag; }),
        'has-point':                   ((pt, x, y) => pt.hasPoint(x, y) ? 1 : 0),
        'is-on':                       ((pt, el, tol) => pt.isOn(el, tol) ? 1 : 0),
        'make-intersection!':          ((pt, el1, el2, i, j) => { pt.makeIntersection(el1, el2, i, j); }),
        'normalize-face':              ((pt, s) => pt.normalizeFace(from_fasl(s))),
        'call-set-style!':             ((pt, i) => { pt.setStyle(i); }),
        'update!':                     ((pt, flag) => { pt.update(!!flag); }),
        'update-renderer!':            (pt => { pt.updateRenderer(); }),
        'update-transform!':           ((pt, flag) => pt.updateTransform(!!flag))
    } : {
        'is-point'()                    { throw new Error('DOM not available in this environment'); },
        'attractor-distance'()          { throw new Error('DOM not available in this environment'); },
        'set-attractor-distance!'()     { throw new Error('DOM not available in this environment'); },
        'attractors'()                  { throw new Error('DOM not available in this environment'); },
        'set-attractors!'()             { throw new Error('DOM not available in this environment'); },
        'attractor-unit'()              { throw new Error('DOM not available in this environment'); },
        'set-attractor-unit!'()         { throw new Error('DOM not available in this environment'); },
        'attract-to-grid'()             { throw new Error('DOM not available in this environment'); },
        'set-attract-to-grid!'()        { throw new Error('DOM not available in this environment'); },
        'face'()                        { throw new Error('DOM not available in this environment'); },
        'set-face!'()                   { throw new Error('DOM not available in this environment'); },
        'ignored-snap-to-points'()      { throw new Error('DOM not available in this environment'); },
        'set-ignored-snap-to-points!'() { throw new Error('DOM not available in this environment'); },
        'infobox-digits'()              { throw new Error('DOM not available in this environment'); },
        'set-infobox-digits!'()         { throw new Error('DOM not available in this environment'); },
        'show-infobox'()                { throw new Error('DOM not available in this environment'); },
        'set-show-infobox!'()           { throw new Error('DOM not available in this environment'); },
        'size'()                        { throw new Error('DOM not available in this environment'); },
        'set-size!'()                   { throw new Error('DOM not available in this environment'); },
        'size-unit'()                   { throw new Error('DOM not available in this environment'); },
        'set-size-unit!'()              { throw new Error('DOM not available in this environment'); },
        'snap-size-x'()                 { throw new Error('DOM not available in this environment'); },
        'set-snap-size-x!'()            { throw new Error('DOM not available in this environment'); },
        'snap-size-y'()                 { throw new Error('DOM not available in this environment'); },
        'set-snap-size-y!'()            { throw new Error('DOM not available in this environment'); },
        'snap-to-grid'()                { throw new Error('DOM not available in this environment'); },
        'set-snap-to-grid!'()           { throw new Error('DOM not available in this environment'); },
        'snap-to-points'()              { throw new Error('DOM not available in this environment'); },
        'set-snap-to-points!'()         { throw new Error('DOM not available in this environment'); },
        'snatch-distance'()             { throw new Error('DOM not available in this environment'); },
        'set-snatch-distance!'()        { throw new Error('DOM not available in this environment'); },
        'style'()                       { throw new Error('DOM not available in this environment'); },
        'set-style!'()                  { throw new Error('DOM not available in this environment'); },
        'x'()                           { throw new Error('DOM not available in this environment'); },
        'y'()                           { throw new Error('DOM not available in this environment'); },
        'zoom'()                        { throw new Error('DOM not available in this environment'); },
        'set-zoom!'()                   { throw new Error('DOM not available in this environment'); },
        'has-point'()                   { throw new Error('DOM not available in this environment'); },
        'is-on'()                       { throw new Error('DOM not available in this environment'); },
        'make-intersection!'()          { throw new Error('DOM not available in this environment'); },
        'normalize-face'()              { throw new Error('DOM not available in this environment'); },
        'call-set-style!'()             { throw new Error('DOM not available in this environment'); },
        'update!'()                     { throw new Error('DOM not available in this environment'); },
        'update-renderer!'()            { throw new Error('DOM not available in this environment'); },
        'update-transform!'()           { throw new Error('DOM not available in this environment'); }
    }
};

const wasmModule
      = await WebAssembly
      .instantiate(wasmBuffer, imports)
      .then(results  => { const { entry, get_bytes, copy_bytes_to_memory, callback } = results.instance.exports;
                          callback_export = callback;
                          var result = entry();
                          // console.log( "Output:")
                          // console.log( output_string );
                          // console.log( "Result:")
                          // console.log( result );

                          // console.log( "Result bytes:" )
                          const bytes  = new Uint8Array(memory.buffer, 0, result);
                          console.log(new TextDecoder().decode(bytes));
                        });

