// Generated by "assembler.rkt".
import fs from 'node:fs/promises';

const wasmBuffer = await fs.readFile("out.wasm");

var memory = new WebAssembly.Memory({initial:1024});

var output_string = [];

function read_u32(arr, i) {
  return ((arr[i] << 24) | (arr[i + 1] << 16) |
          (arr[i + 2] << 8)  | arr[i + 3]) >>> 0;
}

function fasl_to_js_value(arr, i = 0) {

  const tag = arr[i++];

  function u32() {
    const v = read_u32(arr, i);
    i += 4;
    return v;
  }

  function read_bytes() {
    const len = u32();
    const b = arr.slice(i, i + len);
    i += len;
    return b;
  }

  function read_string() {
    const b = read_bytes();
    return new TextDecoder().decode(b);
  }

  switch(tag) {
    case 0: {
      const raw = u32();
      // Sign-extend the 30-bit payload so negative fixnums decode correctly.
      return [(raw << 2) >> 2, i];
    }
    case 1:
      return [String.fromCodePoint(u32()), i];
    case 2:
      return [Symbol.for(read_string()), i];
    case 3:
      return [read_string(), i];
    case 4:
      return [read_bytes(), i];
    case 5:
      return [arr[i++] !== 0, i];
    case 6:
      return [null, i];
    case 7: {
      let car, cdr;
      [car, i] = fasl_to_js_value(arr, i);
      [cdr, i] = fasl_to_js_value(arr, i);
      return [{tag:'pair', car, cdr}, i];
    }
    case 8: {
      const n = u32();
      const vec = new Array(n);
      for(let j = 0; j < n; j++) {
        [vec[j], i] = fasl_to_js_value(arr, i);
      }
      return [vec, i];
    }
    case 9: {
      const hi = u32();
      const lo = u32();
      const dv = new DataView(new ArrayBuffer(8));
      dv.setUint32(0, hi);
      dv.setUint32(4, lo);
      return [dv.getFloat64(0), i];
    }
    case 10:
      return [undefined, i];
    case 11:
      return ['<eof>', i];
    default:
      throw new Error('bad FASL tag ' + tag);
  }
}

function js_value_to_fasl(v) {
  const out = [];
  const enc = new TextEncoder();

  // --- low-level writers (big-endian) ---
  function writeByte(b) {
    out.push(b & 0xFF);
  }
  function writeU32(u) {
    out.push((u >>> 24) & 0xFF, (u >>> 16) & 0xFF, (u >>> 8) & 0xFF, u & 0xFF);
  }
  function writeBytes(u8) {
    writeU32(u8.length >>> 0);
    for (let i = 0; i < u8.length; i++) out.push(u8[i] & 0xFF);
  }
  function writeString(s) {
    const u8 = enc.encode(s);
    writeBytes(u8);
  }
  function writeF64(x) {
    const dv = new DataView(new ArrayBuffer(8));
    // Big-endian
    dv.setFloat64(0, x, false);
    const hi = dv.getUint32(0, false);
    const lo = dv.getUint32(4, false);
    writeU32(hi);
    writeU32(lo);
  }

  // --- tagged writers ---
  function writeFixnum(n) {
    // 30-bit signed two's complement payload; range: [-2^29, 2^29-1]
    if (!Number.isInteger(n) || n < -(1 << 29) || n > ((1 << 29) - 1)) {
      throw new RangeError("fixnum out of 30-bit range");
    }
    writeByte(0);
    const raw30 = n & 0x3FFFFFFF; // 30-bit two's complement payload
    writeU32(raw30 >>> 0);
  }
  function writeFlonum(x) {
    writeByte(9);
    writeF64(x);
  }
  function writeCharacter(cp) {
    // cp = Unicode scalar value (number)
    writeByte(1);
    writeU32(cp >>> 0);
  }
  function writeSymbol(name) {
    writeByte(2);
    writeString(name);
  }
  function writeStringVal(s) {
    writeByte(3);
    writeString(s);
  }
  function writeBytesVal(u8) {
    writeByte(4);
    writeBytes(u8);
  }
  function writeBoolean(b) {
    writeByte(5);
    writeByte(b ? 1 : 0);
  }
  function writeNull() {
    writeByte(6);
  }
  function writeVoid() {
    writeByte(10);
  }
  function writeEof() {
    writeByte(11);
  }
  function writePair(car, cdr) {
    writeByte(7);
    writeAny(car);
    writeAny(cdr);
  }
  function writeVector(arr) {
    writeByte(8);
    writeU32(arr.length >>> 0);
    for (let i = 0; i < arr.length; i++) writeAny(arr[i]);
  }

  // --- main dispatcher (mirrors fasl_to_js_value mapping) ---
  function writeAny(x) {
    // Fast paths by JS type
    if (typeof x === "number") {
      if (Number.isInteger(x) && x >= -(1 << 29) && x <= ((1 << 29) - 1)) {
        writeFixnum(x);
      } else {
        writeFlonum(x);
      }
      return;
    }
    if (typeof x === "boolean") {
      writeBoolean(x);
      return;
    }
    if (x === null) {
      writeNull();
      return;
    }
    if (x === undefined) {
      writeVoid();
      return;
    }
    // EoF sentinel (match your decoder's '<eof>' convention)
    if (x === "<eof>" || (x && x.tag === "eof")) {
      writeEof();
      return;
    }
    // Character (two accepted forms)
    //   { tag: 'char', cp: <codepoint> }  or  { tag: 'char', ch: 'A' }
    if (x && x.tag === "char") {
      const cp = typeof x.cp === "number" ? x.cp
               : (typeof x.ch === "string" ? x.ch.codePointAt(0) : undefined);
      if (cp === undefined) throw new TypeError("bad char object");
      writeCharacter(cp >>> 0);
      return;
    }
    // Pair (your decoder uses {tag:'pair', car, cdr})
    if (x && x.tag === "pair") {
      writePair(x.car, x.cdr);
      return;
    }
    // Bytes: prefer Uint8Array
    if (x instanceof Uint8Array) {
      writeBytesVal(x);
      return;
    }
    // Accept raw byte arrays too
    if (Array.isArray(x) && x.every(n => Number.isInteger(n) && n >= 0 && n <= 255)) {
      writeBytesVal(Uint8Array.from(x));
      return;
    }
    // Vector: plain JS Array (distinct from bytes above)
    if (Array.isArray(x)) {
      writeVector(x);
      return;
    }
    // Symbol
    if (typeof x === "symbol") {
      const name = Symbol.keyFor(x) ?? x.description ?? "";
      writeSymbol(name);
      return;
    }
    // String
    if (typeof x === "string") {
      writeStringVal(x);
      return;
    }
    throw new TypeError("unsupported value for FASL encoding: " + String(x));
  }
  writeAny(v);
  return Uint8Array.from(out);
}

function testsuite(js_value_to_fasl, fasl_to_js_value, { log = true } = {}) {
  // --- helpers -------------------------------------------------------------
  function charToString(v) {
    if (typeof v === 'string' && v.length === 1) return v;
    if (v && typeof v === 'object' && v.tag === 'char' && typeof v.cp === 'number') {
      try { return String.fromCodePoint(v.cp); } catch { /* fall through */ }
    }
    return null;
  }

  function deepEq(a, b) {
    // Treat "char-wrappers" and 1-char strings as equal
    const ac = charToString(a), bc = charToString(b);
    if (ac !== null || bc !== null) return ac === bc;
    // numbers (handle NaN, -0)
    if (typeof a === 'number' || typeof b === 'number') return Object.is(a, b);
    // Uint8Array (bytes)
    if (a instanceof Uint8Array && b instanceof Uint8Array) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
      return true;
    }
    // Symbols (use registry key or description)
    if (typeof a === 'symbol' && typeof b === 'symbol') {
      const ka = Symbol.keyFor(a) ?? a.description ?? '';
      const kb = Symbol.keyFor(b) ?? b.description ?? '';
      return ka === kb;
    }
    // Pairs
    if (a && b && a.tag === 'pair' && b.tag === 'pair') {
      return deepEq(a.car, b.car) && deepEq(a.cdr, b.cdr);
    }
    // Arrays (vectors)
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) if (!deepEq(a[i], b[i])) return false;
      return true;
    }
    // Strings, booleans, null, undefined, "<eof>"
    return a === b;
  }
  function roundtrip(v) {
    const bytes = js_value_to_fasl(v);
    const [v2] = fasl_to_js_value(bytes);
    const ok = deepEq(v2, v);
    if (!ok && log) {
      console.error('Roundtrip mismatch:', v, '->', v2, 'bytes=', bytes);
    }
    return ok;
  }
  function test(name, v) {
    const ok = roundtrip(v);
    results.push({ name, ok });
    if (log) console.log(`${ok ? 'âœ“' : 'âœ—'} ${name}`);
    if (ok) pass++; else fail++;
  }

  // --- run tests -----------------------------------------------------------
  const results = [];
  let pass = 0, fail = 0;

  // Fixnums (30-bit)
  test('fixnum 0', 0);
  test('fixnum 123', 123);
  test('fixnum -5', -5);
  // Flonums
  test('flonum 1.5', 1.5);
  test('flonum -0.0', -0.0);
  test('flonum NaN', NaN);
  test('flonum +Inf', Infinity);
  test('flonum -Inf', -Infinity);
  // Booleans / null / void / eof
  test('boolean true', true);
  test('boolean false', false);
  test('null', null);
  test('void/undefined', undefined);
  test('eof sentinel', '<eof>');
  // Characters (encode via wrapper; decoder yields 1-char string)
  test('char A', { tag: 'char', cp: 'A'.codePointAt(0) });
  test('char snowman', { tag: 'char', cp: 'â˜ƒ'.codePointAt(0) });
  // Symbols
  test('symbol foo', Symbol.for('foo'));
  // Bytes (Uint8Array)
  test('bytes', new Uint8Array([0, 1, 2, 255]));
  // Pairs
  test('pair (1 . null)', { tag: 'pair', car: 1, cdr: null });
  test('list (1 2)',
       { tag: 'pair', car: 1, cdr: { tag: 'pair', car: 2, cdr: null } });
  // Vectors (arrays)
  test('vector mixed',
       [ 1, 2.5, { tag: 'pair', car: 'x', cdr: null }, true ]);
  // Strings
  test('string ascii', 'hello');
  test('string utf8', 'hÃ©llÃ¸ ðŸŒ');

  return { pass, fail, total: pass + fail, results };
}

// Uncomment to run the testsuite for fasl.
// Currently the only failing test is the one for -0.0 which after the round trip becomes 0.0.
// This is not fixabable as long as we convert integers to fixnums.

// const summary = testsuite(js_value_to_fasl, fasl_to_js_value, { log: true });
// console.log(`\nPassed: ${summary.pass}/${summary.total}`);
// if (summary.fail) {
//   console.log('Failures:');
//    for (const r of summary.results.filter(r => !r.ok)) {
//    console.log('  -', r.name);
//  }
// }

// hasDOM gives us a way of determining whether the host is a browser or Node
const hasDOM = typeof document !== 'undefined' && typeof document.createTextNode === 'function';

function from_fasl(index) {
    return fasl_to_js_value(new Uint8Array(memory.buffer), index)[0]
}

var imports = {
    'env': {
        'memory': memory
    },
    'primitives': {
      'console_log': ((x)   => console.log(x)),
      'add':         ((x,y) => x+y),
      'js_output':   ((x)   => output_string.push(x)),
      'js_print_fasl': ((start, len) => {
        const bytes = new Uint8Array(memory.buffer).slice(start, start + len);
        const [v] = fasl_to_js_value(bytes);
        console.log(v);
      })
    },
    document: hasDOM ? {
        // Browser
        'body':             (()                  => document.body),
        'create-text-node': ((fasl_start)        => document.createTextNode(from_fasl(fasl_start))),
        'create-element':   ((local_name)        => document.createElement(from_fasl(local_name))),
    }
    : { // Node
        'body'()             { throw new Error('DOM not available in this environment'); },
        'create-text-node'() { throw new Error('DOM not available in this environment'); },
        'create-element'()   { throw new Error('DOM not available in this environment'); },
    },
    element: hasDOM ? {
        'append-child!':    ((parent, child)     => parent.appendChild(child)),
        'set-attribute!':   ((elem, name, value) => elem.setAttribute(from_fasl(name), from_fasl(value))),
    }
    : { // Node
        'append-child!'()    { throw new Error('DOM not available in this environment'); },
        'set-attribute!'()   { throw new Error('DOM not available in this environment'); },
    }
};

const wasmModule
      = await WebAssembly
      .instantiate(wasmBuffer, imports)
      .then(results  => { const { entry, get_bytes, copy_bytes_to_memory } = results.instance.exports;
                          var result = entry();
                          // console.log( "Output:")
                          // console.log( output_string );
                          // console.log( "Result:")
                          // console.log( result );

                          // console.log( "Result bytes:" )
                          const bytes  = new Uint8Array(memory.buffer, 0, result);
                          console.log(new TextDecoder().decode(bytes));
                        });





