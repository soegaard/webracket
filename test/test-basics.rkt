(list "not"
      (and (equal? (not #t)       #f)
           (equal? (not 3)        #f)
           (equal? (not (list 3)) #f)
           (equal? (not #f)       #t)
           (equal? (not '())      #f)
           (equal? (not (list))   #f)
           (equal? (not 'nil)     #f)
           (equal? (procedure-arity not) 1))

      "boolean?"
      (and (equal? (boolean? #f)  #t)
           (equal? (boolean? #t)  #t)
           (equal? (boolean? 0)   #f)
           (equal? (boolean? '()) #f)
           (equal? (procedure-arity boolean?) 1))

      "eqv?"
      (list (equal? (eqv? 'a 'a) #t)
           (equal? (eqv? 'a 'b) #f)
           (equal? (eqv? 2 2) #t)
           (equal? (eqv? 2 2.0) #f)
           (equal? (eqv? '() '()) #t)
           (equal? (eqv? '10000 '10000) #t)
           (equal? (eqv? 10000000000000000000 10000000000000000000) #t)
           #;(equal? (eqv? 10000000000000000000 10000000000000000001) #f) ; needs bignums
           (equal? (eqv? 10000000000000000000 20000000000000000000) #f)
           (equal? (eqv? (cons 1 2) (cons 1 2)) #f)
           (equal? (eqv? (lambda () 1) (lambda () 2)) #f)
           (equal? (eqv? #f 'nil) #f)
           (let ((p (lambda (x) x)))
             (eqv? p p))
           (let ((g ((lambda ()
                       (let ((n 0))
                         (lambda () (set! n (+ n 1)) n))))))
             (eqv? g g))
           (equal? (eqv? ((lambda ()
                            (let ((n 0))
                              (lambda () (set! n (+ n 1)) n))))
                         ((lambda ()
                            (let ((n 0))
                              (lambda () (set! n (+ n 1)) n)))))
                   #f)
           #;(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
                      (g (lambda () (if (eqv? f g) 'g 'both))))
               (eqv? f g))
           (equal? (procedure-arity eqv?) 2)
      ))
